//// [tests/cases/conformance/enums/enumLiteralBasics.ts] ////

=== enumLiteralBasics.ts ===
// Enum without initializers have first member = 0 and successive members = N + 1

// Enum literal syntax does not implement auto-incrementing behaviour.
let ExistingShorthand = "exists";
>ExistingShorthand : string
>                  : ^^^^^^
>"exists" : "exists"
>         : ^^^^^^^^

const E1: enum = {
>E1 : E1
>   : ^^

    NonexistingShorthand, // error -- EnumLiteralExpressions require explicit property definitions.
>NonexistingShorthand : E1.NonexistingShorthand
>                     : ^^^^^^^^^^^^^^^^^^^^^^^

    ExistingShorthand, // error -- EnumLiteralExpressions require explicit property definitions.
>ExistingShorthand : E1.ExistingShorthand
>                  : ^^^^^^^^^^^^^^^^^^^^

    Int: 1, // ok
>Int : E1.Int
>    : ^^^^^^
>1 : 1
>  : ^

    String: "string", // ok
>String : E1.String
>       : ^^^^^^^^^
>"string" : "string"
>         : ^^^^^^^^

    Flag: 8, // ok
>Flag : E1.Flag
>     : ^^^^^^^
>8 : 8
>  : ^

};

// Valid assignments
const nonexist: E1 = E1.NonexistingShorthand; // ok
>nonexist : E1
>         : ^^
>E1.NonexistingShorthand : E1.NonexistingShorthand
>                        : ^^^^^^^^^^^^^^^^^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>NonexistingShorthand : E1.NonexistingShorthand
>                     : ^^^^^^^^^^^^^^^^^^^^^^^

const exist: E1 = E1.ExistingShorthand; // ok
>exist : E1
>      : ^^
>E1.ExistingShorthand : E1.ExistingShorthand
>                     : ^^^^^^^^^^^^^^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>ExistingShorthand : E1.ExistingShorthand
>                  : ^^^^^^^^^^^^^^^^^^^^

const ival: E1 = E1.Int; // ok
>ival : E1
>     : ^^
>E1.Int : E1.Int
>       : ^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>Int : E1.Int
>    : ^^^^^^

const sval: E1 = E1.String; // ok
>sval : E1
>     : ^^
>E1.String : E1.String
>          : ^^^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>String : E1.String
>       : ^^^^^^^^^

let p_int: E1.Int = E1.Int; // ok
>p_int : E1.Int
>      : ^^^^^^
>E1 : any
>   : ^^^
>E1.Int : E1.Int
>       : ^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>Int : E1.Int
>    : ^^^^^^

const p_nonexist: E1.NonexistingShorthand = E1.NonexistingShorthand; // ok
>p_nonexist : E1.NonexistingShorthand
>           : ^^^^^^^^^^^^^^^^^^^^^^^
>E1 : any
>   : ^^^
>E1.NonexistingShorthand : E1.NonexistingShorthand
>                        : ^^^^^^^^^^^^^^^^^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>NonexistingShorthand : E1.NonexistingShorthand
>                     : ^^^^^^^^^^^^^^^^^^^^^^^

const p_exist: E1.ExistingShorthand = E1.ExistingShorthand; // ok
>p_exist : E1.ExistingShorthand
>        : ^^^^^^^^^^^^^^^^^^^^
>E1 : any
>   : ^^^
>E1.ExistingShorthand : E1.ExistingShorthand
>                     : ^^^^^^^^^^^^^^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>ExistingShorthand : E1.ExistingShorthand
>                  : ^^^^^^^^^^^^^^^^^^^^

const p_string: E1.String = E1.String; // ok
>p_string : E1.String
>         : ^^^^^^^^^
>E1 : any
>   : ^^^
>E1.String : E1.String
>          : ^^^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>String : E1.String
>       : ^^^^^^^^^

p_int = E1.Flag; // Type 'E1.Flag' is not assignable to type 'E1.Int'.
>p_int = E1.Flag : E1.Flag
>                : ^^^^^^^
>p_int : E1.Int
>      : ^^^^^^
>E1.Flag : E1.Flag
>        : ^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>Flag : E1.Flag
>     : ^^^^^^^

p_int = E1.Int | E1.Flag;
>p_int = E1.Int | E1.Flag : number
>                         : ^^^^^^
>p_int : E1.Int
>      : ^^^^^^
>E1.Int | E1.Flag : number
>                 : ^^^^^^
>E1.Int : E1.Int
>       : ^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>Int : E1.Int
>    : ^^^^^^
>E1.Flag : E1.Flag
>        : ^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>Flag : E1.Flag
>     : ^^^^^^^

// Assigning values which are not part of the enum despite being present in the enum
const nonexist_bad: E1 = undefined; // error
>nonexist_bad : E1
>             : ^^
>undefined : undefined
>          : ^^^^^^^^^

const exist_bad: E1 = "exists"; // error
>exist_bad : E1
>          : ^^
>"exists" : "exists"
>         : ^^^^^^^^

const ival_good: E1 = 1; // ok -- TypeScript is permissive of this in enums, to permit things like bitwise combinations of enum values.
>ival_good : E1
>          : ^^
>1 : 1
>  : ^

const sval_bad: E1 = "string"; // error
>sval_bad : E1
>         : ^^
>"string" : "string"
>         : ^^^^^^^^

const ival_notpresent: E1 = 4; // ok -- TypeScript is permissive of this in enums, to permit things like bitwise combinations of enum values.
>ival_notpresent : E1
>                : ^^
>4 : 4
>  : ^

function functest(value: E1) {
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>value : E1
>      : ^^

    console.log(value);
>console.log(value) : void
>                   : ^^^^
>console.log : (...data: any[]) => void
>            : ^^^^    ^^     ^^^^^    
>console : Console
>        : ^^^^^^^
>log : (...data: any[]) => void
>    : ^^^^    ^^     ^^^^^    
>value : E1
>      : ^^

    return value;
>value : E1
>      : ^^
}

const nonexist_bad2: E1 = functest(undefined); // error
>nonexist_bad2 : E1
>              : ^^
>functest(undefined) : E1
>                    : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>undefined : undefined
>          : ^^^^^^^^^

const exist_bad2: E1 = functest("exists"); // error
>exist_bad2 : E1
>           : ^^
>functest("exists") : E1
>                   : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>"exists" : "exists"
>         : ^^^^^^^^

const ival_good2: E1 = functest(1); // ok
>ival_good2 : E1
>           : ^^
>functest(1) : E1
>            : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>1 : 1
>  : ^

const ival_good3: E1 = functest(4); // ok
>ival_good3 : E1
>           : ^^
>functest(4) : E1
>            : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>4 : 4
>  : ^

const ival_good4: E1 = functest(E1.Int | E1.Flag); // ok
>ival_good4 : E1
>           : ^^
>functest(E1.Int | E1.Flag) : E1
>                           : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>E1.Int | E1.Flag : number
>                 : ^^^^^^
>E1.Int : E1.Int
>       : ^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>Int : E1.Int
>    : ^^^^^^
>E1.Flag : E1.Flag
>        : ^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>Flag : E1.Flag
>     : ^^^^^^^

const sval_good2: E1 = functest(E1.String);
>sval_good2 : E1
>           : ^^
>functest(E1.String) : E1
>                    : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>E1.String : E1.String
>          : ^^^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>String : E1.String
>       : ^^^^^^^^^

const sval_bad2: E1 = functest("string"); // error
>sval_bad2 : E1
>          : ^^
>functest("string") : E1
>                   : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>"string" : "string"
>         : ^^^^^^^^

function functest2(value: E1.Int) {
>functest2 : (value: E1.Int) => E1.Int
>          : ^     ^^^^^^^^^^^^^^^^^^^
>value : E1.Int
>      : ^^^^^^
>E1 : any
>   : ^^^

    console.log(value);
>console.log(value) : void
>                   : ^^^^
>console.log : (...data: any[]) => void
>            : ^^^^    ^^     ^^^^^    
>console : Console
>        : ^^^^^^^
>log : (...data: any[]) => void
>    : ^^^^    ^^     ^^^^^    
>value : E1.Int
>      : ^^^^^^

    return value;
>value : E1.Int
>      : ^^^^^^
}

const nonexist_bad3: E1.Int = functest2(undefined);
>nonexist_bad3 : E1.Int
>              : ^^^^^^
>E1 : any
>   : ^^^
>functest2(undefined) : E1.Int
>                     : ^^^^^^
>functest2 : (value: E1.Int) => E1.Int
>          : ^     ^^^^^^^^^^^^^^^^^^^
>undefined : undefined
>          : ^^^^^^^^^

const exist_bad3: E1.Int = functest2("exists"); // error
>exist_bad3 : E1.Int
>           : ^^^^^^
>E1 : any
>   : ^^^
>functest2("exists") : E1.Int
>                    : ^^^^^^
>functest2 : (value: E1.Int) => E1.Int
>          : ^     ^^^^^^^^^^^^^^^^^^^
>"exists" : "exists"
>         : ^^^^^^^^

const ival_good5: E1.Int = functest2(1); // ok
>ival_good5 : E1.Int
>           : ^^^^^^
>E1 : any
>   : ^^^
>functest2(1) : E1.Int
>             : ^^^^^^
>functest2 : (value: E1.Int) => E1.Int
>          : ^     ^^^^^^^^^^^^^^^^^^^
>1 : 1
>  : ^

const ival_good6: E1.Int = functest2(4); // ok
>ival_good6 : E1.Int
>           : ^^^^^^
>E1 : any
>   : ^^^
>functest2(4) : E1.Int
>             : ^^^^^^
>functest2 : (value: E1.Int) => E1.Int
>          : ^     ^^^^^^^^^^^^^^^^^^^
>4 : 4
>  : ^

const ival_good7: E1.Int = functest2(E1.Int | E1.Flag); // ok
>ival_good7 : E1.Int
>           : ^^^^^^
>E1 : any
>   : ^^^
>functest2(E1.Int | E1.Flag) : E1.Int
>                            : ^^^^^^
>functest2 : (value: E1.Int) => E1.Int
>          : ^     ^^^^^^^^^^^^^^^^^^^
>E1.Int | E1.Flag : number
>                 : ^^^^^^
>E1.Int : E1.Int
>       : ^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>Int : E1.Int
>    : ^^^^^^
>E1.Flag : E1.Flag
>        : ^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>Flag : E1.Flag
>     : ^^^^^^^

const sval_good3: E1.Int = functest2(E1.String);
>sval_good3 : E1.Int
>           : ^^^^^^
>E1 : any
>   : ^^^
>functest2(E1.String) : E1.Int
>                     : ^^^^^^
>functest2 : (value: E1.Int) => E1.Int
>          : ^     ^^^^^^^^^^^^^^^^^^^
>E1.String : E1.String
>          : ^^^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>String : E1.String
>       : ^^^^^^^^^

const sval_bad3: E1.Flag = functest2("string"); // error
>sval_bad3 : E1.Flag
>          : ^^^^^^^
>E1 : any
>   : ^^^
>functest2("string") : E1.Int
>                    : ^^^^^^
>functest2 : (value: E1.Int) => E1.Int
>          : ^     ^^^^^^^^^^^^^^^^^^^
>"string" : "string"
>         : ^^^^^^^^

