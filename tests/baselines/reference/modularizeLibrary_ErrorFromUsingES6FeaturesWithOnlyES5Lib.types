=== tests/cases/compiler/modularizeLibrary_ErrorFromUsingES6FeaturesWithOnlyES5Lib.ts ===
// All will be error from using ES6 features but only include ES5 library
// Using Es6 array
function f(x: number, y: number, z: number) {
>f : (x: number, y: number, z: number) => any (error)
>x : number
>y : number
>z : number

    return Array.from(arguments);
>Array.from(arguments) : any (error)
>Array.from : any (error)
>Array : ArrayConstructor
>from : any (error)
>arguments : IArguments
}

f(1, 2, 3);  // no error
>f(1, 2, 3) : any (error)
>f : (x: number, y: number, z: number) => any (error)
>1 : 1
>2 : 2
>3 : 3

// Using ES6 collection
var m = new Map<string, number>();
>m : any (error)
>new Map<string, number>() : any (error)
>Map : any (error)

m.clear();
>m.clear() : any (error)
>m.clear : any (error)
>m : any (error)
>clear : any (error)

// Using ES6 iterable
m.keys();
>m.keys() : any (error)
>m.keys : any (error)
>m : any (error)
>keys : any (error)

// Using ES6 function
function Baz() { }
>Baz : () => void

Baz.name;
>Baz.name : any (error)
>Baz : () => void
>name : any (error)

// Using ES6 math
Math.sign(1);
>Math.sign(1) : any (error)
>Math.sign : any (error)
>Math : Math
>sign : any (error)
>1 : 1

// Using ES6 object
var o = {
>o : { a: number; [Symbol.hasInstance](value: any): boolean; }
>{    a: 2,    [Symbol.hasInstance](value: any) {        return false;    }} : { a: number; [Symbol.hasInstance](value: any): boolean; }

    a: 2,
>a : number
>2 : 2

    [Symbol.hasInstance](value: any) {
>[Symbol.hasInstance] : (value: any) => boolean
>Symbol.hasInstance : any (error)
>Symbol : any (error)
>hasInstance : any (error)
>value : any

        return false;
>false : false
    }
};
o.hasOwnProperty(Symbol.hasInstance);
>o.hasOwnProperty(Symbol.hasInstance) : boolean
>o.hasOwnProperty : (v: string | number | symbol) => boolean
>o : { a: number; [Symbol.hasInstance](value: any): boolean; }
>hasOwnProperty : (v: string | number | symbol) => boolean
>Symbol.hasInstance : any (error)
>Symbol : any (error)
>hasInstance : any (error)

// Using Es6 proxy
var t = {}
>t : {}
>{} : {}

var p = new Proxy(t, {});
>p : any (error)
>new Proxy(t, {}) : any (error)
>Proxy : any (error)
>t : {}
>{} : {}

// Using ES6 reflect
Reflect.isExtensible({});
>Reflect.isExtensible({}) : any (error)
>Reflect.isExtensible : any (error)
>Reflect : any (error)
>isExtensible : any (error)
>{} : {}

// Using Es6 regexp
var reg = new RegExp("/s");
>reg : RegExp
>new RegExp("/s") : RegExp
>RegExp : RegExpConstructor
>"/s" : "/s"

reg.flags;
>reg.flags : any (error)
>reg : RegExp
>flags : any (error)

// Using ES6 string
var str = "Hello world";
>str : string
>"Hello world" : "Hello world"

str.includes("hello", 0);
>str.includes("hello", 0) : any (error)
>str.includes : any (error)
>str : string
>includes : any (error)
>"hello" : "hello"
>0 : 0

// Using ES6 symbol
var s = Symbol();
>s : any (error)
>Symbol() : any (error)
>Symbol : any (error)

// Using ES6 wellknown-symbol
const o1 = {
>o1 : { [Symbol.hasInstance](value: any): boolean; }
>{    [Symbol.hasInstance](value: any) {        return false;    }} : { [Symbol.hasInstance](value: any): boolean; }

    [Symbol.hasInstance](value: any) {
>[Symbol.hasInstance] : (value: any) => boolean
>Symbol.hasInstance : any (error)
>Symbol : any (error)
>hasInstance : any (error)
>value : any

        return false;
>false : false
    }
}
