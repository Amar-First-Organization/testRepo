=== tests/cases/compiler/superAccess2.ts ===
class P {
>P : P

    x() { }
>x : () => void

    static y() { }
>y : () => void
}

class Q extends P {
>Q : Q
>P : P

    xx = super;
>xx : any (error)
>super : any (error)
>super : P
> : any (error)

    static yy = super; // error for static initializer accessing super
>yy : any (error)
>super : any (error)
>super : any (error)
> : any (error)

    // Super is not allowed in constructor args
    constructor(public z = super, zz = super, zzz = () => super) {
>z : any (error)
>super : any (error)
>super : any (error)
> : any (error)
>zz : any (error)
>super : any (error)
>super : any (error)
> : any (error)
>zzz : () => any (error)
>() => super : () => any (error)
>super : any (error)
>super : any (error)
> : any (error)

        super();
>super() : void
>super : typeof P
    }

    foo(zz = super) {
>foo : (zz?: any (error)) => void
>zz : any (error)
>super : any (error)
>super : P
> : any (error)

        super.x();
>super.x() : void
>super.x : () => void
>super : P
>x : () => void

        super.y(); // error
>super.y() : any (error)
>super.y : any (error)
>super : P
>y : any (error)
    }

    static bar(zz = super) {
>bar : (zz?: any (error)) => void
>zz : any (error)
>super : any (error)
>super : typeof P
> : any (error)

        super.x(); // error
>super.x() : any (error)
>super.x : any (error)
>super : typeof P
>x : any (error)

        super.y();
>super.y() : void
>super.y : () => void
>super : typeof P
>y : () => void
    }
}
