//// [tests/cases/conformance/types/typeParameters/typeParameterLists/typeParametersAvailableInNestedScope3.ts] ////

=== typeParametersAvailableInNestedScope3.ts ===
function foo<T>(v: T) {
>foo : <T>(v: T) => { a: <T>(a: T) => T; b: () => T; c: <T>(v: T) => { a: <T>(a: T) => T; b: () => T; c: <T>() => [T, T, T]; }; }
>v : T

    function a<T>(a: T) { return a; }
>a : <T>(a: T) => T
>a : T
>a : T

    function b(): T { return v; }
>b : () => T
>v : T

    type Alias = T;
>Alias : T

    function c<T>(v: T) {
>c : <T>(v: T) => { a: <T>(a: T) => T; b: () => T; c: <T>() => [T, T, T]; }
>v : T

        type Alias2 = T;
>Alias2 : T

        function a<T>(a: T) { return a; }
>a : <T>(a: T) => T
>a : T
>a : T

        function b(): T { return v; }
>b : () => T
>v : T

        function c<T>(): [Alias, Alias2, T] { return null as any; }
>c : <T>() => [T, T, T]
>null as any : any

        return { a, b, c };
>{ a, b, c } : { a: <T>(a: T) => T; b: () => T; c: <T>() => [T, T, T]; }
>a : <T>(a: T) => T
>b : () => T
>c : <T>() => [T, T, T]
    }

    return { a, b, c };
>{ a, b, c } : { a: <T>(a: T) => T; b: () => T; c: <T>(v: T) => { a: <T>(a: T) => T; b: () => T; c: <T>() => [T, T, T]; }; }
>a : <T>(a: T) => T
>b : () => T
>c : <T>(v: T) => { a: <T>(a: T) => T; b: () => T; c: <T>() => [T, T, T]; }
}

