=== tests/cases/compiler/destructuringTypeGuardFlow.ts ===
type foo = {
>foo : foo

  bar: number | null;
>bar : number | null
>null : null

  baz: string;
>baz : string

  nested: {
>nested : { a: number; b: string | null; }

    a: number;
>a : number

    b: string | null;
>b : string | null
>null : null
  }
};

const aFoo: foo = { bar: 3, baz: "b", nested: { a: 1, b: "y" } };
>aFoo : foo
>foo : foo
>{ bar: 3, baz: "b", nested: { a: 1, b: "y" } } : { bar: number; baz: string; nested: { a: number; b: string; }; }
>bar : number
>3 : 3
>baz : string
>"b" : "b"
>nested : { a: number; b: string; }
>{ a: 1, b: "y" } : { a: number; b: string; }
>a : number
>1 : 1
>b : string
>"y" : "y"

if (aFoo.bar && aFoo.nested.b) {
>aFoo.bar && aFoo.nested.b : string | 0 | null
>aFoo.bar : number | null
>aFoo : foo
>bar : number | null
>aFoo.nested.b : string | null
>aFoo.nested : { a: number; b: string | null; }
>aFoo : foo
>nested : { a: number; b: string | null; }
>b : string | null

  const { bar, baz, nested: {a, b: text} } = aFoo;
>bar : number
>baz : string
>nested : any
>a : number
>b : any
>text : string
>aFoo : foo

  const right: number = aFoo.bar;
>right : number
>aFoo.bar : number
>aFoo : foo
>bar : number

  const wrong: number = bar;
>wrong : number
>bar : number

  const another: string = baz;
>another : string
>baz : string

  const aAgain: number = a;
>aAgain : number
>a : number

  const bAgain: string = text;
>bAgain : string
>text : string
}
