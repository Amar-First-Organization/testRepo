=== tests/cases/conformance/es6/spread/arraySpreadInCall.ts ===
declare function f1(a: number, b: number, c: number, d: number, e: number, f: number): void;
>f1 : (a: number, b: number, c: number, d: number, e: number, f: number) => void
>a : number
>b : number
>c : number
>d : number
>e : number
>f : number

f1(1, 2, 3, 4, ...[5, 6]);
>f1(1, 2, 3, 4, ...[5, 6]) : void
>f1 : (a: number, b: number, c: number, d: number, e: number, f: number) => void
>1 : 1
>2 : 2
>3 : 3
>4 : 4
>...[5, 6] : number
>[5, 6] : readonly [number, number]
>5 : 5
>6 : 6

f1(...[1], 2, 3, 4, 5, 6);
>f1(...[1], 2, 3, 4, 5, 6) : void
>f1 : (a: number, b: number, c: number, d: number, e: number, f: number) => void
>...[1] : number
>[1] : readonly [number]
>1 : 1
>2 : 2
>3 : 3
>4 : 4
>5 : 5
>6 : 6

f1(1, 2, ...[3, 4], 5, 6);
>f1(1, 2, ...[3, 4], 5, 6) : void
>f1 : (a: number, b: number, c: number, d: number, e: number, f: number) => void
>1 : 1
>2 : 2
>...[3, 4] : number
>[3, 4] : readonly [number, number]
>3 : 3
>4 : 4
>5 : 5
>6 : 6

f1(1, 2, ...[3], 4, ...[5, 6]);
>f1(1, 2, ...[3], 4, ...[5, 6]) : void
>f1 : (a: number, b: number, c: number, d: number, e: number, f: number) => void
>1 : 1
>2 : 2
>...[3] : number
>[3] : readonly [number]
>3 : 3
>4 : 4
>...[5, 6] : number
>[5, 6] : readonly [number, number]
>5 : 5
>6 : 6

f1(...[1, 2], ...[3, 4], ...[5, 6]);
>f1(...[1, 2], ...[3, 4], ...[5, 6]) : void
>f1 : (a: number, b: number, c: number, d: number, e: number, f: number) => void
>...[1, 2] : number
>[1, 2] : readonly [number, number]
>1 : 1
>2 : 2
>...[3, 4] : number
>[3, 4] : readonly [number, number]
>3 : 3
>4 : 4
>...[5, 6] : number
>[5, 6] : readonly [number, number]
>5 : 5
>6 : 6

declare function f2<T extends unknown[]>(...args: T): T;
>f2 : <T extends unknown[]>(...args: T) => T
>args : T

const x21 = f2(...[1, 'foo'])
>x21 : [number, string]
>f2(...[1, 'foo']) : [number, string]
>f2 : <T extends unknown[]>(...args: T) => T
>...[1, 'foo'] : string | number
>[1, 'foo'] : readonly [number, string]
>1 : 1
>'foo' : "foo"

const x22 = f2(true, ...[1, 'foo'])
>x22 : [boolean, number, string]
>f2(true, ...[1, 'foo']) : [boolean, number, string]
>f2 : <T extends unknown[]>(...args: T) => T
>true : true
>...[1, 'foo'] : string | number
>[1, 'foo'] : readonly [number, string]
>1 : 1
>'foo' : "foo"

declare function f3<T extends readonly unknown[]>(...args: T): T;
>f3 : <T extends readonly unknown[]>(...args: T) => T
>args : T

const x31 = f3(...[1, 'foo'])
>x31 : [number, string]
>f3(...[1, 'foo']) : [number, string]
>f3 : <T extends readonly unknown[]>(...args: T) => T
>...[1, 'foo'] : string | number
>[1, 'foo'] : readonly [number, string]
>1 : 1
>'foo' : "foo"

const x32 = f3(true, ...[1, 'foo'])
>x32 : [boolean, number, string]
>f3(true, ...[1, 'foo']) : [boolean, number, string]
>f3 : <T extends readonly unknown[]>(...args: T) => T
>true : true
>...[1, 'foo'] : string | number
>[1, 'foo'] : readonly [number, string]
>1 : 1
>'foo' : "foo"

// dicovered in #52845#issuecomment-1459132562
interface IAction {
    run(event?: unknown): unknown;
>run : (event?: unknown) => unknown
>event : unknown
}
declare const action: IAction
>action : IAction

action.run(...[100, 'foo']) // error
>action.run(...[100, 'foo']) : unknown
>action.run : (event?: unknown) => unknown
>action : IAction
>run : (event?: unknown) => unknown
>...[100, 'foo'] : string | number
>[100, 'foo'] : readonly [number, string]
>100 : 100
>'foo' : "foo"

// repro from #53541
class T {
>T : T

  fn(name?: string, sex?: number): void {}
>fn : (name?: string, sex?: number) => void
>name : string | undefined
>sex : number | undefined
}

class M<X extends T> {
>M : M<X>

  constructor(public m: X) {}
>m : X

  fn(...args: Parameters<X["fn"]>) {
>fn : (...args: Parameters<X["fn"]>) => void
>args : Parameters<X["fn"]>

    this.m.fn(...args);
>this.m.fn(...args) : void
>this.m.fn : (name?: string | undefined, sex?: number | undefined) => void
>this.m : X
>this : this
>m : X
>fn : (name?: string | undefined, sex?: number | undefined) => void
>...args : string | number | undefined
>args : Parameters<X["fn"]>
  }
}

// repro from #53541#issuecomment-1487859044
interface HasMethod {
  method(first?: string, second?: number): void;
>method : (first?: string, second?: number) => void
>first : string | undefined
>second : number | undefined

  method2(...args: [name: string, sex?: number] | [other: number]): void;
>method2 : (...args: [name: string, sex?: number] | [other: number]) => void
>args : [name: string, sex?: number | undefined] | [other: number]
}

function fn21<HasMethodLike extends HasMethod>(
>fn21 : <HasMethodLike extends HasMethod>(instance: HasMethodLike, ...args: Parameters<HasMethodLike["method"]>) => void

  instance: HasMethodLike,
>instance : HasMethodLike

  ...args: Parameters<HasMethodLike["method"]>
>args : Parameters<HasMethodLike["method"]>

) {
  instance.method(...args);
>instance.method(...args) : void
>instance.method : (first?: string | undefined, second?: number | undefined) => void
>instance : HasMethodLike
>method : (first?: string | undefined, second?: number | undefined) => void
>...args : string | number | undefined
>args : Parameters<HasMethodLike["method"]>
}

function fn22<HasMethodLike extends HasMethod>(
>fn22 : <HasMethodLike extends HasMethod>(instance: HasMethodLike, ...args: Parameters<HasMethodLike["method2"]>) => void

  instance: HasMethodLike,
>instance : HasMethodLike

  ...args: Parameters<HasMethodLike["method2"]>
>args : Parameters<HasMethodLike["method2"]>

) {
  instance.method2(...args);
>instance.method2(...args) : void
>instance.method2 : (...args: [name: string, sex?: number | undefined] | [other: number]) => void
>instance : HasMethodLike
>method2 : (...args: [name: string, sex?: number | undefined] | [other: number]) => void
>...args : string | number | undefined
>args : Parameters<HasMethodLike["method2"]>
}

