//// [tests/cases/conformance/types/intersection/intersectionOfUnionNarrowing.ts] ////

=== intersectionOfUnionNarrowing.ts ===
interface X {
  a?: { aProp: string };
>a : { aProp: string; } | undefined
>  : ^^^^^^^^^      ^^^^^^^^^^^^^^^
>aProp : string
>      : ^^^^^^

  b?: { bProp: string };
>b : { bProp: string; } | undefined
>  : ^^^^^^^^^      ^^^^^^^^^^^^^^^
>bProp : string
>      : ^^^^^^
}
type AorB = { a: object; b: undefined } | { a: undefined; b: object };
>AorB : AorB
>     : ^^^^
>a : object
>  : ^^^^^^
>b : undefined
>  : ^^^^^^^^^
>a : undefined
>  : ^^^^^^^^^
>b : object
>  : ^^^^^^

declare const q: X & AorB;
>q : X & AorB
>  : ^^^^^^^^

if (q.a !== undefined) {
>q.a !== undefined : boolean
>                  : ^^^^^^^
>q.a : (object & { aProp: string; }) | undefined
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>q : X & AorB
>  : ^^^^^^^^
>a : (object & { aProp: string; }) | undefined
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>undefined : undefined
>          : ^^^^^^^^^

  q.a.aProp;
>q.a.aProp : string
>          : ^^^^^^
>q.a : object & { aProp: string; }
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>q : X & { a: object; b: undefined; }
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>a : object & { aProp: string; }
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>aProp : string
>      : ^^^^^^

} else {
  // q.b is previously incorrectly inferred as potentially undefined
  q.b.bProp;
>q.b.bProp : string
>          : ^^^^^^
>q.b : object & { bProp: string; }
>    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>q : X & { a: undefined; b: object; }
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>b : object & { bProp: string; }
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>bProp : string
>      : ^^^^^^
}

