//// [tests/cases/compiler/declarationEmitLocalClassDeclarationMixin.ts] ////

=== declarationEmitLocalClassDeclarationMixin.ts ===
interface Constructor<C> { new (...args: any[]): C; }
>args : any[]
>     : ^^^^^

function mixin<B extends Constructor<{}>>(Base: B) {
>mixin : <B extends Constructor<{}>>(Base: B) => B & { new (...args: any[]): PrivateMixed; prototype: mixin<any>.PrivateMixed; }
>      : ^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>Base : B
>     : ^

    class PrivateMixed extends Base {
>PrivateMixed : PrivateMixed
>             : ^^^^^^^^^^^^
>Base : {}
>     : ^^

        bar = 2;
>bar : number
>    : ^^^^^^
>2 : 2
>  : ^
    }
    return PrivateMixed;
>PrivateMixed : B & { new (...args: any[]): PrivateMixed; prototype: mixin<any>.PrivateMixed; }
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
}

export class Unmixed {
>Unmixed : Unmixed
>        : ^^^^^^^

    foo = 1;
>foo : number
>    : ^^^^^^
>1 : 1
>  : ^
}

export const Mixed = mixin(Unmixed);
>Mixed : typeof Unmixed & { new (...args: any[]): mixin<typeof Unmixed>.PrivateMixed; prototype: mixin<any>.PrivateMixed; }
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>mixin(Unmixed) : typeof Unmixed & { new (...args: any[]): mixin<typeof Unmixed>.PrivateMixed; prototype: mixin<any>.PrivateMixed; }
>               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>mixin : <B extends Constructor<{}>>(Base: B) => B & { new (...args: any[]): PrivateMixed; prototype: mixin<any>.PrivateMixed; }
>      : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>Unmixed : typeof Unmixed
>        : ^^^^^^^^^^^^^^

function Filter<C extends Constructor<{}>>(ctor: C) {
>Filter : <C extends Constructor<{}>>(ctor: C) => C & ((abstract new (...args: any[]) => FilterMixin) & { prototype: Filter<any>.FilterMixin; })
>       : ^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>ctor : C
>     : ^

    abstract class FilterMixin extends ctor {
>FilterMixin : FilterMixin
>            : ^^^^^^^^^^^
>ctor : {}
>     : ^^

        abstract match(path: string): boolean;
>match : (path: string) => boolean
>      : ^^^^^^^      ^^^^^       
>path : string
>     : ^^^^^^

        // other concrete methods, fields, constructor
        thing = 12;
>thing : number
>      : ^^^^^^
>12 : 12
>   : ^^
    }
    return FilterMixin;
>FilterMixin : C & ((abstract new (...args: any[]) => FilterMixin) & { prototype: Filter<any>.FilterMixin; })
>            : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
}

export class FilteredThing extends Filter(Unmixed) {
>FilteredThing : FilteredThing
>              : ^^^^^^^^^^^^^
>Filter(Unmixed) : Unmixed & Filter<typeof Unmixed>.FilterMixin
>                : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>Filter : <C extends Constructor<{}>>(ctor: C) => C & ((abstract new (...args: any[]) => FilterMixin) & { prototype: Filter<any>.FilterMixin; })
>       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>Unmixed : typeof Unmixed
>        : ^^^^^^^^^^^^^^

    match(path: string) {
>match : (path: string) => boolean
>      : ^^^^^^^      ^^^^^^^^^^^^
>path : string
>     : ^^^^^^

        return false;
>false : false
>      : ^^^^^
    }
}

