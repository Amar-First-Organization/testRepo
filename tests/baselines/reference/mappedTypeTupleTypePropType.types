=== tests/cases/compiler/mappedTypeTupleTypePropType.ts ===
type Indices<T extends Array<any>> = {
>Indices : Indices<T>

  [K in keyof T]: K
};

// should contain numbers
type MyIndices = Indices<[string, number]>;
>MyIndices : ["0", "1"]

// union of indices should be preserved
type StillMyIndices = MyIndices[number] & number
>StillMyIndices : never

// simplified repro from https://twitter.com/oleg008/status/1508422774401949704

type Container<V> = {
>Container : Container<V>

  value: V;
>value : V

};

type UnwrapContainers<T extends Container<unknown>[]> = {
>UnwrapContainers : UnwrapContainers<T>

  [K in keyof T]: T[K & number]["value"];
};

declare function combine<T extends Container<unknown>[]>(
>combine : <T extends Container<unknown>[]>(containers: [...T], callback: (...values: UnwrapContainers<T>) => void) => void

  containers: [...T],
>containers : [...T]

  callback: (...values: UnwrapContainers<T>) => void
>callback : (...values: UnwrapContainers<T>) => void
>values : UnwrapContainers<T>

): void;

declare const container1: Container<string>;
>container1 : Container<string>

declare const container2: Container<number>;
>container2 : Container<number>

combine([container1, container2], (value1, value2) => {
>combine([container1, container2], (value1, value2) => {  const val1: string = value1;  const val2: number = value2;}) : void
>combine : <T extends Container<unknown>[]>(containers: [...T], callback: (...values: UnwrapContainers<T>) => void) => void
>[container1, container2] : [Container<string>, Container<number>]
>container1 : Container<string>
>container2 : Container<number>
>(value1, value2) => {  const val1: string = value1;  const val2: number = value2;} : (value1: string | number, value2: string | number) => void
>value1 : string | number
>value2 : string | number

  const val1: string = value1;
>val1 : string
>value1 : string | number

  const val2: number = value2;
>val2 : number
>value2 : string | number

});


