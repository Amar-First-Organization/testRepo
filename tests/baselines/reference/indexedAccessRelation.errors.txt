tests/cases/compiler/indexedAccessRelation.ts(16,23): error TS2345: Argument of type '{ a: T; }' is not assignable to parameter of type 'Pick<S & State<T>, "a">'.
  Types of property 'a' are incompatible.
    Type 'T' is not assignable to type 'S["a"] & T'.
      Type 'Foo' is not assignable to type 'S["a"] & T'.
        Type 'Foo' is not assignable to type 'S["a"]'.
          Type 'T' is not assignable to type 'S["a"]'.
            Type 'Foo' is not assignable to type 'S["a"]'.


==== tests/cases/compiler/indexedAccessRelation.ts (1 errors) ====
    // Repro from #14723
    
    class Component<S> {
        setState<K extends keyof S>(state: Pick<S, K>) {}
    }
    
    export interface State<T> {
        a?: T;
    }
    
    class Foo {}
    
    class Comp<T extends Foo, S> extends Component<S & State<T>>
    {
        foo(a: T) {
            this.setState({ a: a });
                          ~~~~~~~~
!!! error TS2345: Argument of type '{ a: T; }' is not assignable to parameter of type 'Pick<S & State<T>, "a">'.
!!! error TS2345:   Types of property 'a' are incompatible.
!!! error TS2345:     Type 'T' is not assignable to type 'S["a"] & T'.
!!! error TS2345:       Type 'Foo' is not assignable to type 'S["a"] & T'.
!!! error TS2345:         Type 'Foo' is not assignable to type 'S["a"]'.
!!! error TS2345:           Type 'T' is not assignable to type 'S["a"]'.
!!! error TS2345:             Type 'Foo' is not assignable to type 'S["a"]'.
        }
    }
    
    // Repro from #31833
    
    type Foo1 = {
      type: 'foo1';
      extra: number;
    };
    
    type Foo2 = {
      type: 'foo2';
      extra: string;
    };
    
    type Both = Foo1 | Foo2;
    
    type FooTypes = Both['type'];
    
    export type FooFromType<T extends FooTypes, O extends Both = Both> = O extends { type: T } ? O : never;
    
    type FooExtraFromType<T extends FooTypes> = FooFromType<T>['extra'];
    
    function fnWithFooExtra<T extends FooTypes>(type: T, extra: FooExtraFromType<T>) { }
    
    type FnType = <T extends FooTypes>(type: T, extra: FooExtraFromType<T>) => void;
    
    const fn: FnType = fnWithFooExtra;
    