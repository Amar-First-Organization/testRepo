=== tests/cases/compiler/noIterationTypeErrorsInCFA.ts ===
interface F {
    d(): void
>d : () => void
}
export function doRemove(dds: F | F[]) {
>doRemove : (dds: F | F[]) => F[]
>dds : F | F[]

    if (!Array.isArray(dds)) {
>!Array.isArray(dds) : boolean
>Array.isArray(dds) : boolean
>Array.isArray : { <T>(arg: T): arg is T extends any ? Extract<(true extends false & T ? any : T extends (infer U)[] ? U : T extends string | readonly any[] ? unknown : T extends ArrayLike<infer U> ? U : unknown)[], T> | Extract<true extends false & T ? never : T extends readonly (infer U)[] ? Extract<T, readonly U[]> : never, T> | (true extends false & T ? never : {} extends T ? T & unknown[] : never) : never; <T>(arg: T): arg is T extends any ? Extract<(true extends false & T ? any : T extends (infer U)[] ? U : T extends string | readonly any[] ? unknown : T extends ArrayLike<infer U> | Iterable<infer U> ? U : unknown)[], T> | Extract<true extends false & T ? never : T extends readonly (infer U)[] ? Extract<T, readonly U[]> : never, T> | (true extends false & T ? never : {} extends T ? T & unknown[] : never) : never; }
>Array : ArrayConstructor
>isArray : { <T>(arg: T): arg is T extends any ? Extract<(true extends false & T ? any : T extends (infer U)[] ? U : T extends string | readonly any[] ? unknown : T extends ArrayLike<infer U> ? U : unknown)[], T> | Extract<true extends false & T ? never : T extends readonly (infer U)[] ? Extract<T, readonly U[]> : never, T> | (true extends false & T ? never : {} extends T ? T & unknown[] : never) : never; <T>(arg: T): arg is T extends any ? Extract<(true extends false & T ? any : T extends (infer U)[] ? U : T extends string | readonly any[] ? unknown : T extends ArrayLike<infer U> | Iterable<infer U> ? U : unknown)[], T> | Extract<true extends false & T ? never : T extends readonly (infer U)[] ? Extract<T, readonly U[]> : never, T> | (true extends false & T ? never : {} extends T ? T & unknown[] : never) : never; }
>dds : F | F[]

        dds = [dds]
>dds = [dds] : F[]
>dds : F | F[]
>[dds] : F[]
>dds : F
    }
    for (let n of dds) {
>n : F
>dds : F[]

        n.d()
>n.d() : void
>n.d : () => void
>n : F
>d : () => void
    }
    return dds
>dds : F[]
}

