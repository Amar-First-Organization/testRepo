//// [tests/cases/conformance/types/typeRelationships/typeInference/noInfer.ts] ////

=== noInfer.ts ===
// NoInfer<T> is erased for primitives

type T00 = NoInfer<string>;
>T00 : Symbol(T00, Decl(noInfer.ts, 0, 0))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))

type T01 = NoInfer<string | number | boolean>;
>T01 : Symbol(T01, Decl(noInfer.ts, 2, 27))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))

type T02 = NoInfer<undefined>;
>T02 : Symbol(T02, Decl(noInfer.ts, 3, 46))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))

type T03 = NoInfer<"foo">;
>T03 : Symbol(T03, Decl(noInfer.ts, 4, 30))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))

type T04 = NoInfer<`foo${string}`>;
>T04 : Symbol(T04, Decl(noInfer.ts, 5, 26))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))

type T05 = NoInfer<`foo${string}` & `${string}bar`>;
>T05 : Symbol(T05, Decl(noInfer.ts, 6, 35))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))

type T06 = NoInfer<{}>;
>T06 : Symbol(T06, Decl(noInfer.ts, 7, 52))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))

// NoInfer<T> is preserved for object types

type T10 = NoInfer<string[]>;
>T10 : Symbol(T10, Decl(noInfer.ts, 8, 23))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))

type T11 = NoInfer<{ x: string }>;
>T11 : Symbol(T11, Decl(noInfer.ts, 12, 29))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>x : Symbol(x, Decl(noInfer.ts, 13, 20))

// NoInfer<T> is erased if it has no effect

type T20<T> = NoInfer<NoInfer<T>>;
>T20 : Symbol(T20, Decl(noInfer.ts, 13, 34))
>T : Symbol(T, Decl(noInfer.ts, 17, 9))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 17, 9))

type T21<T> = NoInfer<NoInfer<T> & string>;
>T21 : Symbol(T21, Decl(noInfer.ts, 17, 34))
>T : Symbol(T, Decl(noInfer.ts, 18, 9))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 18, 9))

type T22<T> = NoInfer<NoInfer<T> & string[]>;
>T22 : Symbol(T22, Decl(noInfer.ts, 18, 43))
>T : Symbol(T, Decl(noInfer.ts, 19, 9))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 19, 9))

declare function foo1<T extends string>(a: T, b: NoInfer<T>): void
>foo1 : Symbol(foo1, Decl(noInfer.ts, 19, 45))
>T : Symbol(T, Decl(noInfer.ts, 21, 22))
>a : Symbol(a, Decl(noInfer.ts, 21, 40))
>T : Symbol(T, Decl(noInfer.ts, 21, 22))
>b : Symbol(b, Decl(noInfer.ts, 21, 45))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 21, 22))

declare function foo2<T extends string>(a: T, b: NoInfer<T>[]): void
>foo2 : Symbol(foo2, Decl(noInfer.ts, 21, 66))
>T : Symbol(T, Decl(noInfer.ts, 22, 22))
>a : Symbol(a, Decl(noInfer.ts, 22, 40))
>T : Symbol(T, Decl(noInfer.ts, 22, 22))
>b : Symbol(b, Decl(noInfer.ts, 22, 45))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 22, 22))

declare function foo3<T extends string>(a: T, b: NoInfer<T[]>): void
>foo3 : Symbol(foo3, Decl(noInfer.ts, 22, 68))
>T : Symbol(T, Decl(noInfer.ts, 23, 22))
>a : Symbol(a, Decl(noInfer.ts, 23, 40))
>T : Symbol(T, Decl(noInfer.ts, 23, 22))
>b : Symbol(b, Decl(noInfer.ts, 23, 45))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 23, 22))

declare function foo4<T extends string>(a: T, b: { x: NoInfer<T> }): void
>foo4 : Symbol(foo4, Decl(noInfer.ts, 23, 68))
>T : Symbol(T, Decl(noInfer.ts, 24, 22))
>a : Symbol(a, Decl(noInfer.ts, 24, 40))
>T : Symbol(T, Decl(noInfer.ts, 24, 22))
>b : Symbol(b, Decl(noInfer.ts, 24, 45))
>x : Symbol(x, Decl(noInfer.ts, 24, 50))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 24, 22))

declare function foo5<T extends string>(a: T, b: NoInfer<{ x: T }>): void
>foo5 : Symbol(foo5, Decl(noInfer.ts, 24, 73))
>T : Symbol(T, Decl(noInfer.ts, 25, 22))
>a : Symbol(a, Decl(noInfer.ts, 25, 40))
>T : Symbol(T, Decl(noInfer.ts, 25, 22))
>b : Symbol(b, Decl(noInfer.ts, 25, 45))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>x : Symbol(x, Decl(noInfer.ts, 25, 58))
>T : Symbol(T, Decl(noInfer.ts, 25, 22))

foo1('foo', 'foo') // ok
>foo1 : Symbol(foo1, Decl(noInfer.ts, 19, 45))

foo1('foo', 'bar') // error
>foo1 : Symbol(foo1, Decl(noInfer.ts, 19, 45))

foo2('foo', ['bar']) // error
>foo2 : Symbol(foo2, Decl(noInfer.ts, 21, 66))

foo3('foo', ['bar']) // error
>foo3 : Symbol(foo3, Decl(noInfer.ts, 22, 68))

foo4('foo', { x: 'bar' }) // error
>foo4 : Symbol(foo4, Decl(noInfer.ts, 23, 68))
>x : Symbol(x, Decl(noInfer.ts, 31, 13))

foo5('foo', { x: 'bar' }) // error
>foo5 : Symbol(foo5, Decl(noInfer.ts, 24, 73))
>x : Symbol(x, Decl(noInfer.ts, 32, 13))

declare class Animal { move(): void }
>Animal : Symbol(Animal, Decl(noInfer.ts, 32, 25))
>move : Symbol(Animal.move, Decl(noInfer.ts, 34, 22))

declare class Dog extends Animal { woof(): void }
>Dog : Symbol(Dog, Decl(noInfer.ts, 34, 37))
>Animal : Symbol(Animal, Decl(noInfer.ts, 32, 25))
>woof : Symbol(Dog.woof, Decl(noInfer.ts, 35, 34))

declare function doSomething<T>(value: T, getDefault: () => NoInfer<T>): void;
>doSomething : Symbol(doSomething, Decl(noInfer.ts, 35, 49))
>T : Symbol(T, Decl(noInfer.ts, 36, 29))
>value : Symbol(value, Decl(noInfer.ts, 36, 32))
>T : Symbol(T, Decl(noInfer.ts, 36, 29))
>getDefault : Symbol(getDefault, Decl(noInfer.ts, 36, 41))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 36, 29))

doSomething(new Animal(), () => new Animal()); // ok
>doSomething : Symbol(doSomething, Decl(noInfer.ts, 35, 49))
>Animal : Symbol(Animal, Decl(noInfer.ts, 32, 25))
>Animal : Symbol(Animal, Decl(noInfer.ts, 32, 25))

doSomething(new Animal(), () => new Dog()); // ok
>doSomething : Symbol(doSomething, Decl(noInfer.ts, 35, 49))
>Animal : Symbol(Animal, Decl(noInfer.ts, 32, 25))
>Dog : Symbol(Dog, Decl(noInfer.ts, 34, 37))

doSomething(new Dog(), () => new Animal()); // error
>doSomething : Symbol(doSomething, Decl(noInfer.ts, 35, 49))
>Dog : Symbol(Dog, Decl(noInfer.ts, 34, 37))
>Animal : Symbol(Animal, Decl(noInfer.ts, 32, 25))

declare function assertEqual<T>(actual: T, expected: NoInfer<T>): boolean;
>assertEqual : Symbol(assertEqual, Decl(noInfer.ts, 40, 43))
>T : Symbol(T, Decl(noInfer.ts, 42, 29))
>actual : Symbol(actual, Decl(noInfer.ts, 42, 32))
>T : Symbol(T, Decl(noInfer.ts, 42, 29))
>expected : Symbol(expected, Decl(noInfer.ts, 42, 42))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 42, 29))

assertEqual({ x: 1 }, { x: 3 }); // ok
>assertEqual : Symbol(assertEqual, Decl(noInfer.ts, 40, 43))
>x : Symbol(x, Decl(noInfer.ts, 44, 13))
>x : Symbol(x, Decl(noInfer.ts, 44, 23))

const g = { x: 3, y: 2 };
>g : Symbol(g, Decl(noInfer.ts, 45, 5))
>x : Symbol(x, Decl(noInfer.ts, 45, 11))
>y : Symbol(y, Decl(noInfer.ts, 45, 17))

assertEqual(g, { x: 3 }); // error
>assertEqual : Symbol(assertEqual, Decl(noInfer.ts, 40, 43))
>g : Symbol(g, Decl(noInfer.ts, 45, 5))
>x : Symbol(x, Decl(noInfer.ts, 46, 16))

declare function invoke<T, R>(func: (value: T) => R, value: NoInfer<T>): R;
>invoke : Symbol(invoke, Decl(noInfer.ts, 46, 25))
>T : Symbol(T, Decl(noInfer.ts, 48, 24))
>R : Symbol(R, Decl(noInfer.ts, 48, 26))
>func : Symbol(func, Decl(noInfer.ts, 48, 30))
>value : Symbol(value, Decl(noInfer.ts, 48, 37))
>T : Symbol(T, Decl(noInfer.ts, 48, 24))
>R : Symbol(R, Decl(noInfer.ts, 48, 26))
>value : Symbol(value, Decl(noInfer.ts, 48, 52))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 48, 24))
>R : Symbol(R, Decl(noInfer.ts, 48, 26))

declare function test(value: { x: number; }): number;
>test : Symbol(test, Decl(noInfer.ts, 48, 75))
>value : Symbol(value, Decl(noInfer.ts, 49, 22))
>x : Symbol(x, Decl(noInfer.ts, 49, 30))

invoke(test, { x: 1, y: 2 }); // error
>invoke : Symbol(invoke, Decl(noInfer.ts, 46, 25))
>test : Symbol(test, Decl(noInfer.ts, 48, 75))
>x : Symbol(x, Decl(noInfer.ts, 51, 14))
>y : Symbol(y, Decl(noInfer.ts, 51, 20))

test({ x: 1, y: 2 }); // error
>test : Symbol(test, Decl(noInfer.ts, 48, 75))
>x : Symbol(x, Decl(noInfer.ts, 52, 6))
>y : Symbol(y, Decl(noInfer.ts, 52, 12))

type Component<Props> = { props: Props; };
>Component : Symbol(Component, Decl(noInfer.ts, 52, 21))
>Props : Symbol(Props, Decl(noInfer.ts, 54, 15))
>props : Symbol(props, Decl(noInfer.ts, 54, 25))
>Props : Symbol(Props, Decl(noInfer.ts, 54, 15))

declare function doWork<Props>(Component: Component<Props>, props: NoInfer<Props>): void;
>doWork : Symbol(doWork, Decl(noInfer.ts, 54, 42))
>Props : Symbol(Props, Decl(noInfer.ts, 55, 24))
>Component : Symbol(Component, Decl(noInfer.ts, 55, 31))
>Component : Symbol(Component, Decl(noInfer.ts, 52, 21))
>Props : Symbol(Props, Decl(noInfer.ts, 55, 24))
>props : Symbol(props, Decl(noInfer.ts, 55, 59))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>Props : Symbol(Props, Decl(noInfer.ts, 55, 24))

declare const comp: Component<{ foo: number }>;
>comp : Symbol(comp, Decl(noInfer.ts, 56, 13))
>Component : Symbol(Component, Decl(noInfer.ts, 52, 21))
>foo : Symbol(foo, Decl(noInfer.ts, 56, 31))

doWork(comp, { foo: 42 }); // ok
>doWork : Symbol(doWork, Decl(noInfer.ts, 54, 42))
>comp : Symbol(comp, Decl(noInfer.ts, 56, 13))
>foo : Symbol(foo, Decl(noInfer.ts, 58, 14))

doWork(comp, {}); // error
>doWork : Symbol(doWork, Decl(noInfer.ts, 54, 42))
>comp : Symbol(comp, Decl(noInfer.ts, 56, 13))

declare function mutate<T>(callback: (a: NoInfer<T>, b: number) => T): T;
>mutate : Symbol(mutate, Decl(noInfer.ts, 59, 17))
>T : Symbol(T, Decl(noInfer.ts, 61, 24))
>callback : Symbol(callback, Decl(noInfer.ts, 61, 27))
>a : Symbol(a, Decl(noInfer.ts, 61, 38))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 61, 24))
>b : Symbol(b, Decl(noInfer.ts, 61, 52))
>T : Symbol(T, Decl(noInfer.ts, 61, 24))
>T : Symbol(T, Decl(noInfer.ts, 61, 24))

const mutate1 = mutate((a, b) => b);
>mutate1 : Symbol(mutate1, Decl(noInfer.ts, 62, 5))
>mutate : Symbol(mutate, Decl(noInfer.ts, 59, 17))
>a : Symbol(a, Decl(noInfer.ts, 62, 24))
>b : Symbol(b, Decl(noInfer.ts, 62, 26))
>b : Symbol(b, Decl(noInfer.ts, 62, 26))

declare class ExampleClass<T> {}
>ExampleClass : Symbol(ExampleClass, Decl(noInfer.ts, 62, 36))
>T : Symbol(T, Decl(noInfer.ts, 64, 27))

class OkClass<T> {
>OkClass : Symbol(OkClass, Decl(noInfer.ts, 64, 32))
>T : Symbol(T, Decl(noInfer.ts, 65, 14))

    constructor(private clazz: ExampleClass<T>, private _value: NoInfer<T>) {}
>clazz : Symbol(OkClass.clazz, Decl(noInfer.ts, 66, 16))
>ExampleClass : Symbol(ExampleClass, Decl(noInfer.ts, 62, 36))
>T : Symbol(T, Decl(noInfer.ts, 65, 14))
>_value : Symbol(OkClass._value, Decl(noInfer.ts, 66, 47))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 65, 14))

    get value(): T {
>value : Symbol(OkClass.value, Decl(noInfer.ts, 66, 78))
>T : Symbol(T, Decl(noInfer.ts, 65, 14))

        return this._value; // ok
>this._value : Symbol(OkClass._value, Decl(noInfer.ts, 66, 47))
>this : Symbol(OkClass, Decl(noInfer.ts, 64, 32))
>_value : Symbol(OkClass._value, Decl(noInfer.ts, 66, 47))
    }
}
class OkClass2<T> {
>OkClass2 : Symbol(OkClass2, Decl(noInfer.ts, 71, 1))
>T : Symbol(T, Decl(noInfer.ts, 72, 15))

    constructor(private clazz: ExampleClass<T>, public _value: NoInfer<T>) {}
>clazz : Symbol(OkClass2.clazz, Decl(noInfer.ts, 73, 16))
>ExampleClass : Symbol(ExampleClass, Decl(noInfer.ts, 62, 36))
>T : Symbol(T, Decl(noInfer.ts, 72, 15))
>_value : Symbol(OkClass2._value, Decl(noInfer.ts, 73, 47))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 72, 15))
}

