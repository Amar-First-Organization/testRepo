/// <reference path="../src/compiler/sys.ts" />

interface DiagnosticDetails {
    category: string;
    code: number;
    isEarly?: boolean;
}

interface InputDiagnosticMessageTable {
    [msg: string]: DiagnosticDetails;
}

function main(): void {
    var sys = ts.sys;
    if (sys.args.length < 1) {
        sys.write("Usage:" + sys.newLine)
        sys.write("\tnode processDiagnosticMessages.js <diagnostic-json-input-file>" + sys.newLine);
        return;
    }

    var inputFilePath = sys.args[0].replace(/\\/g, "/");
    var inputStr = sys.readFile(inputFilePath);
    
    var diagnosticMessages: InputDiagnosticMessageTable = JSON.parse(inputStr);

    var names = Utilities.getObjectKeys(diagnosticMessages);
    var nameMap = buildUniqueNameMap(names);

    var infoFileOutput = buildInfoFileOutput(diagnosticMessages, nameMap);
    checkForUniqueCodes(names, diagnosticMessages);

    // TODO: Fix path joining
    var inputDirectory = inputFilePath.substr(0,inputFilePath.lastIndexOf("/"));
    var fileOutputPath = inputDirectory + "/diagnosticInformationMap.generated.ts";
    sys.writeFile(fileOutputPath, infoFileOutput);
}

function checkForUniqueCodes(messages: string[], diagnosticTable: InputDiagnosticMessageTable) {
    const originalMessageForCode: string[] = [];
    let numConflicts = 0;
    
    for (const currentMessage of messages) {
        const code = diagnosticTable[currentMessage].code;

        if (code in originalMessageForCode) {
            const originalMessage = originalMessageForCode[code];
            ts.sys.write("\x1b[91m"); // High intensity red.
            ts.sys.write("Error");
            ts.sys.write("\x1b[0m");  // Reset formatting.
            ts.sys.write(`: Diagnostic code '${code}' conflicts between "${originalMessage}" and "${currentMessage}".`);
            ts.sys.write(ts.sys.newLine + ts.sys.newLine);

            numConflicts++;
        }
        else {
            originalMessageForCode[code] = currentMessage;
        }
    }

    if (numConflicts > 0) {
        throw new Error(`Found ${numConflicts} conflict(s) in diagnostic codes.`);
    }
}

function buildUniqueNameMap(names: string[]): ts.Map<string> {
    var nameMap: ts.Map<string> = {};

    var uniqueNames = NameGenerator.mangle(names, /* isCaseSensitive */ false, /* isFixed */ undefined);

    for (var i = 0; i < names.length; i++) {
        nameMap[uniqueNames[i]] = names[i];
    }

    return nameMap;
}

function buildInfoFileOutput(messageTable: InputDiagnosticMessageTable, nameMap: ts.Map<string>): string {
    var result =
        '// <auto-generated />\r\n' +
        '/// <reference path="types.ts" />\r\n' +
        '/* @internal */\r\n' +
        'namespace ts {\r\n' +
        '    export var Diagnostics = {\r\n';
    var names = Utilities.getObjectKeys(nameMap);
    for (var i = 0; i < names.length; i++) {
        var name = names[i];
        var diagnosticDetails = messageTable[nameMap[name]];

        result +=
        '        ' + name +
        ': { code: ' + diagnosticDetails.code +
        ', category: DiagnosticCategory.' + diagnosticDetails.category +
        ', key: ' + JSON.stringify(nameMap[name]) +
        ' },\r\n';
    }

    result += '    };\r\n}';

    return result;
}

module NameGenerator {
    export function mangle(names: string[], isCaseSensitive: boolean, isFixed?: boolean[]): string[]{
        if (!isFixed) {
            isFixed = names.map(() => false)
        }

        var mangledNames = names.map(name => convertToPropertyName(name));
        ensureUniquenessInPlace(mangledNames, isCaseSensitive, isFixed);
        return mangledNames;
    }

    function convertToPropertyName(origName: string): string {
        var result = origName.split("").map(char => {
            if (char === '*') { return "_Asterisk"; }
            if (char === '/') { return "_Slash"; }
            if (char === ':') { return "_Colon"; }
            return /\w/.test(char) ? char : "_";
        }).join("");


        // get rid of all multi-underscores
        result = result.replace(/_+/g, "_");

        // remove any leading underscore, unless it is followed by a number.
        result = result.replace(/^_([^\d])/, "$1")

        // get rid of all trailing underscores.
        result = result.replace(/_$/, "");

        return result;
    }

    function ensureUniquenessInPlace(names: string[], isCaseSensitive: boolean, isFixed: boolean[]): void {
        var nameToIndicesMap = Utilities.collectMatchingIndices(names, isCaseSensitive);
        for (var i = 0; i < names.length; i++) {
            var name = names[i];

            // Since we're operating in place, `names[i]` may refer to an element that was part
            // part of a set of collisions that is now resolved.  If so, it won't be in the map,
            // since it has a new name, different from the one it had when we called
            // `collectMatchingIndices`.
            if (Utilities.mapHasKey(nameToIndicesMap, name)) {
                var collisionIndices = nameToIndicesMap[name];

                // We will always have one "collision" because `i` itself will be present in the
                // list, so if we only have one item in `collisionIndices`, then there are no
                // issues.
                if (collisionIndices.length < 2) {
                    continue;
                }

                handleCollisions(name, names, isFixed, collisionIndices, isCaseSensitive);
            }
        }
    }

    function handleCollisions(name: string, proposedNames: string[], isFixed: boolean[], collisionIndices: number[], isCaseSensitive: boolean): void {
        var suffix = 1;

        for (var i = 0; i < collisionIndices.length; i++) {
            var collisionIndex = collisionIndices[i];

            if (isFixed[collisionIndex]) {
                // can't do anything about this name.
                continue;
            }

            while (true) {
                var newName = name + "$$" + suffix;
                suffix++;

                // Check if we've synthesized a unique name, and if so
                // replace the conflicting name with the new one.
                if (!proposedNames.some(name => Utilities.stringEquals(name, newName, isCaseSensitive))) {
                    proposedNames[collisionIndex] = newName;
                    break;
                }
            }
        }
    }
}

module Utilities {
    export function collectMatchingIndices(proposedNames: string[], isCaseSensitive: boolean): IIndexable<number[]> {
        var nameToIndicesMap: IIndexable<number[]> = {};
        for (var i = 0; i < proposedNames.length; i++) {
            var name = proposedNames[i];
            if (!mapHasKey(nameToIndicesMap, name)) {
                nameToIndicesMap[name] = [];
            }

            nameToIndicesMap[name].push(i);
        }

        return nameToIndicesMap;
    }

    export function mapHasKey<T>(map: IIndexable<T>, key: string): boolean {
        return Object.prototype.hasOwnProperty.call(map, key);
    }

    export function stringEquals(s1: string, s2: string, caseSensitive: boolean): boolean {
        if (caseSensitive) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
        }

        return s1 == s2;
    }

    // Like Object.keys
    export function getObjectKeys(obj: any): string[] {
        var result: string[] = [];

        for (var name in obj) {
            if (obj.hasOwnProperty(name)) {
                result.push(name);
            }
        }

        return result;
    }
}

main();
