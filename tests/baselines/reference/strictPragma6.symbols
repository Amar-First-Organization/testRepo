=== tests/cases/conformance/pragma/strict/file1.ts ===
// @ts-strict
// @ts-strictFunctionTypes false
export function f1(x: string) {}
>f1 : Symbol(f1, Decl(file1.ts, 0, 0))
>x : Symbol(x, Decl(file1.ts, 2, 19))

f1.call(undefined, 42); // wrong
>f1.call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>f1 : Symbol(f1, Decl(file1.ts, 0, 0))
>call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>undefined : Symbol(undefined)

f1.call(undefined, "ok"); // right
>f1.call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>f1 : Symbol(f1, Decl(file1.ts, 0, 0))
>call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>undefined : Symbol(undefined)

export let a = (arg: string) => 0;
>a : Symbol(a, Decl(file1.ts, 6, 10))
>arg : Symbol(arg, Decl(file1.ts, 6, 16))

export let b = (arg: unknown) => 0;
>b : Symbol(b, Decl(file1.ts, 7, 10))
>arg : Symbol(arg, Decl(file1.ts, 7, 16))

a = b;
>a : Symbol(a, Decl(file1.ts, 6, 10))
>b : Symbol(b, Decl(file1.ts, 7, 10))

b = a;
>b : Symbol(b, Decl(file1.ts, 7, 10))
>a : Symbol(a, Decl(file1.ts, 6, 10))

export class A {
>A : Symbol(A, Decl(file1.ts, 10, 6))

    prop: string;
>prop : Symbol(A.prop, Decl(file1.ts, 12, 16))

    constructor() {}
}

declare var c: { member?: string };
>c : Symbol(c, Decl(file1.ts, 17, 11))
>member : Symbol(member, Decl(file1.ts, 17, 16))

c.member.charAt(0);
>c.member.charAt : Symbol(String.charAt, Decl(lib.es5.d.ts, --, --))
>c.member : Symbol(member, Decl(file1.ts, 17, 16))
>c : Symbol(c, Decl(file1.ts, 17, 11))
>member : Symbol(member, Decl(file1.ts, 17, 16))
>charAt : Symbol(String.charAt, Decl(lib.es5.d.ts, --, --))

