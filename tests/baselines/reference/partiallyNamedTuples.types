=== tests/cases/conformance/types/tuple/named/partiallyNamedTuples.ts ===
type NamedAndAnonymous = [a: string, number];
>NamedAndAnonymous : [a: string, number]

function fa1(...args: NamedAndAnonymous) {}
>fa1 : (a: string, args_1: number) => void
>args : NamedAndAnonymous

function fa2(a: NamedAndAnonymous, ...args: NamedAndAnonymous) {}
>fa2 : (a: NamedAndAnonymous, a: string, args_1: number) => void
>a : NamedAndAnonymous
>args : NamedAndAnonymous

type NamedAnonymousMixed = [a: string, number, c: number, NamedAndAnonymous];
>NamedAnonymousMixed : [a: string, number, c: number, NamedAndAnonymous]

function fb1(...args: NamedAnonymousMixed) {}
>fb1 : (a: string, args_1: number, c: number, args_3: NamedAndAnonymous) => void
>args : NamedAnonymousMixed

function fb2(a: NamedAnonymousMixed, ...args: NamedAnonymousMixed) {}
>fb2 : (a: NamedAnonymousMixed, a: string, args_1: number, c: number, args_3: NamedAndAnonymous) => void
>a : NamedAnonymousMixed
>args : NamedAnonymousMixed

function fb3(a: NamedAnonymousMixed, ...args: NamedAnonymousMixed[3]) {}
>fb3 : (a: NamedAnonymousMixed, a: string, args_1: number) => void
>a : NamedAnonymousMixed
>args : NamedAndAnonymous

type ToAnonymousTuple<T extends unknown[]> = {
>ToAnonymousTuple : ToAnonymousTuple<T>

  [K in keyof T]: [K, T[K], keyof T, T];
};

type AnonymousToAnonymous = ToAnonymousTuple<[boolean, number]>;
>AnonymousToAnonymous : [["0", boolean, keyof [boolean, number], [boolean, number]], ["1", number, keyof [boolean, number], [boolean, number]]]

type MixedToAnonymous = ToAnonymousTuple<[boolean, second: number]>;
>MixedToAnonymous : [["0", boolean, keyof [boolean, second: number], [boolean, second: number]], second: ["1", number, keyof [boolean, second: number], [boolean, second: number]]]

type NamedToAnonymous = ToAnonymousTuple<[first: boolean, second: number]>;
>NamedToAnonymous : [first: ["0", boolean, keyof [first: boolean, second: number], [first: boolean, second: number]], second: ["1", number, keyof [first: boolean, second: number], [first: boolean, second: number]]]

type ToMixedTuple<T extends unknown[]> = {
>ToMixedTuple : ToMixedTuple<T>

  [K in keyof T]: [K, second: T[K], keyof T, fourth: T];
};

type AnonymousToMixed = ToAnonymousTuple<[boolean, number]>;
>AnonymousToMixed : [["0", boolean, keyof [boolean, number], [boolean, number]], ["1", number, keyof [boolean, number], [boolean, number]]]

type MixedToMixed = ToAnonymousTuple<[boolean, second: number]>;
>MixedToMixed : [["0", boolean, keyof [boolean, second: number], [boolean, second: number]], second: ["1", number, keyof [boolean, second: number], [boolean, second: number]]]

type NamedToMixed = ToAnonymousTuple<[first: boolean, second: number]>;
>NamedToMixed : [first: ["0", boolean, keyof [first: boolean, second: number], [first: boolean, second: number]], second: ["1", number, keyof [first: boolean, second: number], [first: boolean, second: number]]]

type MixedSpread = [first: boolean, ...[second: string]];
>MixedSpread : [first: boolean, second: string]

type ConditionalTuple = [
>ConditionalTuple : [first: boolean, second: string]

  first: boolean,
  ...(0 extends 0 ? [second: string] : [])
];

type AddMixedConditional<T> = [
>AddMixedConditional : [boolean, null, T extends number ? "a" : "b", ...T extends 0 ? [fourth: "c"] : []]

  first: boolean,
  null,
  third: T extends number ? "a" : "b",
  ...(T extends 0 ? [fourth: "c"] : [])
];

type AddMixedConditionalBoolean = AddMixedConditional<boolean>;
>AddMixedConditionalBoolean : [boolean, null, "b"]

type AddMixedConditionalLiteral = AddMixedConditional<0>;
>AddMixedConditionalLiteral : [boolean, null, "a", "c"]

type AddMixedConditionalNumberPrimitive = AddMixedConditional<number>;
>AddMixedConditionalNumberPrimitive : [boolean, null, "a"]

