=== tests/cases/conformance/types/primitives/numericLiteral/NaNLiteralTypes.ts ===
interface NaNMember {
>NaNMember : NaNMember

    member: NaN
>member : NaN
>NaN : NaN
}

let x: NaNMember;
>x : NaNMember
>NaNMember : NaNMember

x = {member: NaN as NaN}
>x = {member: NaN as NaN} : { member: NaN; }
>x : NaNMember
>{member: NaN as NaN} : { member: NaN; }
>member : NaN
>NaN as NaN : NaN
>NaN : number
>NaN : NaN

declare function stillNumber(x: number): boolean;
>stillNumber : (x: number) => boolean
>x : number

stillNumber(x.member);
>stillNumber(x.member) : boolean
>stillNumber : (x: number) => boolean
>x.member : NaN
>x : NaNMember
>member : NaN

//Check that NaN's declaration is still of type "number", while being "NaN" when used as a type, so its usage is opt-in
let y = NaN;
>y : number
>NaN : number

y = 42;
>y = 42 : number
>y : number
>42 : number

/*function isNaN(x: number): x is NaN {
    return x !== x;
}

let y: number;
if (isNaN(y)) {
    let a: NaN = y;
}
else {
    let b: number = y;
}
*/
