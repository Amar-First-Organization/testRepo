=== tests/cases/compiler/typeCall.ts ===
type F1 = () => 1;
>F1 : F1

type a = F1();
>a : 1
>F1 : F1

type F2 = (a: string) => 1;
>F2 : F2
>a : string

type b = F2('foo');
>b : 1
>F2 : F2

interface F3 {
>F3 : F3

    (): 1;
    (a: number): 2;
>a : number

    (a: string): 3;
>a : string
}
type c = F3();
>c : 1
>F3 : F3

type d = F3(123);
>d : 2
>F3 : F3

type e = F3('foo');
>e : 3
>F3 : F3

declare function f4(a: string): 1;
>f4 : (a: string) => 1
>a : string

let a = 'foo';
>a : string
>'foo' : "foo"

type f = typeof f4(typeof a);
>f : 1
>f4 : (a: string) => 1
>a : string

type g = (() => 1)();
>g : 1

type Id = <T>(v: T) => T;
>Id : Id
>T : T
>v : T
>T : T
>T : T

type h = Id(123);
>h : 123
>Id : Id

type Wrap<T> = Id(T);
>Wrap : T
>T : T
>Id : Id
>T : T

type i = Wrap<123>;
>i : 123
>Wrap : T

type F5 = () => () => { a: () => 1; };
>F5 : F5
>a : () => 1

type j = F5()()['a']();
>j : 1
>F5 : F5

type k = Id<string>('foo'); // `any`, explicit type argument fails
>k : any
>Id : Id

interface IsPrimitive {
>IsPrimitive : IsPrimitive

  <T extends object>(o: T): '0';
>T : T
>o : T
>T : T

  <T>(o: T): '1';
>T : T
>o : T
>T : T
}
type stringIsPrimitive = IsPrimitive(string); // '1', ok
>stringIsPrimitive : "1"
>IsPrimitive : IsPrimitive

type regexpIsPrimitive = IsPrimitive(RegExp); // '0', ok
>regexpIsPrimitive : "0"
>IsPrimitive : IsPrimitive
>RegExp : RegExp

// explicit type arguments still fail
type genericIsPrimitive = <T>() => IsPrimitive(T);
>genericIsPrimitive : genericIsPrimitive
>T : T
>IsPrimitive : IsPrimitive
>T : T

type stringIsPrimitive2 = genericIsPrimitive<string>();
>stringIsPrimitive2 : any
>genericIsPrimitive : genericIsPrimitive

type regexpIsPrimitive2 = genericIsPrimitive<RegExp>();
>regexpIsPrimitive2 : any
>genericIsPrimitive : genericIsPrimitive
>RegExp : RegExp

// workaround, pass as parameters
type genericIsPrimitive3 = <T>(v: T) => IsPrimitive(T);
>genericIsPrimitive3 : genericIsPrimitive3
>T : T
>v : T
>T : T
>IsPrimitive : IsPrimitive
>T : T

type stringIsPrimitive3 = genericIsPrimitive3(string); // '1', ok
>stringIsPrimitive3 : "1"
>genericIsPrimitive3 : genericIsPrimitive3

type regexpIsPrimitive3 = genericIsPrimitive3(RegExp)
>regexpIsPrimitive3 : "1"
>genericIsPrimitive3 : genericIsPrimitive3
>RegExp : RegExp

// FAILS!, '1' instead of '0', should delay overload selection until type argument is known

