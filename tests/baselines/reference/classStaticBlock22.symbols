=== tests/cases/conformance/classes/classStaticBlock/classStaticBlock22.ts ===
let await: "any";
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

class C {
>C : Symbol(C, Decl(classStaticBlock22.ts, 0, 17))

  static {
    let await: any; // illegal, cannot declare a new binding for await
>await : Symbol(await, Decl(classStaticBlock22.ts, 3, 7))
  }
  static {
    let { await } = {} as any; // illegal, cannot declare a new binding for await
>await : Symbol(await, Decl(classStaticBlock22.ts, 6, 9))
  }
  static {
    let { await: other } = {} as any; // legal
>other : Symbol(other, Decl(classStaticBlock22.ts, 9, 9))
  }
  static {
    let await; // illegal, cannot declare a new binding for await
>await : Symbol(await, Decl(classStaticBlock22.ts, 12, 7))
  }
  static {
    await; // illegal
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
  }
  static {
    await(1); // illegal
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
  }
  static {
    function await() {}; // illegal
>await : Symbol(await, Decl(classStaticBlock22.ts, 20, 10))
  }
  static {
    class await {}; // illegal
>await : Symbol(await, Decl(classStaticBlock22.ts, 23, 10))
  }
  static {
    ({ await }); // illegal short-hand property reference
>await : Symbol(await, Decl(classStaticBlock22.ts, 27, 6))
  }
  static {
    ({ [await]: 1 }); // illegal
>[await] : Symbol([await], Decl(classStaticBlock22.ts, 30, 6))
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
  }
  static {
    class D {
>D : Symbol(D, Decl(classStaticBlock22.ts, 32, 10))

        await = 1; // legal
>await : Symbol(D.await, Decl(classStaticBlock22.ts, 33, 13))

        x = await; // legal (initializers have an implicit function boundary)
>x : Symbol(D.x, Decl(classStaticBlock22.ts, 34, 18))
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

        [await] = 1; // illegal (computed property names are evaluated outside of a class body
>[await] : Symbol(D[await], Decl(classStaticBlock22.ts, 35, 18))
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

      };
  }
  static {
    (function await() {}); // legal, 'await' in function expression name not bound inside of static block
>await : Symbol(await, Decl(classStaticBlock22.ts, 40, 5))
  }
  static {
    (class await {}); // legal, 'await' in class expression name not bound inside of static block
>await : Symbol(await, Decl(classStaticBlock22.ts, 43, 5))
  }
  static {
    (function () { return await; }); // legal, 'await' is inside of a new function boundary
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
  }
  static {
    (() => await); // legal, 'await' is inside of a new function boundary
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
  }
  static {
    await: // illegal, 'await' cannot be used as a label
        break await; // illegal, 'await' cannot be used as a label
  }
}
