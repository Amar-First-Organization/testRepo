=== tests/cases/conformance/classes/classStaticBlock/classStaticBlock22.ts ===
let await: "any";
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

class C {
>C : Symbol(C, Decl(classStaticBlock22.ts, 0, 17))

  static {
    let await: any; // illegal, cannot declare a new binding for await
>await : Symbol(await, Decl(classStaticBlock22.ts, 3, 7))
  }
  static {
    let { await } = {} as any; // illegal, cannot declare a new binding for await
>await : Symbol(await, Decl(classStaticBlock22.ts, 6, 9))
  }
  static {
    let { await: other } = {} as any; // legal
>other : Symbol(other, Decl(classStaticBlock22.ts, 9, 9))
  }
  static {
    let await; // illegal, cannot declare a new binding for await
>await : Symbol(await, Decl(classStaticBlock22.ts, 12, 7))
  }
  static {
    await; // illegal
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
  }
  static {
    await(1); // illegal
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
  }
  static {
    function await() {}; // illegal
>await : Symbol(await, Decl(classStaticBlock22.ts, 20, 10))
  }
  static {
    class await {}; // illegal
>await : Symbol(await, Decl(classStaticBlock22.ts, 23, 10))
  }
  static {
    ({ await }); // illegal short-hand property reference
>await : Symbol(await, Decl(classStaticBlock22.ts, 27, 6))
  }
  static {
    ({ [await]: 1 }); // illegal
>[await] : Symbol([await], Decl(classStaticBlock22.ts, 30, 6))
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
  }
  static {
    class D {
>D : Symbol(D, Decl(classStaticBlock22.ts, 32, 10))

        await = 1; // legal
>await : Symbol(D.await, Decl(classStaticBlock22.ts, 33, 13))

        x = await; // legal (initializers have an implicit function boundary)
>x : Symbol(D.x, Decl(classStaticBlock22.ts, 34, 18))
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

        [await] = 1; // illegal (computed property names are evaluated outside of a class body
>[await] : Symbol(D[await], Decl(classStaticBlock22.ts, 35, 18))
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

      };
  }
  static {
    (function await() {}); // legal, 'await' in function expression name not bound inside of static block
>await : Symbol(await, Decl(classStaticBlock22.ts, 40, 5))
  }
  static {
    (class await {}); // legal, 'await' in class expression name not bound inside of static block
>await : Symbol(await, Decl(classStaticBlock22.ts, 43, 5))
  }
  static {
    (function () { return await; }); // legal, 'await' is inside of a new function boundary
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
  }
  static {
    (() => await); // legal, 'await' is inside of a new function boundary
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
  }
  static {
    await: // illegal, 'await' cannot be used as a label
        break await; // illegal, 'await' cannot be used as a label
  }
  static {
    class E {
>E : Symbol(E, Decl(classStaticBlock22.ts, 55, 10))

      constructor () { await; }
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

      method () { await; }
>method : Symbol(E.method, Decl(classStaticBlock22.ts, 57, 31))
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

      get accessor () {
>accessor : Symbol(E.accessor, Decl(classStaticBlock22.ts, 58, 26), Decl(classStaticBlock22.ts, 62, 7))

        await;
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

        return 1;
      }
      set accessor (v: any) {
>accessor : Symbol(E.accessor, Decl(classStaticBlock22.ts, 58, 26), Decl(classStaticBlock22.ts, 62, 7))
>v : Symbol(v, Decl(classStaticBlock22.ts, 63, 20))

        await;
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
      }
      propLambda = () => { await; }
>propLambda : Symbol(E.propLambda, Decl(classStaticBlock22.ts, 65, 7))
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

      propFunc = function () { await; }
>propFunc : Symbol(E.propFunc, Decl(classStaticBlock22.ts, 66, 35))
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
    }
  }
  static {
    class S {
>S : Symbol(S, Decl(classStaticBlock22.ts, 70, 10))

      static method () { await; }
>method : Symbol(S.method, Decl(classStaticBlock22.ts, 71, 13))
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

      static get accessor () {
>accessor : Symbol(S.accessor, Decl(classStaticBlock22.ts, 72, 33), Decl(classStaticBlock22.ts, 76, 7))

        await;
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

        return 1;
      }
      static set accessor (v: any) {
>accessor : Symbol(S.accessor, Decl(classStaticBlock22.ts, 72, 33), Decl(classStaticBlock22.ts, 76, 7))
>v : Symbol(v, Decl(classStaticBlock22.ts, 77, 27))

        await;
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
      }
      static propLambda = () => { await; }
>propLambda : Symbol(S.propLambda, Decl(classStaticBlock22.ts, 79, 7))
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))

      static propFunc = function () { await; }
>propFunc : Symbol(S.propFunc, Decl(classStaticBlock22.ts, 80, 42))
>await : Symbol(await, Decl(classStaticBlock22.ts, 0, 3))
    }
  }
  static {
    function f (await) {}
>f : Symbol(f, Decl(classStaticBlock22.ts, 84, 10))
>await : Symbol(await, Decl(classStaticBlock22.ts, 85, 16))

    const ff = (await) => {}
>ff : Symbol(ff, Decl(classStaticBlock22.ts, 86, 9))
>await : Symbol(await, Decl(classStaticBlock22.ts, 86, 16))

    const fff = await => {}
>fff : Symbol(fff, Decl(classStaticBlock22.ts, 87, 9))
>await : Symbol(await, Decl(classStaticBlock22.ts, 87, 15))
  }
}
