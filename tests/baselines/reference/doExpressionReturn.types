=== tests/cases/compiler/doExpressionReturn.ts ===
declare let v: boolean
>v : boolean

function returnTypeInfer() {
>returnTypeInfer : () => number

    const y = do { return 1 }
>y : never
>do { return 1 } : never
>1 : 1
}

function returnTypeCheck(): string {
>returnTypeCheck : () => string

    const y = do { return 1 }
>y : never
>do { return 1 } : never
>1 : 1
}

function avoidFalsePositive() {
>avoidFalsePositive : () => void

    const y = do {
>y : 1
>do {        function z() {            return 1        }        1    } : 1

        function z() {
>z : () => number

            return 1
>1 : 1
        }
        1
>1 : 1
    }
}

function tryCatch() {
>tryCatch : () => void

    try {
        const y = do { if (v) return; 1; }
>y : 1
>do { if (v) return; 1; } : 1
>v : boolean
>1 : 1

    } catch { 1 }
>1 : 1

    try {
        const y = do { if (v) return; 1; }
>y : 1
>do { if (v) return; 1; } : 1
>v : boolean
>1 : 1

    } catch (e) { 1 }
>e : any
>1 : 1

    try {
        const y = do { if (v) return; 1; }
>y : 1
>do { if (v) return; 1; } : 1
>v : boolean
>1 : 1

    } catch ({ a = 1 }) { 1 }
>a : any
>1 : 1
>1 : 1
}

function avoidSignatureToBeCaptured(): void {
>avoidSignatureToBeCaptured : () => void

    const a = do {
>a : 1
>do {        try {            if (v) return; 1;        } catch { 1 }    } : 1

        try {
            if (v) return; 1;
>v : boolean
>1 : 1

        } catch { 1 }
>1 : 1

    };
    const b = do {
>b : 1
>do {        try {            if (v) return; 1;        } catch (d) { 1 }    } : 1

        try {
            if (v) return; 1;
>v : boolean
>1 : 1

        } catch (d) { 1 }
>d : any
>1 : 1

    };
    const c = do {
>c : 1
>do {        try {            if (v) return; 1;        } catch ({ a = 1 }) { 1 }    } : 1

        try {
            if (v) return; 1;
>v : boolean
>1 : 1

        } catch ({ a = 1 }) { 1 }
>a : any
>1 : 1
>1 : 1

    };
}

