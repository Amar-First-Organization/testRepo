=== tests/cases/compiler/contextualTypeShouldBeLiteral.ts ===
interface X {
>X : X

    type: 'x';
>type : "x"

    value: string;
>value : string
}

interface Y {
>Y : Y

    type: 'y';
>type : "y"

    value: 'none' | 'done';
>value : "none" | "done"
}

function foo(bar: X | Y) { }
>foo : (bar: X | Y) => void
>bar : X | Y
>X : X
>Y : Y

foo({
>foo({    type: 'y',    value: 'done',}) : void
>foo : (bar: X | Y) => void
>{    type: 'y',    value: 'done',} : { type: "y"; value: "done"; }

    type: 'y',
>type : string
>'y' : "y"

    value: 'done',
>value : string
>'done' : "done"

});

interface X2 {
>X2 : X2

    type1: 'x';
>type1 : "x"

    value: string;
>value : string
}

interface Y2 {
>Y2 : Y2

    type2: 'y';
>type2 : "y"

    value: 'none' | 'done';
>value : "none" | "done"
}

function foo2(bar: X2 | Y2) { }
>foo2 : (bar: X2 | Y2) => void
>bar : X2 | Y2
>X2 : X2
>Y2 : Y2

foo2({
>foo2({    type2: 'y',    value: 'done',}) : void
>foo2 : (bar: X2 | Y2) => void
>{    type2: 'y',    value: 'done',} : { type2: "y"; value: "done"; }

    type2: 'y',
>type2 : string
>'y' : "y"

    value: 'done',
>value : string
>'done' : "done"

});

interface X3 {
>X3 : X3

    type: 'x';
>type : "x"

    value: 1 | 2 | 3;
>value : 1 | 2 | 3

    xtra: number;
>xtra : number
}

interface Y3 {
>Y3 : Y3

    type: 'y';
>type : "y"

    value: 11 | 12 | 13;
>value : 11 | 12 | 13

    ytra: number;
>ytra : number
}

let xy: X3 | Y3 = {
>xy : X3 | Y3
>X3 : X3
>Y3 : Y3
>{    type: 'y',    value: 11,    ytra: 12} : { type: "y"; value: 11; ytra: number; }

    type: 'y',
>type : string
>'y' : "y"

    value: 11,
>value : number
>11 : 11

    ytra: 12
>ytra : number
>12 : 12

};

xy;
>xy : Y3

