=== tests/cases/compiler/inDoesNotOperateOnPrimitiveTypes.ts ===
const validHasKey = <T extends object>(
>validHasKey : Symbol(validHasKey, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 0, 5))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 0, 21))

  thing: T,
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 0, 39))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 0, 21))

  key: string,
>key : Symbol(key, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 1, 11))

): boolean => {
  return key in thing;
>key : Symbol(key, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 1, 11))
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 0, 39))

};

const alsoValidHasKey = <T>(
>alsoValidHasKey : Symbol(alsoValidHasKey, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 7, 5))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 7, 25))

  thing: T,
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 7, 28))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 7, 25))

  key: string,
>key : Symbol(key, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 8, 11))

): boolean => {
  return key in thing;
>key : Symbol(key, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 8, 11))
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 7, 28))

};

function invalidHasKey<T extends string | number>(
>invalidHasKey : Symbol(invalidHasKey, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 12, 2))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 14, 23))

  thing: T,
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 14, 50))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 14, 23))

  key: string,
>key : Symbol(key, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 15, 11))

): boolean {
  return key in thing;
>key : Symbol(key, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 15, 11))
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 14, 50))
}

function union1<T extends string | number, U extends boolean>(thing: T | U) {
>union1 : Symbol(union1, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 19, 1))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 21, 16))
>U : Symbol(U, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 21, 42))
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 21, 62))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 21, 16))
>U : Symbol(U, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 21, 42))

  "key" in thing; // Error (because all possible instantiations are errors)
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 21, 62))
}

function union2<T extends object, U extends string | number>(thing: T | U) {
>union2 : Symbol(union2, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 23, 1))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 25, 16))
>U : Symbol(U, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 25, 33))
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 25, 61))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 25, 16))
>U : Symbol(U, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 25, 33))

  "key" in thing; // Error (because narrowing is possible)
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 25, 61))

  if (typeof thing === "object") {
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 25, 61))

    "key" in thing; // Ok
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 25, 61))
  }
}

function union3<T>(thing: T | string | number) {
>union3 : Symbol(union3, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 30, 1))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 32, 16))
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 32, 19))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 32, 16))

  "key" in thing; // Error (because narrowing is possible)
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 32, 19))

  if (typeof thing !== "string" && typeof thing !== "number") {
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 32, 19))
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 32, 19))

    "key" in thing; // Ok, because further narrowing is impossible
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 32, 19))
  }
}

function union4<T extends object | "hello">(thing: T) {
>union4 : Symbol(union4, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 37, 1))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 39, 16))
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 39, 44))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 39, 16))

  "key" in thing; // Error (because union includes string literal)
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 39, 44))
}

function union5<T extends object | string>(thing: T) {
>union5 : Symbol(union5, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 41, 1))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 43, 16))
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 43, 43))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 43, 16))

  "key" in thing; // Error (because union includes string)
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 43, 43))
}

function intersection1<T extends number, U extends 0 | 1 | 2>(thing: T & U) {
>intersection1 : Symbol(intersection1, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 45, 1))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 47, 23))
>U : Symbol(U, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 47, 40))
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 47, 62))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 47, 23))
>U : Symbol(U, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 47, 40))

  "key" in thing; // Error (because all possible instantiations are errors)
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 47, 62))
}

function intersection2<T>(thing: T & (0 | 1 | 2)) {
>intersection2 : Symbol(intersection2, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 49, 1))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 51, 23))
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 51, 26))
>T : Symbol(T, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 51, 23))

  "key" in thing; // Error (because all possible instantations are errors)
>thing : Symbol(thing, Decl(inDoesNotOperateOnPrimitiveTypes.ts, 51, 26))
}

