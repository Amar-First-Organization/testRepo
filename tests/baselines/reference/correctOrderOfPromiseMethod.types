=== tests/cases/compiler/correctOrderOfPromiseMethod.ts ===
interface A {
>A : A

    id: string
>id : string
}

interface B {
>B : B

    id: string
>id : string

    fieldB: string
>fieldB : string
}

async function countEverything(): Promise<number> {
>countEverything : () => Promise<number>
>Promise : Promise<T>

    const providerA = async (): Promise<A[]> => { return [] }
>providerA : () => Promise<A[]>
>async (): Promise<A[]> => { return [] } : () => Promise<A[]>
>Promise : Promise<T>
>A : A
>[] : undefined[]

    const providerB = async (): Promise<B[]> => { return [] }
>providerB : () => Promise<B[]>
>async (): Promise<B[]> => { return [] } : () => Promise<B[]>
>Promise : Promise<T>
>B : B
>[] : undefined[]

    const [resultA, resultB] = await Promise.all([
>resultA : A[]
>resultB : B[]
>await Promise.all([        providerA(),        providerB(),    ]) : [A[], B[]]
>Promise.all([        providerA(),        providerB(),    ]) : Promise<[A[], B[]]>
>Promise.all : { <T>(values: Iterable<T>): Promise<Awaited<T>[]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>, Awaited<T5>, Awaited<T6>, Awaited<T7>, Awaited<T8>, Awaited<T9>, Awaited<T10>]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1, T2, T3, T4, T5, T6, T7, T8, T9]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>, Awaited<T5>, Awaited<T6>, Awaited<T7>, Awaited<T8>, Awaited<T9>]>; <T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1, T2, T3, T4, T5, T6, T7, T8]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>, Awaited<T5>, Awaited<T6>, Awaited<T7>, Awaited<T8>]>; <T1, T2, T3, T4, T5, T6, T7>(values: [T1, T2, T3, T4, T5, T6, T7]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>, Awaited<T5>, Awaited<T6>, Awaited<T7>]>; <T1, T2, T3, T4, T5, T6>(values: [T1, T2, T3, T4, T5, T6]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>, Awaited<T5>, Awaited<T6>]>; <T1, T2, T3, T4, T5>(values: [T1, T2, T3, T4, T5]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>, Awaited<T5>]>; <T1, T2, T3, T4>(values: [T1, T2, T3, T4]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>]>; <T1, T2, T3>(values: [T1, T2, T3]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>]>; <T1, T2>(values: [T1, T2]): Promise<[Awaited<T1>, Awaited<T2>]>; <T>(values: T[]): Promise<Awaited<T>[]>; }
>Promise : PromiseConstructor
>all : { <T>(values: Iterable<T>): Promise<Awaited<T>[]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>, Awaited<T5>, Awaited<T6>, Awaited<T7>, Awaited<T8>, Awaited<T9>, Awaited<T10>]>; <T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1, T2, T3, T4, T5, T6, T7, T8, T9]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>, Awaited<T5>, Awaited<T6>, Awaited<T7>, Awaited<T8>, Awaited<T9>]>; <T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1, T2, T3, T4, T5, T6, T7, T8]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>, Awaited<T5>, Awaited<T6>, Awaited<T7>, Awaited<T8>]>; <T1, T2, T3, T4, T5, T6, T7>(values: [T1, T2, T3, T4, T5, T6, T7]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>, Awaited<T5>, Awaited<T6>, Awaited<T7>]>; <T1, T2, T3, T4, T5, T6>(values: [T1, T2, T3, T4, T5, T6]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>, Awaited<T5>, Awaited<T6>]>; <T1, T2, T3, T4, T5>(values: [T1, T2, T3, T4, T5]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>, Awaited<T5>]>; <T1, T2, T3, T4>(values: [T1, T2, T3, T4]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>, Awaited<T4>]>; <T1, T2, T3>(values: [T1, T2, T3]): Promise<[Awaited<T1>, Awaited<T2>, Awaited<T3>]>; <T1, T2>(values: [T1, T2]): Promise<[Awaited<T1>, Awaited<T2>]>; <T>(values: T[]): Promise<Awaited<T>[]>; }
>[        providerA(),        providerB(),    ] : [Promise<A[]>, Promise<B[]>]

        providerA(),
>providerA() : Promise<A[]>
>providerA : () => Promise<A[]>

        providerB(),
>providerB() : Promise<B[]>
>providerB : () => Promise<B[]>

    ]);

    const dataA: A[] = resultA;
>dataA : A[]
>A : A
>resultA : A[]

    const dataB: B[] = resultB;
>dataB : B[]
>B : B
>resultB : B[]

    if (dataA && dataB) {
>dataA && dataB : B[]
>dataA : A[]
>dataB : B[]

        return dataA.length + dataB.length;
>dataA.length + dataB.length : number
>dataA.length : number
>dataA : A[]
>length : number
>dataB.length : number
>dataB : B[]
>length : number
    }
    return 0;
>0 : 0
}
