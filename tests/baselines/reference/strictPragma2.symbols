=== tests/cases/conformance/pragma/strict/file1.ts ===
// @ts-strict
export function f1(x: string) {}
>f1 : Symbol(f1, Decl(file1.ts, 0, 0))
>x : Symbol(x, Decl(file1.ts, 1, 19))

f1.call(undefined, 42); // wrong
>f1.call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>f1 : Symbol(f1, Decl(file1.ts, 0, 0))
>call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>undefined : Symbol(undefined)

f1.call(undefined, "ok"); // right
>f1.call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>f1 : Symbol(f1, Decl(file1.ts, 0, 0))
>call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>undefined : Symbol(undefined)

export let a = (arg: string) => 0;
>a : Symbol(a, Decl(file1.ts, 5, 10))
>arg : Symbol(arg, Decl(file1.ts, 5, 16))

export let b = (arg: unknown) => 0;
>b : Symbol(b, Decl(file1.ts, 6, 10))
>arg : Symbol(arg, Decl(file1.ts, 6, 16))

a = b;
>a : Symbol(a, Decl(file1.ts, 5, 10))
>b : Symbol(b, Decl(file1.ts, 6, 10))

b = a;
>b : Symbol(b, Decl(file1.ts, 6, 10))
>a : Symbol(a, Decl(file1.ts, 5, 10))

export class A {
>A : Symbol(A, Decl(file1.ts, 9, 6))

    prop: string;
>prop : Symbol(A.prop, Decl(file1.ts, 11, 16))

    constructor() {}
}

declare var c: { member?: string };
>c : Symbol(c, Decl(file1.ts, 16, 11))
>member : Symbol(member, Decl(file1.ts, 16, 16))

c.member.charAt(0);
>c.member.charAt : Symbol(String.charAt, Decl(lib.es5.d.ts, --, --))
>c.member : Symbol(member, Decl(file1.ts, 16, 16))
>c : Symbol(c, Decl(file1.ts, 16, 11))
>member : Symbol(member, Decl(file1.ts, 16, 16))
>charAt : Symbol(String.charAt, Decl(lib.es5.d.ts, --, --))

=== tests/cases/conformance/pragma/strict/file2.ts ===
// @ts-strict true
export function f1(x: string) {}
>f1 : Symbol(f1, Decl(file2.ts, 0, 0))
>x : Symbol(x, Decl(file2.ts, 1, 19))

f1.call(undefined, 42); // wrong
>f1.call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>f1 : Symbol(f1, Decl(file2.ts, 0, 0))
>call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>undefined : Symbol(undefined)

f1.call(undefined, "ok"); // right
>f1.call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>f1 : Symbol(f1, Decl(file2.ts, 0, 0))
>call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>undefined : Symbol(undefined)

export let a = (arg: string) => 0;
>a : Symbol(a, Decl(file2.ts, 5, 10))
>arg : Symbol(arg, Decl(file2.ts, 5, 16))

export let b = (arg: unknown) => 0;
>b : Symbol(b, Decl(file2.ts, 6, 10))
>arg : Symbol(arg, Decl(file2.ts, 6, 16))

a = b;
>a : Symbol(a, Decl(file2.ts, 5, 10))
>b : Symbol(b, Decl(file2.ts, 6, 10))

b = a;
>b : Symbol(b, Decl(file2.ts, 6, 10))
>a : Symbol(a, Decl(file2.ts, 5, 10))

export class A {
>A : Symbol(A, Decl(file2.ts, 9, 6))

    prop: string;
>prop : Symbol(A.prop, Decl(file2.ts, 11, 16))

    constructor() {}
}

declare var c: { member?: string };
>c : Symbol(c, Decl(file2.ts, 16, 11))
>member : Symbol(member, Decl(file2.ts, 16, 16))

c.member.charAt(0);
>c.member.charAt : Symbol(String.charAt, Decl(lib.es5.d.ts, --, --))
>c.member : Symbol(member, Decl(file2.ts, 16, 16))
>c : Symbol(c, Decl(file2.ts, 16, 11))
>member : Symbol(member, Decl(file2.ts, 16, 16))
>charAt : Symbol(String.charAt, Decl(lib.es5.d.ts, --, --))

=== tests/cases/conformance/pragma/strict/file3.ts ===
// @ts-strict false
export function f1(x: string) {}
>f1 : Symbol(f1, Decl(file3.ts, 0, 0))
>x : Symbol(x, Decl(file3.ts, 1, 19))

f1.call(undefined, 42); // wrong
>f1.call : Symbol(Function.call, Decl(lib.es5.d.ts, --, --))
>f1 : Symbol(f1, Decl(file3.ts, 0, 0))
>call : Symbol(Function.call, Decl(lib.es5.d.ts, --, --))
>undefined : Symbol(undefined)

f1.call(undefined, "ok"); // right
>f1.call : Symbol(Function.call, Decl(lib.es5.d.ts, --, --))
>f1 : Symbol(f1, Decl(file3.ts, 0, 0))
>call : Symbol(Function.call, Decl(lib.es5.d.ts, --, --))
>undefined : Symbol(undefined)

export let a = (arg: string) => 0;
>a : Symbol(a, Decl(file3.ts, 5, 10))
>arg : Symbol(arg, Decl(file3.ts, 5, 16))

export let b = (arg: unknown) => 0;
>b : Symbol(b, Decl(file3.ts, 6, 10))
>arg : Symbol(arg, Decl(file3.ts, 6, 16))

a = b;
>a : Symbol(a, Decl(file3.ts, 5, 10))
>b : Symbol(b, Decl(file3.ts, 6, 10))

b = a;
>b : Symbol(b, Decl(file3.ts, 6, 10))
>a : Symbol(a, Decl(file3.ts, 5, 10))

export class A {
>A : Symbol(A, Decl(file3.ts, 9, 6))

    prop: string;
>prop : Symbol(A.prop, Decl(file3.ts, 11, 16))

    constructor() {}
}

declare var c: { member?: string };
>c : Symbol(c, Decl(file3.ts, 16, 11))
>member : Symbol(member, Decl(file3.ts, 16, 16))

c.member.charAt(0);
>c.member.charAt : Symbol(String.charAt, Decl(lib.es5.d.ts, --, --))
>c.member : Symbol(member, Decl(file3.ts, 16, 16))
>c : Symbol(c, Decl(file3.ts, 16, 11))
>member : Symbol(member, Decl(file3.ts, 16, 16))
>charAt : Symbol(String.charAt, Decl(lib.es5.d.ts, --, --))

=== tests/cases/conformance/pragma/strict/file4.ts ===
export function f1(x: string) {}
>f1 : Symbol(f1, Decl(file4.ts, 0, 0))
>x : Symbol(x, Decl(file4.ts, 0, 19))

f1.call(undefined, 42); // wrong
>f1.call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>f1 : Symbol(f1, Decl(file4.ts, 0, 0))
>call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>undefined : Symbol(undefined)

f1.call(undefined, "ok"); // right
>f1.call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>f1 : Symbol(f1, Decl(file4.ts, 0, 0))
>call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>undefined : Symbol(undefined)

export let a = (arg: string) => 0;
>a : Symbol(a, Decl(file4.ts, 4, 10))
>arg : Symbol(arg, Decl(file4.ts, 4, 16))

export let b = (arg: unknown) => 0;
>b : Symbol(b, Decl(file4.ts, 5, 10))
>arg : Symbol(arg, Decl(file4.ts, 5, 16))

a = b;
>a : Symbol(a, Decl(file4.ts, 4, 10))
>b : Symbol(b, Decl(file4.ts, 5, 10))

b = a;
>b : Symbol(b, Decl(file4.ts, 5, 10))
>a : Symbol(a, Decl(file4.ts, 4, 10))

export class A {
>A : Symbol(A, Decl(file4.ts, 8, 6))

    prop: string;
>prop : Symbol(A.prop, Decl(file4.ts, 10, 16))

    constructor() {}
}

declare var c: { member?: string };
>c : Symbol(c, Decl(file4.ts, 15, 11))
>member : Symbol(member, Decl(file4.ts, 15, 16))

c.member.charAt(0);
>c.member.charAt : Symbol(String.charAt, Decl(lib.es5.d.ts, --, --))
>c.member : Symbol(member, Decl(file4.ts, 15, 16))
>c : Symbol(c, Decl(file4.ts, 15, 11))
>member : Symbol(member, Decl(file4.ts, 15, 16))
>charAt : Symbol(String.charAt, Decl(lib.es5.d.ts, --, --))

