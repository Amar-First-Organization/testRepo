=== tests/cases/compiler/declarationEmitPromise.ts ===
export class bluebird<T> {
>bluebird : bluebird<T>

    static all: Array<bluebird<any>>;
>all : bluebird<any>[]
}

export async function runSampleWorks<A, B, C, D, E>(
>runSampleWorks : <A, B, C, D, E>(a: bluebird<A>, b?: bluebird<B>, c?: bluebird<C>, d?: bluebird<D>, e?: bluebird<E>) => Promise<(<T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T)>

    a: bluebird<A>, b?: bluebird<B>, c?: bluebird<C>, d?: bluebird<D>, e?: bluebird<E>) {
>a : bluebird<A>
>b : bluebird<B>
>c : bluebird<C>
>d : bluebird<D>
>e : bluebird<E>

    let result = await (bluebird.all as any)([a, b, c, d, e].filter(el => !!el));
>result : any
>await (bluebird.all as any)([a, b, c, d, e].filter(el => !!el)) : any
>(bluebird.all as any)([a, b, c, d, e].filter(el => !!el)) : any
>(bluebird.all as any) : any
>bluebird.all as any : any
>bluebird.all : bluebird<any>[]
>bluebird : typeof bluebird
>all : bluebird<any>[]
>[a, b, c, d, e].filter(el => !!el) : (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]
>[a, b, c, d, e].filter : { <S extends bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>>(callbackfn: (value: bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>, index: number, array: (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]) => value is S, thisArg?: any): S[]; (callbackfn: (value: bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>, index: number, array: (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]) => any, thisArg?: any): (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]; }
>[a, b, c, d, e] : (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]
>a : bluebird<A>
>b : bluebird<B>
>c : bluebird<C>
>d : bluebird<D>
>e : bluebird<E>
>filter : { <S extends bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>>(callbackfn: (value: bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>, index: number, array: (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]) => value is S, thisArg?: any): S[]; (callbackfn: (value: bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>, index: number, array: (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]) => any, thisArg?: any): (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]; }
>el => !!el : (el: bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>) => boolean
>el : bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>
>!!el : boolean
>!el : boolean
>el : bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>

    let func = <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T): T =>
>func : <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T
><T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T): T =>        f.apply(this, result) : <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T
>f : (a: A, b?: B, c?: C, d?: D, e?: E) => T
>a : A
>b : B
>c : C
>d : D
>e : E

        f.apply(this, result);
>f.apply(this, result) : any
>f.apply : (this: Function, thisArg: any, argArray?: any) => any
>f : (a: A, b?: B, c?: C, d?: D, e?: E) => T
>apply : (this: Function, thisArg: any, argArray?: any) => any
>this : any
>result : any

    let rfunc: typeof func & {} = func as any; // <- This is the only difference
>rfunc : <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T
>func : <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T
>func as any : any
>func : <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T

    return rfunc
>rfunc : <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T
}

export async function runSampleBreaks<A, B, C, D, E>(
>runSampleBreaks : <A, B, C, D, E>(a: bluebird<A>, b?: bluebird<B>, c?: bluebird<C>, d?: bluebird<D>, e?: bluebird<E>) => Promise<(<T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T)>

    a: bluebird<A>, b?: bluebird<B>, c?: bluebird<C>, d?: bluebird<D>, e?: bluebird<E>) {
>a : bluebird<A>
>b : bluebird<B>
>c : bluebird<C>
>d : bluebird<D>
>e : bluebird<E>

    let result = await (bluebird.all as any)([a, b, c, d, e].filter(el => !!el));
>result : any
>await (bluebird.all as any)([a, b, c, d, e].filter(el => !!el)) : any
>(bluebird.all as any)([a, b, c, d, e].filter(el => !!el)) : any
>(bluebird.all as any) : any
>bluebird.all as any : any
>bluebird.all : bluebird<any>[]
>bluebird : typeof bluebird
>all : bluebird<any>[]
>[a, b, c, d, e].filter(el => !!el) : (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]
>[a, b, c, d, e].filter : { <S extends bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>>(callbackfn: (value: bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>, index: number, array: (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]) => value is S, thisArg?: any): S[]; (callbackfn: (value: bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>, index: number, array: (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]) => any, thisArg?: any): (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]; }
>[a, b, c, d, e] : (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]
>a : bluebird<A>
>b : bluebird<B>
>c : bluebird<C>
>d : bluebird<D>
>e : bluebird<E>
>filter : { <S extends bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>>(callbackfn: (value: bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>, index: number, array: (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]) => value is S, thisArg?: any): S[]; (callbackfn: (value: bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>, index: number, array: (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]) => any, thisArg?: any): (bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>)[]; }
>el => !!el : (el: bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>) => boolean
>el : bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>
>!!el : boolean
>!el : boolean
>el : bluebird<A> | bluebird<B> | bluebird<C> | bluebird<D> | bluebird<E>

    let func = <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T): T =>
>func : <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T
><T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T): T =>        f.apply(this, result) : <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T
>f : (a: A, b?: B, c?: C, d?: D, e?: E) => T
>a : A
>b : B
>c : C
>d : D
>e : E

        f.apply(this, result);
>f.apply(this, result) : any
>f.apply : (this: Function, thisArg: any, argArray?: any) => any
>f : (a: A, b?: B, c?: C, d?: D, e?: E) => T
>apply : (this: Function, thisArg: any, argArray?: any) => any
>this : any
>result : any

    let rfunc: typeof func = func as any; // <- This is the only difference
>rfunc : <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T
>func : <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T
>func as any : any
>func : <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T

    return rfunc
>rfunc : <T>(f: (a: A, b?: B, c?: C, d?: D, e?: E) => T) => T
}
