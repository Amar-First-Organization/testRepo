=== tests/cases/conformance/types/spread/objectSpreadUnion.ts ===
// concrete types work
interface A1 { a: number }
>A1 : Symbol(A1, Decl(objectSpreadUnion.ts, 0, 0))
>a : Symbol(A1.a, Decl(objectSpreadUnion.ts, 1, 14))

interface A2 { a: string }
>A2 : Symbol(A2, Decl(objectSpreadUnion.ts, 1, 26))
>a : Symbol(A2.a, Decl(objectSpreadUnion.ts, 2, 14))

let a12: A1 | A2;
>a12 : Symbol(a12, Decl(objectSpreadUnion.ts, 3, 3))
>A1 : Symbol(A1, Decl(objectSpreadUnion.ts, 0, 0))
>A2 : Symbol(A2, Decl(objectSpreadUnion.ts, 1, 26))

let result = { ...a12 };
>result : Symbol(result, Decl(objectSpreadUnion.ts, 4, 3))
>a12 : Symbol(a12, Decl(objectSpreadUnion.ts, 3, 3))

let sn: number | string = result.a;
>sn : Symbol(sn, Decl(objectSpreadUnion.ts, 5, 3))
>result.a : Symbol(a, Decl(objectSpreadUnion.ts, 1, 14), Decl(objectSpreadUnion.ts, 2, 14))
>result : Symbol(result, Decl(objectSpreadUnion.ts, 4, 3))
>a : Symbol(a, Decl(objectSpreadUnion.ts, 1, 14), Decl(objectSpreadUnion.ts, 2, 14))

let assignable: spread(A1 | A2) = result;
>assignable : Symbol(assignable, Decl(objectSpreadUnion.ts, 6, 3))
>A1 : Symbol(A1, Decl(objectSpreadUnion.ts, 0, 0))
>A2 : Symbol(A2, Decl(objectSpreadUnion.ts, 1, 26))
>result : Symbol(result, Decl(objectSpreadUnion.ts, 4, 3))

function tripleUnion<T, U, V>(t: T, u: U, v: V): void {
>tripleUnion : Symbol(tripleUnion, Decl(objectSpreadUnion.ts, 6, 41))
>T : Symbol(T, Decl(objectSpreadUnion.ts, 8, 21))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 8, 23))
>V : Symbol(V, Decl(objectSpreadUnion.ts, 8, 26))
>t : Symbol(t, Decl(objectSpreadUnion.ts, 8, 30))
>T : Symbol(T, Decl(objectSpreadUnion.ts, 8, 21))
>u : Symbol(u, Decl(objectSpreadUnion.ts, 8, 35))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 8, 23))
>v : Symbol(v, Decl(objectSpreadUnion.ts, 8, 41))
>V : Symbol(V, Decl(objectSpreadUnion.ts, 8, 26))

    let tuv: T | U | V;
>tuv : Symbol(tuv, Decl(objectSpreadUnion.ts, 9, 7))
>T : Symbol(T, Decl(objectSpreadUnion.ts, 8, 21))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 8, 23))
>V : Symbol(V, Decl(objectSpreadUnion.ts, 8, 26))

    let result = { ...tuv, id: 'foo' };
>result : Symbol(result, Decl(objectSpreadUnion.ts, 10, 7))
>tuv : Symbol(tuv, Decl(objectSpreadUnion.ts, 9, 7))
>id : Symbol(id, Decl(objectSpreadUnion.ts, 10, 26))

    let expected: spread(T, { id: string }) | spread(U, { id: string }) | spread(V, { id: string }) = result;
>expected : Symbol(expected, Decl(objectSpreadUnion.ts, 11, 7))
>T : Symbol(T, Decl(objectSpreadUnion.ts, 8, 21))
>id : Symbol(id, Decl(objectSpreadUnion.ts, 11, 29))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 8, 23))
>id : Symbol(id, Decl(objectSpreadUnion.ts, 11, 57))
>V : Symbol(V, Decl(objectSpreadUnion.ts, 8, 26))
>id : Symbol(id, Decl(objectSpreadUnion.ts, 11, 85))
>result : Symbol(result, Decl(objectSpreadUnion.ts, 10, 7))

    let assignable: spread(T | U | V, { id: string }) = result;
>assignable : Symbol(assignable, Decl(objectSpreadUnion.ts, 12, 7))
>T : Symbol(T, Decl(objectSpreadUnion.ts, 8, 21))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 8, 23))
>V : Symbol(V, Decl(objectSpreadUnion.ts, 8, 26))
>id : Symbol(id, Decl(objectSpreadUnion.ts, 12, 39))
>result : Symbol(result, Decl(objectSpreadUnion.ts, 10, 7))
}
function iteratedDoubleUnion<T, U, V>(t: T, u: U, v: V): void {
>iteratedDoubleUnion : Symbol(iteratedDoubleUnion, Decl(objectSpreadUnion.ts, 13, 1))
>T : Symbol(T, Decl(objectSpreadUnion.ts, 14, 29))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 14, 31))
>V : Symbol(V, Decl(objectSpreadUnion.ts, 14, 34))
>t : Symbol(t, Decl(objectSpreadUnion.ts, 14, 38))
>T : Symbol(T, Decl(objectSpreadUnion.ts, 14, 29))
>u : Symbol(u, Decl(objectSpreadUnion.ts, 14, 43))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 14, 31))
>v : Symbol(v, Decl(objectSpreadUnion.ts, 14, 49))
>V : Symbol(V, Decl(objectSpreadUnion.ts, 14, 34))

    let tu: T | U;
>tu : Symbol(tu, Decl(objectSpreadUnion.ts, 15, 7))
>T : Symbol(T, Decl(objectSpreadUnion.ts, 14, 29))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 14, 31))

    let uv: U | V;
>uv : Symbol(uv, Decl(objectSpreadUnion.ts, 16, 7))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 14, 31))
>V : Symbol(V, Decl(objectSpreadUnion.ts, 14, 34))

    let result = { ...tu, ...uv, id: 'bar' };
>result : Symbol(result, Decl(objectSpreadUnion.ts, 17, 7))
>tu : Symbol(tu, Decl(objectSpreadUnion.ts, 15, 7))
>uv : Symbol(uv, Decl(objectSpreadUnion.ts, 16, 7))
>id : Symbol(id, Decl(objectSpreadUnion.ts, 17, 32))

    let expected: spread(spread(T, U), { id: string }) | spread(spread(T, V), { id: string }) | spread(U, { id: string }) | spread(spread(U, V), { id: string });
>expected : Symbol(expected, Decl(objectSpreadUnion.ts, 18, 7))
>T : Symbol(T, Decl(objectSpreadUnion.ts, 14, 29))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 14, 31))
>id : Symbol(id, Decl(objectSpreadUnion.ts, 18, 40))
>T : Symbol(T, Decl(objectSpreadUnion.ts, 14, 29))
>V : Symbol(V, Decl(objectSpreadUnion.ts, 14, 34))
>id : Symbol(id, Decl(objectSpreadUnion.ts, 18, 79))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 14, 31))
>id : Symbol(id, Decl(objectSpreadUnion.ts, 18, 107))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 14, 31))
>V : Symbol(V, Decl(objectSpreadUnion.ts, 14, 34))
>id : Symbol(id, Decl(objectSpreadUnion.ts, 18, 146))

    let assignable: spread(spread(T | U, U | V), { id: string }) = result;
>assignable : Symbol(assignable, Decl(objectSpreadUnion.ts, 19, 7))
>T : Symbol(T, Decl(objectSpreadUnion.ts, 14, 29))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 14, 31))
>U : Symbol(U, Decl(objectSpreadUnion.ts, 14, 31))
>V : Symbol(V, Decl(objectSpreadUnion.ts, 14, 34))
>id : Symbol(id, Decl(objectSpreadUnion.ts, 19, 50))
>result : Symbol(result, Decl(objectSpreadUnion.ts, 17, 7))
}

