//// [tests/cases/compiler/isolatedDeclarationBinderConditionalTypes.ts] ////

=== isolatedDeclarationBinderConditionalTypes.ts ===
type TA = string;
>TA : string

type UA = string;
>UA : string

export type Conditional<UA> = UA extends infer TA ? TA: never;
>Conditional : Conditional<UA>


type TF = string;
>TF : string

type UF = string;
>UF : string

export function test<UF>(o: UF extends infer TF ? TF: never): UF extends infer TF ? TF: never {
>test : <UF>(o: UF extends infer TF ? TF : never) => UF extends infer TF_1 ? TF_1 : never
>o : UF extends infer TF ? TF : never

    return null!
>null! : null
}

type TC = string;
>TC : string

type UC = string;
>UC : string

export class C<UC> {
>C : C<UC>

    member!: UC extends infer TC ? TC: never
>member : UC extends infer TC ? TC : never

    get accessor(): UC extends infer TC ? TC: never {
>accessor : UC extends infer TC ? TC : never

        return null!
>null! : null
    }
    set accessor(value: UC extends infer TC ? TC: never) {
>accessor : UC extends infer TC ? TC : never
>value : UC extends infer TC ? TC : never
        
    }
    constructor(p: UC extends infer TC ? TC: never) {
>p : UC extends infer TC ? TC : never

        return null!;
>null! : null
    }
    method(p: UC extends infer TC ? TC: never): UC extends infer TC ? TC: never {
>method : (p: UC extends infer TC ? TC : never) => UC extends infer TC_1 ? TC_1 : never
>p : UC extends infer TC ? TC : never

        return null!;
>null! : null
    }
}

type TI = string;
>TI : string

type UI = string;
>UI : string

export interface I<UI> {
    member: UI extends infer TI ? TI: never
>member : UI extends infer TI ? TI : never

    method(p: UI extends infer TI ? TI: never): UI extends infer TI ? TI: never;
>method : (p: UI extends infer TI ? TI : never) => UI extends infer TI_1 ? TI_1 : never
>p : UI extends infer TI ? TI : never

    new (p: UI extends infer TI ? TI: never): UI extends infer TI ? TI: never;
>p : UI extends infer TI ? TI : never
}



type T2 = {}
>T2 : {}

export type Prepend<Elm, T extends unknown[]> =
>Prepend : Prepend<Elm, T>

  T extends unknown ?
  ((arg: Elm, ...rest: T) => void) extends ((...args: infer T2) => void) ? T2 :
>arg : Elm
>rest : T
>args : T2

  never :
  never;
