=== tests/cases/compiler/declarationsWithRecursiveInternalTypesProduceUniqueTypeParams.ts ===
// Note that both of the following have an `any` in their return type from where we bottom out the type printout
// for havign too many instances of the same symbol nesting.

// Slightly simplified repro from https://github.com/microsoft/TypeScript/issues/30732 so it's easier to read and debug
export type Key<U> = keyof U;
>Key : keyof U

export type Value<K extends Key<U>, U> = U[K];
>Value : U[K]

export const updateIfChanged = <T>(t: T) => {
>updateIfChanged : <T>(t: T) => (<K extends keyof T>(key: K) => (<K extends keyof T[K]>(key: K) => (<K extends keyof T[K][K]>(key: K) => (<K extends keyof T[K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K][K][K][K][K]>(key: K) => any & { map: (updater: (u: T[K][K][K][K][K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K]) => T[K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K]) => T[K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K]) => T[K][K][K][K]) => T; set: (newU: T[K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K]) => T[K][K][K]) => T; set: (newU: T[K][K][K]) => T; }) & { map: (updater: (u: T[K][K]) => T[K][K]) => T; set: (newU: T[K][K]) => T; }) & { map: (updater: (u: T[K]) => T[K]) => T; set: (newU: T[K]) => T; }) & { map: (updater: (u: T) => T) => T; set: (newU: T) => T; }
><T>(t: T) => {    const reduce = <U>(u: U, update: (u: U) => T) => {        const set = (newU: U) => Object.is(u, newU) ? t : update(newU);        return Object.assign(            <K extends Key<U>>(key: K) =>                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }),            { map: (updater: (u: U) => U) => set(updater(u)), set });    };    return reduce<T>(t, (t: T) => t);} : <T>(t: T) => (<K extends keyof T>(key: K) => (<K extends keyof T[K]>(key: K) => (<K extends keyof T[K][K]>(key: K) => (<K extends keyof T[K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K][K][K][K][K]>(key: K) => any & { map: (updater: (u: T[K][K][K][K][K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K]) => T[K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K]) => T[K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K]) => T[K][K][K][K]) => T; set: (newU: T[K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K]) => T[K][K][K]) => T; set: (newU: T[K][K][K]) => T; }) & { map: (updater: (u: T[K][K]) => T[K][K]) => T; set: (newU: T[K][K]) => T; }) & { map: (updater: (u: T[K]) => T[K]) => T; set: (newU: T[K]) => T; }) & { map: (updater: (u: T) => T) => T; set: (newU: T) => T; }
>t : T

    const reduce = <U>(u: U, update: (u: U) => T) => {
>reduce : <U>(u: U, update: (u: U) => T) => (<K extends keyof U>(key: K) => (<K extends keyof U[K]>(key: K) => (<K extends keyof U[K][K]>(key: K) => (<K extends keyof U[K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K][K]>(key: K) => any & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K]) => U[K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K]) => U[K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K]) => U[K][K][K][K]) => T; set: (newU: U[K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K]) => U[K][K][K]) => T; set: (newU: U[K][K][K]) => T; }) & { map: (updater: (u: U[K][K]) => U[K][K]) => T; set: (newU: U[K][K]) => T; }) & { map: (updater: (u: U[K]) => U[K]) => T; set: (newU: U[K]) => T; }) & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
><U>(u: U, update: (u: U) => T) => {        const set = (newU: U) => Object.is(u, newU) ? t : update(newU);        return Object.assign(            <K extends Key<U>>(key: K) =>                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }),            { map: (updater: (u: U) => U) => set(updater(u)), set });    } : <U>(u: U, update: (u: U) => T) => (<K extends keyof U>(key: K) => (<K extends keyof U[K]>(key: K) => (<K extends keyof U[K][K]>(key: K) => (<K extends keyof U[K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K][K]>(key: K) => any & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K]) => U[K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K]) => U[K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K]) => U[K][K][K][K]) => T; set: (newU: U[K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K]) => U[K][K][K]) => T; set: (newU: U[K][K][K]) => T; }) & { map: (updater: (u: U[K][K]) => U[K][K]) => T; set: (newU: U[K][K]) => T; }) & { map: (updater: (u: U[K]) => U[K]) => T; set: (newU: U[K]) => T; }) & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
>u : U
>update : (u: U) => T
>u : U

        const set = (newU: U) => Object.is(u, newU) ? t : update(newU);
>set : (newU: U) => T
>(newU: U) => Object.is(u, newU) ? t : update(newU) : (newU: U) => T
>newU : U
>Object.is(u, newU) ? t : update(newU) : T
>Object.is(u, newU) : boolean
>Object.is : (value1: any, value2: any) => boolean
>Object : ObjectConstructor
>is : (value1: any, value2: any) => boolean
>u : U
>newU : U
>t : T
>update(newU) : T
>update : (u: U) => T
>newU : U

        return Object.assign(
>Object.assign(            <K extends Key<U>>(key: K) =>                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }),            { map: (updater: (u: U) => U) => set(updater(u)), set }) : (<K extends keyof U>(key: K) => (<K extends keyof U[K]>(key: K) => (<K extends keyof U[K][K]>(key: K) => (<K extends keyof U[K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K][K]>(key: K) => any & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K]) => U[K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K]) => U[K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K]) => U[K][K][K][K]) => T; set: (newU: U[K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K]) => U[K][K][K]) => T; set: (newU: U[K][K][K]) => T; }) & { map: (updater: (u: U[K][K]) => U[K][K]) => T; set: (newU: U[K][K]) => T; }) & { map: (updater: (u: U[K]) => U[K]) => T; set: (newU: U[K]) => T; }) & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
>Object.assign : { <T, U>(target: T, source: U): T & U; <T, U, V>(target: T, source1: U, source2: V): T & U & V; <T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W; (target: object, ...sources: any[]): any; }
>Object : ObjectConstructor
>assign : { <T, U>(target: T, source: U): T & U; <T, U, V>(target: T, source1: U, source2: V): T & U & V; <T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W; (target: object, ...sources: any[]): any; }

            <K extends Key<U>>(key: K) =>
><K extends Key<U>>(key: K) =>                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }) : <K extends keyof U>(key: K) => (<K extends keyof U[K]>(key: K) => (<K extends keyof U[K][K]>(key: K) => (<K extends keyof U[K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K][K]>(key: K) => any & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K]) => U[K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K]) => U[K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K]) => U[K][K][K][K]) => T; set: (newU: U[K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K]) => U[K][K][K]) => T; set: (newU: U[K][K][K]) => T; }) & { map: (updater: (u: U[K][K]) => U[K][K]) => T; set: (newU: U[K][K]) => T; }) & { map: (updater: (u: U[K]) => U[K]) => T; set: (newU: U[K]) => T; }
>key : K

                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {
>reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }) : (<K extends keyof U[K]>(key: K) => (<K extends keyof U[K][K]>(key: K) => (<K extends keyof U[K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K][K][K]>(key: K) => any & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K]) => U[K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K]) => U[K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K]) => U[K][K][K][K]) => T; set: (newU: U[K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K]) => U[K][K][K]) => T; set: (newU: U[K][K][K]) => T; }) & { map: (updater: (u: U[K][K]) => U[K][K]) => T; set: (newU: U[K][K]) => T; }) & { map: (updater: (u: U[K]) => U[K]) => T; set: (newU: U[K]) => T; }
>reduce : <U>(u: U, update: (u: U) => T) => (<K extends keyof U>(key: K) => (<K extends keyof U[K]>(key: K) => (<K extends keyof U[K][K]>(key: K) => (<K extends keyof U[K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K][K]>(key: K) => any & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K]) => U[K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K]) => U[K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K]) => U[K][K][K][K]) => T; set: (newU: U[K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K]) => U[K][K][K]) => T; set: (newU: U[K][K][K]) => T; }) & { map: (updater: (u: U[K][K]) => U[K][K]) => T; set: (newU: U[K][K]) => T; }) & { map: (updater: (u: U[K]) => U[K]) => T; set: (newU: U[K]) => T; }) & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
>u[key as keyof U] as Value<K, U> : U[K]
>u[key as keyof U] : U[keyof U]
>u : U
>key as keyof U : keyof U
>key : K
>(v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                } : (v: U[K]) => T
>v : U[K]

                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));
>update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v })) : T
>update : (u: U) => T
>Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }) : U & { [x: string]: U[K]; }
>Object.assign : { <T, U>(target: T, source: U): T & U; <T, U, V>(target: T, source1: U, source2: V): T & U & V; <T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W; (target: object, ...sources: any[]): any; }
>Object : ObjectConstructor
>assign : { <T, U>(target: T, source: U): T & U; <T, U, V>(target: T, source1: U, source2: V): T & U & V; <T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W; (target: object, ...sources: any[]): any; }
>Array.isArray(u) ? [] : {} : undefined[] | {}
>Array.isArray(u) : boolean
>Array.isArray : (arg: any) => arg is any[]
>Array : ArrayConstructor
>isArray : (arg: any) => arg is any[]
>u : U
>[] : undefined[]
>{} : {}
>u : U
>{ [key]: v } : { [x: string]: U[K]; }
>[key] : U[K]
>key : K
>v : U[K]

                }),
            { map: (updater: (u: U) => U) => set(updater(u)), set });
>{ map: (updater: (u: U) => U) => set(updater(u)), set } : { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
>map : (updater: (u: U) => U) => T
>(updater: (u: U) => U) => set(updater(u)) : (updater: (u: U) => U) => T
>updater : (u: U) => U
>u : U
>set(updater(u)) : T
>set : (newU: U) => T
>updater(u) : U
>updater : (u: U) => U
>u : U
>set : (newU: U) => T

    };
    return reduce<T>(t, (t: T) => t);
>reduce<T>(t, (t: T) => t) : (<K extends keyof T>(key: K) => (<K extends keyof T[K]>(key: K) => (<K extends keyof T[K][K]>(key: K) => (<K extends keyof T[K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof T[K][K][K][K][K][K][K][K][K][K]>(key: K) => any & { map: (updater: (u: T[K][K][K][K][K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K][K]) => T[K][K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K][K]) => T[K][K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K][K]) => T[K][K][K][K][K]) => T; set: (newU: T[K][K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K][K]) => T[K][K][K][K]) => T; set: (newU: T[K][K][K][K]) => T; }) & { map: (updater: (u: T[K][K][K]) => T[K][K][K]) => T; set: (newU: T[K][K][K]) => T; }) & { map: (updater: (u: T[K][K]) => T[K][K]) => T; set: (newU: T[K][K]) => T; }) & { map: (updater: (u: T[K]) => T[K]) => T; set: (newU: T[K]) => T; }) & { map: (updater: (u: T) => T) => T; set: (newU: T) => T; }
>reduce : <U>(u: U, update: (u: U) => T) => (<K extends keyof U>(key: K) => (<K extends keyof U[K]>(key: K) => (<K extends keyof U[K][K]>(key: K) => (<K extends keyof U[K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K]>(key: K) => (<K extends keyof U[K][K][K][K][K][K][K][K][K][K]>(key: K) => any & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K][K]) => U[K][K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K][K]) => U[K][K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K][K]) => U[K][K][K][K][K]) => T; set: (newU: U[K][K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K][K]) => U[K][K][K][K]) => T; set: (newU: U[K][K][K][K]) => T; }) & { map: (updater: (u: U[K][K][K]) => U[K][K][K]) => T; set: (newU: U[K][K][K]) => T; }) & { map: (updater: (u: U[K][K]) => U[K][K]) => T; set: (newU: U[K][K]) => T; }) & { map: (updater: (u: U[K]) => U[K]) => T; set: (newU: U[K]) => T; }) & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
>t : T
>(t: T) => t : (t: T) => T
>t : T
>t : T

};

