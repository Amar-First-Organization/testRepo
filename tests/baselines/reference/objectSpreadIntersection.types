=== tests/cases/conformance/types/spread/objectSpreadIntersection.ts ===
function iteratedUnionIntersection<T, U, V>(t: T, u: U, v: V): void {
>iteratedUnionIntersection : <T, U, V>(t: T, u: U, v: V) => void
>T : T
>U : U
>V : V
>t : T
>T : T
>u : U
>U : U
>v : V
>V : V

    let tu: T | U;
>tu : T | U
>T : T
>U : U

    let uv: U & V;
>uv : U & V
>U : U
>V : V

    let result = { ...tu, ...uv, id: 'foo' };
>result : spread(spread(T, U & V), { id: string; }) | spread(spread(U, U & V), { id: string; })
>{ ...tu, ...uv, id: 'foo' } : spread(spread(T, U & V), { id: string; }) | spread(spread(U, U & V), { id: string; })
>tu : T | U
>uv : U & V
>id : string
>'foo' : "foo"

    let assignable: spread(spread(T | U, U & V), { id: string }) = result;
>assignable : spread(spread(T, U & V), { id: string; }) | spread(spread(U, U & V), { id: string; })
>T : T
>U : U
>U : U
>V : V
>id : string
>result : spread(spread(T, U & V), { id: string; }) | spread(spread(U, U & V), { id: string; })
}
// concrete types work
interface A1 { a: number }
>A1 : A1
>a : number

interface A2 { a: string }
>A2 : A2
>a : string

interface B1 { b: number }
>B1 : B1
>b : number

interface B2 { b: string }
>B2 : B2
>b : string

let a12: A1 & A2;
>a12 : A1 & A2
>A1 : A1
>A2 : A2

let b12: B1 & B2;
>b12 : B1 & B2
>B1 : B1
>B2 : B2

let result = { ...a12, ...b12 };
>result : { b: number & string; a: number & string; }
>{ ...a12, ...b12 } : { b: number & string; a: number & string; }
>a12 : A1 & A2
>b12 : B1 & B2

let sn: number & string = result.a;
>sn : number & string
>result.a : number & string
>result : { b: number & string; a: number & string; }
>a : number & string

sn = result.b;
>sn = result.b : number & string
>sn : number & string
>result.b : number & string
>result : { b: number & string; a: number & string; }
>b : number & string

let assignable: spread(A1 & A2, B1 & B2) = result;
>assignable : { b: number & string; a: number & string; }
>A1 : A1
>A2 : A2
>B1 : B1
>B2 : B2
>result : { b: number & string; a: number & string; }

function tripleIntersection<T, U, V>(t: T, u: U, v: V): void {
>tripleIntersection : <T, U, V>(t: T, u: U, v: V) => void
>T : T
>U : U
>V : V
>t : T
>T : T
>u : U
>U : U
>v : V
>V : V

    let tuv: T & U & V;
>tuv : T & U & V
>T : T
>U : U
>V : V

    let result = { ...tuv, id: 'bar' };
>result : spread(T & U & V, { id: string; })
>{ ...tuv, id: 'bar' } : spread(T & U & V, { id: string; })
>tuv : T & U & V
>id : string
>'bar' : "bar"

    let assignable: spread(T & U & V, { id: string }) = result;
>assignable : spread(T & U & V, { id: string; })
>T : T
>U : U
>V : V
>id : string
>result : spread(T & U & V, { id: string; })
}
function iteratedDoubleIntersection<T, U, V>(t: T, u: U, v: V): void {
>iteratedDoubleIntersection : <T, U, V>(t: T, u: U, v: V) => void
>T : T
>U : U
>V : V
>t : T
>T : T
>u : U
>U : U
>v : V
>V : V

    let tu: T & U;
>tu : T & U
>T : T
>U : U

    let uv: U & V;
>uv : U & V
>U : U
>V : V

    let result = { ...tu, ...uv, id: 'baz' };
>result : spread(spread(T & U, U & V), { id: string; })
>{ ...tu, ...uv, id: 'baz' } : spread(spread(T & U, U & V), { id: string; })
>tu : T & U
>uv : U & V
>id : string
>'baz' : "baz"

    let assignable: spread(spread(T & U, U & V), { id: string }) = result;
>assignable : spread(spread(T & U, U & V), { id: string; })
>T : T
>U : U
>U : U
>V : V
>id : string
>result : spread(spread(T & U, U & V), { id: string; })
}
function iteratedIntersectionUnion<T, U, V>(t: T, u: U, v: V): void {
>iteratedIntersectionUnion : <T, U, V>(t: T, u: U, v: V) => void
>T : T
>U : U
>V : V
>t : T
>T : T
>u : U
>U : U
>v : V
>V : V

    let tu: T & U;
>tu : T & U
>T : T
>U : U

    let uv: U | V;
>uv : U | V
>U : U
>V : V

    let result = { ...tu, ...uv, id: 'qux' };
>result : spread(spread(T & U, U), { id: string; }) | spread(spread(T & U, V), { id: string; })
>{ ...tu, ...uv, id: 'qux' } : spread(spread(T & U, U), { id: string; }) | spread(spread(T & U, V), { id: string; })
>tu : T & U
>uv : U | V
>id : string
>'qux' : "qux"

    let assignable: spread(spread(T & U, U | V), { id: string }) = result;
>assignable : spread(spread(T & U, U), { id: string; }) | spread(spread(T & U, V), { id: string; })
>T : T
>U : U
>U : U
>V : V
>id : string
>result : spread(spread(T & U, U), { id: string; }) | spread(spread(T & U, V), { id: string; })
}

