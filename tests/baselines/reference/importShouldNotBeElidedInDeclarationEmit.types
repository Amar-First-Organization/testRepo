=== tests/cases/compiler/node_modules/reselect.d.ts ===
export as namespace Reselect;
>Reselect : typeof "tests/cases/compiler/node_modules/reselect"

export type Selector<S, R> = (state: S) => R;
>Selector : Selector<S, R>
>S : S
>R : R
>state : S
>S : S
>R : R

export type OutputSelector<S, R, C> = Selector<S, R> & {
>OutputSelector : OutputSelector<S, R, C>
>S : S
>R : R
>C : C
>Selector : Selector<S, R>
>S : S
>R : R

  resultFunc: C;
>resultFunc : C
>C : C

  recomputations: () => number;
>recomputations : () => number

  resetRecomputations: () => number;
>resetRecomputations : () => number

};

export type ParametricSelector<S, P, R> = (state: S, props: P, ...args: any[]) => R;
>ParametricSelector : ParametricSelector<S, P, R>
>S : S
>P : P
>R : R
>state : S
>S : S
>props : P
>P : P
>args : any[]
>R : R

export type OutputParametricSelector<S, P, R, C> = ParametricSelector<S, P, R> & {
>OutputParametricSelector : OutputParametricSelector<S, P, R, C>
>S : S
>P : P
>R : R
>C : C
>ParametricSelector : ParametricSelector<S, P, R>
>S : S
>P : P
>R : R

  resultFunc: C;
>resultFunc : C
>C : C

  recomputations: () => number;
>recomputations : () => number

  resetRecomputations: () => number;
>resetRecomputations : () => number

};

/* one selector */
export function createSelector<S, R1, T>(
>createSelector : { <S, R1, T>(selector: Selector<S, R1>, combiner: (res: R1) => T): OutputSelector<S, T, (res: R1) => T>; <S, P, R1, T>(selector: ParametricSelector<S, P, R1>, combiner: (res: R1) => T): OutputParametricSelector<S, P, T, (res: R1) => T>; <S, R1, R2, T>(selector1: Selector<S, R1>, selector2: Selector<S, R2>, combiner: (res1: R1, res2: R2) => T): OutputSelector<S, T, (res1: R1, res2: R2) => T>; <S, P, R1, R2, T>(selector1: ParametricSelector<S, P, R1>, selector2: ParametricSelector<S, P, R2>, combiner: (res1: R1, res2: R2) => T): OutputParametricSelector<S, P, T, (res1: R1, res2: R2) => T>; }
>S : S
>R1 : R1
>T : T

    selector: Selector<S, R1>,
>selector : Selector<S, R1>
>Selector : Selector<S, R>
>S : S
>R1 : R1

    combiner: (res: R1) => T,
>combiner : (res: R1) => T
>res : R1
>R1 : R1
>T : T

): OutputSelector<S, T, (res: R1) => T>;
>OutputSelector : OutputSelector<S, R, C>
>S : S
>T : T
>res : R1
>R1 : R1
>T : T

export function createSelector<S, P, R1, T>(
>createSelector : { <S, R1, T>(selector: Selector<S, R1>, combiner: (res: R1) => T): OutputSelector<S, T, (res: R1) => T>; <S, P, R1, T>(selector: ParametricSelector<S, P, R1>, combiner: (res: R1) => T): OutputParametricSelector<S, P, T, (res: R1) => T>; <S, R1, R2, T>(selector1: Selector<S, R1>, selector2: Selector<S, R2>, combiner: (res1: R1, res2: R2) => T): OutputSelector<S, T, (res1: R1, res2: R2) => T>; <S, P, R1, R2, T>(selector1: ParametricSelector<S, P, R1>, selector2: ParametricSelector<S, P, R2>, combiner: (res1: R1, res2: R2) => T): OutputParametricSelector<S, P, T, (res1: R1, res2: R2) => T>; }
>S : S
>P : P
>R1 : R1
>T : T

    selector: ParametricSelector<S, P, R1>,
>selector : ParametricSelector<S, P, R1>
>ParametricSelector : ParametricSelector<S, P, R>
>S : S
>P : P
>R1 : R1

    combiner: (res: R1) => T,
>combiner : (res: R1) => T
>res : R1
>R1 : R1
>T : T

): OutputParametricSelector<S, P, T, (res: R1) => T>;
>OutputParametricSelector : OutputParametricSelector<S, P, R, C>
>S : S
>P : P
>T : T
>res : R1
>R1 : R1
>T : T

/* two selectors */
export function createSelector<S, R1, R2, T>(
>createSelector : { <S, R1, T>(selector: Selector<S, R1>, combiner: (res: R1) => T): OutputSelector<S, T, (res: R1) => T>; <S, P, R1, T>(selector: ParametricSelector<S, P, R1>, combiner: (res: R1) => T): OutputParametricSelector<S, P, T, (res: R1) => T>; <S, R1, R2, T>(selector1: Selector<S, R1>, selector2: Selector<S, R2>, combiner: (res1: R1, res2: R2) => T): OutputSelector<S, T, (res1: R1, res2: R2) => T>; <S, P, R1, R2, T>(selector1: ParametricSelector<S, P, R1>, selector2: ParametricSelector<S, P, R2>, combiner: (res1: R1, res2: R2) => T): OutputParametricSelector<S, P, T, (res1: R1, res2: R2) => T>; }
>S : S
>R1 : R1
>R2 : R2
>T : T

    selector1: Selector<S, R1>,
>selector1 : Selector<S, R1>
>Selector : Selector<S, R>
>S : S
>R1 : R1

    selector2: Selector<S, R2>,
>selector2 : Selector<S, R2>
>Selector : Selector<S, R>
>S : S
>R2 : R2

    combiner: (res1: R1, res2: R2) => T,
>combiner : (res1: R1, res2: R2) => T
>res1 : R1
>R1 : R1
>res2 : R2
>R2 : R2
>T : T

): OutputSelector<S, T, (res1: R1, res2: R2) => T>;
>OutputSelector : OutputSelector<S, R, C>
>S : S
>T : T
>res1 : R1
>R1 : R1
>res2 : R2
>R2 : R2
>T : T

export function createSelector<S, P, R1, R2, T>(
>createSelector : { <S, R1, T>(selector: Selector<S, R1>, combiner: (res: R1) => T): OutputSelector<S, T, (res: R1) => T>; <S, P, R1, T>(selector: ParametricSelector<S, P, R1>, combiner: (res: R1) => T): OutputParametricSelector<S, P, T, (res: R1) => T>; <S, R1, R2, T>(selector1: Selector<S, R1>, selector2: Selector<S, R2>, combiner: (res1: R1, res2: R2) => T): OutputSelector<S, T, (res1: R1, res2: R2) => T>; <S, P, R1, R2, T>(selector1: ParametricSelector<S, P, R1>, selector2: ParametricSelector<S, P, R2>, combiner: (res1: R1, res2: R2) => T): OutputParametricSelector<S, P, T, (res1: R1, res2: R2) => T>; }
>S : S
>P : P
>R1 : R1
>R2 : R2
>T : T

    selector1: ParametricSelector<S, P, R1>,
>selector1 : ParametricSelector<S, P, R1>
>ParametricSelector : ParametricSelector<S, P, R>
>S : S
>P : P
>R1 : R1

    selector2: ParametricSelector<S, P, R2>,
>selector2 : ParametricSelector<S, P, R2>
>ParametricSelector : ParametricSelector<S, P, R>
>S : S
>P : P
>R2 : R2

    combiner: (res1: R1, res2: R2) => T,
>combiner : (res1: R1, res2: R2) => T
>res1 : R1
>R1 : R1
>res2 : R2
>R2 : R2
>T : T

): OutputParametricSelector<S, P, T, (res1: R1, res2: R2) => T>;
>OutputParametricSelector : OutputParametricSelector<S, P, R, C>
>S : S
>P : P
>T : T
>res1 : R1
>R1 : R1
>res2 : R2
>R2 : R2
>T : T

=== tests/cases/compiler/index.ts ===
import { createSelector } from "reselect";
>createSelector : { <S, R1, T>(selector: (state: S) => R1, combiner: (res: R1) => T): ((state: S) => T) & { resultFunc: (res: R1) => T; recomputations: () => number; resetRecomputations: () => number; }; <S, P, R1, T>(selector: (state: S, props: P, ...args: any[]) => R1, combiner: (res: R1) => T): ((state: S, props: P, ...args: any[]) => T) & { resultFunc: (res: R1) => T; recomputations: () => number; resetRecomputations: () => number; }; <S, R1, R2, T>(selector1: (state: S) => R1, selector2: (state: S) => R2, combiner: (res1: R1, res2: R2) => T): ((state: S) => T) & { resultFunc: (res1: R1, res2: R2) => T; recomputations: () => number; resetRecomputations: () => number; }; <S, P, R1, R2, T>(selector1: (state: S, props: P, ...args: any[]) => R1, selector2: (state: S, props: P, ...args: any[]) => R2, combiner: (res1: R1, res2: R2) => T): ((state: S, props: P, ...args: any[]) => T) & { resultFunc: (res1: R1, res2: R2) => T; recomputations: () => number; resetRecomputations: () => number; }; }

/*
 * changing the import to
 * import * as reselect from 'reselect';
 * and accessing reselect.createSelector fixes the issue
*/
export interface State {
>State : State

    a: string;
>a : string

    b: number;
>b : number
}
export const selector = createSelector<State, string, number, { out: string }>(
>selector : ((state: State) => { out: string; }) & { resultFunc: (res1: string, res2: number) => { out: string; }; recomputations: () => number; resetRecomputations: () => number; }
>createSelector<State, string, number, { out: string }>(    state => state.a,    state => state.b,    (a, b) => {        return {            out: `${a}+${b}`        };    }) : ((state: State) => { out: string; }) & { resultFunc: (res1: string, res2: number) => { out: string; }; recomputations: () => number; resetRecomputations: () => number; }
>createSelector : { <S, R1, T>(selector: (state: S) => R1, combiner: (res: R1) => T): ((state: S) => T) & { resultFunc: (res: R1) => T; recomputations: () => number; resetRecomputations: () => number; }; <S, P, R1, T>(selector: (state: S, props: P, ...args: any[]) => R1, combiner: (res: R1) => T): ((state: S, props: P, ...args: any[]) => T) & { resultFunc: (res: R1) => T; recomputations: () => number; resetRecomputations: () => number; }; <S, R1, R2, T>(selector1: (state: S) => R1, selector2: (state: S) => R2, combiner: (res1: R1, res2: R2) => T): ((state: S) => T) & { resultFunc: (res1: R1, res2: R2) => T; recomputations: () => number; resetRecomputations: () => number; }; <S, P, R1, R2, T>(selector1: (state: S, props: P, ...args: any[]) => R1, selector2: (state: S, props: P, ...args: any[]) => R2, combiner: (res1: R1, res2: R2) => T): ((state: S, props: P, ...args: any[]) => T) & { resultFunc: (res1: R1, res2: R2) => T; recomputations: () => number; resetRecomputations: () => number; }; }
>State : State
>out : string

    state => state.a,
>state => state.a : (state: State) => string
>state : State
>state.a : string
>state : State
>a : string

    state => state.b,
>state => state.b : (state: State) => number
>state : State
>state.b : number
>state : State
>b : number

    (a, b) => {
>(a, b) => {        return {            out: `${a}+${b}`        };    } : (a: string, b: number) => { out: string; }
>a : string
>b : number

        return {
>{            out: `${a}+${b}`        } : { out: string; }

            out: `${a}+${b}`
>out : string
>`${a}+${b}` : string
>a : string
>b : number

        };
    }
);
selector({ a: "string", b: 5 });
>selector({ a: "string", b: 5 }) : { out: string; }
>selector : ((state: State) => { out: string; }) & { resultFunc: (res1: string, res2: number) => { out: string; }; recomputations: () => number; resetRecomputations: () => number; }
>{ a: "string", b: 5 } : { a: string; b: number; }
>a : string
>"string" : "string"
>b : number
>5 : 5

