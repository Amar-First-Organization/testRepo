=== tests/cases/compiler/inDoesNotOperateOnPrimitiveTypes.ts ===
const validHasKey = <T extends object>(
>validHasKey : <T extends object>(thing: T, key: string) => boolean
><T extends object>(  thing: T,  key: string,): boolean => {  return key in thing;} : <T extends object>(thing: T, key: string) => boolean

  thing: T,
>thing : T

  key: string,
>key : string

): boolean => {
  return key in thing;
>key in thing : boolean
>key : string
>thing : T

};

const alsoValidHasKey = <T>(
>alsoValidHasKey : <T>(thing: T, key: string) => boolean
><T>(  thing: T,  key: string,): boolean => {  return key in thing;} : <T>(thing: T, key: string) => boolean

  thing: T,
>thing : T

  key: string,
>key : string

): boolean => {
  return key in thing;
>key in thing : boolean
>key : string
>thing : T

};

function invalidHasKey<T extends string | number>(
>invalidHasKey : <T extends string | number>(thing: T, key: string) => boolean

  thing: T,
>thing : T

  key: string,
>key : string

): boolean {
  return key in thing;
>key in thing : boolean
>key : string
>thing : T
}

function union1<T extends string | number, U extends boolean>(thing: T | U) {
>union1 : <T extends string | number, U extends boolean>(thing: T | U) => void
>thing : T | U

  "key" in thing; // Error (because all possible instantiations are errors)
>"key" in thing : boolean
>"key" : "key"
>thing : T | U
}

function union2<T extends object, U extends string | number>(thing: T | U) {
>union2 : <T extends object, U extends string | number>(thing: T | U) => void
>thing : T | U

  "key" in thing; // Error (because narrowing is possible)
>"key" in thing : boolean
>"key" : "key"
>thing : T | U

  if (typeof thing === "object") {
>typeof thing === "object" : boolean
>typeof thing : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>thing : T | U
>"object" : "object"

    "key" in thing; // Ok
>"key" in thing : boolean
>"key" : "key"
>thing : T
  }
}

function union3<T>(thing: T | string | number) {
>union3 : <T>(thing: T | string | number) => void
>thing : string | number | T

  "key" in thing; // Error (because narrowing is possible)
>"key" in thing : boolean
>"key" : "key"
>thing : string | number | T

  if (typeof thing !== "string" && typeof thing !== "number") {
>typeof thing !== "string" && typeof thing !== "number" : boolean
>typeof thing !== "string" : boolean
>typeof thing : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>thing : string | number | T
>"string" : "string"
>typeof thing !== "number" : boolean
>typeof thing : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>thing : number | T
>"number" : "number"

    "key" in thing; // Ok, because further narrowing is impossible
>"key" in thing : boolean
>"key" : "key"
>thing : T
  }
}

function union4<T extends object | "hello">(thing: T) {
>union4 : <T extends object | "hello">(thing: T) => void
>thing : T

  "key" in thing; // Error (because union includes string literal)
>"key" in thing : boolean
>"key" : "key"
>thing : T
}

function union5<T extends object | string>(thing: T) {
>union5 : <T extends string | object>(thing: T) => void
>thing : T

  "key" in thing; // Error (because union includes string)
>"key" in thing : boolean
>"key" : "key"
>thing : T
}

function intersection1<T extends number, U extends 0 | 1 | 2>(thing: T & U) {
>intersection1 : <T extends number, U extends 0 | 1 | 2>(thing: T & U) => void
>thing : T & U

  "key" in thing; // Error (because all possible instantiations are errors)
>"key" in thing : boolean
>"key" : "key"
>thing : T & U
}

function intersection2<T>(thing: T & (0 | 1 | 2)) {
>intersection2 : <T>(thing: T & (0 | 1 | 2)) => void
>thing : (T & 0) | (T & 1) | (T & 2)

  "key" in thing; // Error (because all possible instantations are errors)
>"key" in thing : boolean
>"key" : "key"
>thing : (T & 0) | (T & 1) | (T & 2)
}

