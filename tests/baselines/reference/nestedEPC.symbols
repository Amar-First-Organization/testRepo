=== tests/cases/compiler/nestedEPC.ts ===
interface IProps {
>IProps : Symbol(IProps, Decl(nestedEPC.ts, 0, 0))

  iconProp?: string;
>iconProp : Symbol(IProps.iconProp, Decl(nestedEPC.ts, 0, 18))

  nestedProp?: {
>nestedProp : Symbol(IProps.nestedProp, Decl(nestedEPC.ts, 1, 20))

    testBool?: boolean;
>testBool : Symbol(testBool, Decl(nestedEPC.ts, 2, 16))
  }
}
 
interface INestedProps {
>INestedProps : Symbol(INestedProps, Decl(nestedEPC.ts, 5, 1))

  nestedProps?: IProps;
>nestedProps : Symbol(INestedProps.nestedProps, Decl(nestedEPC.ts, 7, 24))
>IProps : Symbol(IProps, Decl(nestedEPC.ts, 0, 0))
}
 
// These are the types of errors we want:
const propB1: IProps | number = { INVALID_PROP_NAME: 'share', iconProp: 'test' };
>propB1 : Symbol(propB1, Decl(nestedEPC.ts, 12, 5))
>IProps : Symbol(IProps, Decl(nestedEPC.ts, 0, 0))
>INVALID_PROP_NAME : Symbol(INVALID_PROP_NAME, Decl(nestedEPC.ts, 12, 33))
>iconProp : Symbol(iconProp, Decl(nestedEPC.ts, 12, 61))
 
// Nested typing works here and we also get an expected error:
const propB2: IProps | number = { nestedProp: { asdfasdf: 'test' }, iconProp: 'test' };
>propB2 : Symbol(propB2, Decl(nestedEPC.ts, 15, 5))
>IProps : Symbol(IProps, Decl(nestedEPC.ts, 0, 0))
>nestedProp : Symbol(nestedProp, Decl(nestedEPC.ts, 15, 33))
>asdfasdf : Symbol(asdfasdf, Decl(nestedEPC.ts, 15, 47))
>iconProp : Symbol(iconProp, Decl(nestedEPC.ts, 15, 67))
 
// Want an error generated here but there isn't one.
const propA1: INestedProps | number = { nestedProps: { INVALID_PROP_NAME: 'share', iconProp: 'test' } };
>propA1 : Symbol(propA1, Decl(nestedEPC.ts, 18, 5))
>INestedProps : Symbol(INestedProps, Decl(nestedEPC.ts, 5, 1))
>nestedProps : Symbol(nestedProps, Decl(nestedEPC.ts, 18, 39))
>INVALID_PROP_NAME : Symbol(INVALID_PROP_NAME, Decl(nestedEPC.ts, 18, 54))
>iconProp : Symbol(iconProp, Decl(nestedEPC.ts, 18, 82))

