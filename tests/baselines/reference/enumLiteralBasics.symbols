//// [tests/cases/conformance/enums/enumLiteralBasics.ts] ////

=== enumLiteralBasics.ts ===
// Enum without initializers have first member = 0 and successive members = N + 1

// Enum literal syntax does not implement auto-incrementing behaviour.
let ExistingShorthand = "exists";
>ExistingShorthand : Symbol(ExistingShorthand, Decl(enumLiteralBasics.ts, 3, 3))

const E1: enum = {
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))

    NonexistingShorthand, // error -- EnumLiteralExpressions require explicit property definitions.
>NonexistingShorthand : Symbol(E1.NonexistingShorthand, Decl(enumLiteralBasics.ts, 4, 18))

    ExistingShorthand, // error -- EnumLiteralExpressions require explicit property definitions.
>ExistingShorthand : Symbol(E1.ExistingShorthand, Decl(enumLiteralBasics.ts, 5, 25))

    Int: 1, // ok
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))

    String: "string", // ok
>String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))

    Flag: 8, // ok
>Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))

};

// Valid assignments
const nonexist: E1 = E1.NonexistingShorthand; // ok
>nonexist : Symbol(nonexist, Decl(enumLiteralBasics.ts, 13, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>E1.NonexistingShorthand : Symbol(E1.NonexistingShorthand, Decl(enumLiteralBasics.ts, 4, 18))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>NonexistingShorthand : Symbol(E1.NonexistingShorthand, Decl(enumLiteralBasics.ts, 4, 18))

const exist: E1 = E1.ExistingShorthand; // ok
>exist : Symbol(exist, Decl(enumLiteralBasics.ts, 14, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>E1.ExistingShorthand : Symbol(E1.ExistingShorthand, Decl(enumLiteralBasics.ts, 5, 25))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>ExistingShorthand : Symbol(E1.ExistingShorthand, Decl(enumLiteralBasics.ts, 5, 25))

const ival: E1 = E1.Int; // ok
>ival : Symbol(ival, Decl(enumLiteralBasics.ts, 15, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>E1.Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))

const sval: E1 = E1.String; // ok
>sval : Symbol(sval, Decl(enumLiteralBasics.ts, 16, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>E1.String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))

let p_int: E1.Int = E1.Int; // ok
>p_int : Symbol(p_int, Decl(enumLiteralBasics.ts, 17, 3))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>E1.Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))

const p_nonexist: E1.NonexistingShorthand = E1.NonexistingShorthand; // ok
>p_nonexist : Symbol(p_nonexist, Decl(enumLiteralBasics.ts, 18, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>NonexistingShorthand : Symbol(E1.NonexistingShorthand, Decl(enumLiteralBasics.ts, 4, 18))
>E1.NonexistingShorthand : Symbol(E1.NonexistingShorthand, Decl(enumLiteralBasics.ts, 4, 18))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>NonexistingShorthand : Symbol(E1.NonexistingShorthand, Decl(enumLiteralBasics.ts, 4, 18))

const p_exist: E1.ExistingShorthand = E1.ExistingShorthand; // ok
>p_exist : Symbol(p_exist, Decl(enumLiteralBasics.ts, 19, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>ExistingShorthand : Symbol(E1.ExistingShorthand, Decl(enumLiteralBasics.ts, 5, 25))
>E1.ExistingShorthand : Symbol(E1.ExistingShorthand, Decl(enumLiteralBasics.ts, 5, 25))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>ExistingShorthand : Symbol(E1.ExistingShorthand, Decl(enumLiteralBasics.ts, 5, 25))

const p_string: E1.String = E1.String; // ok
>p_string : Symbol(p_string, Decl(enumLiteralBasics.ts, 20, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))
>E1.String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))

p_int = E1.Flag; // Type 'E1.Flag' is not assignable to type 'E1.Int'.
>p_int : Symbol(p_int, Decl(enumLiteralBasics.ts, 17, 3))
>E1.Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))

p_int = E1.Int | E1.Flag;
>p_int : Symbol(p_int, Decl(enumLiteralBasics.ts, 17, 3))
>E1.Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>E1.Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))

// Assigning values which are not part of the enum despite being present in the enum
const nonexist_bad: E1 = undefined; // error
>nonexist_bad : Symbol(nonexist_bad, Decl(enumLiteralBasics.ts, 25, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>undefined : Symbol(undefined)

const exist_bad: E1 = "exists"; // error
>exist_bad : Symbol(exist_bad, Decl(enumLiteralBasics.ts, 26, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))

const ival_good: E1 = 1; // ok -- TypeScript is permissive of this in enums, to permit things like bitwise combinations of enum values.
>ival_good : Symbol(ival_good, Decl(enumLiteralBasics.ts, 27, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))

const sval_bad: E1 = "string"; // error
>sval_bad : Symbol(sval_bad, Decl(enumLiteralBasics.ts, 28, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))

const ival_notpresent: E1 = 4; // ok -- TypeScript is permissive of this in enums, to permit things like bitwise combinations of enum values.
>ival_notpresent : Symbol(ival_notpresent, Decl(enumLiteralBasics.ts, 30, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))

function functest(value: E1) {
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 30, 30))
>value : Symbol(value, Decl(enumLiteralBasics.ts, 32, 18))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))

    console.log(value);
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>value : Symbol(value, Decl(enumLiteralBasics.ts, 32, 18))

    return value;
>value : Symbol(value, Decl(enumLiteralBasics.ts, 32, 18))
}

const nonexist_bad2: E1 = functest(undefined); // error
>nonexist_bad2 : Symbol(nonexist_bad2, Decl(enumLiteralBasics.ts, 37, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 30, 30))
>undefined : Symbol(undefined)

const exist_bad2: E1 = functest("exists"); // error
>exist_bad2 : Symbol(exist_bad2, Decl(enumLiteralBasics.ts, 38, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 30, 30))

const ival_good2: E1 = functest(1); // ok
>ival_good2 : Symbol(ival_good2, Decl(enumLiteralBasics.ts, 39, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 30, 30))

const ival_good3: E1 = functest(4); // ok
>ival_good3 : Symbol(ival_good3, Decl(enumLiteralBasics.ts, 40, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 30, 30))

const ival_good4: E1 = functest(E1.Int | E1.Flag); // ok
>ival_good4 : Symbol(ival_good4, Decl(enumLiteralBasics.ts, 41, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 30, 30))
>E1.Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>E1.Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))

const sval_good2: E1 = functest(E1.String);
>sval_good2 : Symbol(sval_good2, Decl(enumLiteralBasics.ts, 42, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 30, 30))
>E1.String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))

const sval_bad2: E1 = functest("string"); // error
>sval_bad2 : Symbol(sval_bad2, Decl(enumLiteralBasics.ts, 43, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 30, 30))

function functest2(value: E1.Int) {
>functest2 : Symbol(functest2, Decl(enumLiteralBasics.ts, 43, 41))
>value : Symbol(value, Decl(enumLiteralBasics.ts, 45, 19))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))

    console.log(value);
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>value : Symbol(value, Decl(enumLiteralBasics.ts, 45, 19))

    return value;
>value : Symbol(value, Decl(enumLiteralBasics.ts, 45, 19))
}

const nonexist_bad3: E1.Int = functest2(undefined);
>nonexist_bad3 : Symbol(nonexist_bad3, Decl(enumLiteralBasics.ts, 50, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>functest2 : Symbol(functest2, Decl(enumLiteralBasics.ts, 43, 41))
>undefined : Symbol(undefined)

const exist_bad3: E1.Int = functest2("exists"); // error
>exist_bad3 : Symbol(exist_bad3, Decl(enumLiteralBasics.ts, 51, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>functest2 : Symbol(functest2, Decl(enumLiteralBasics.ts, 43, 41))

const ival_good5: E1.Int = functest2(1); // ok
>ival_good5 : Symbol(ival_good5, Decl(enumLiteralBasics.ts, 52, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>functest2 : Symbol(functest2, Decl(enumLiteralBasics.ts, 43, 41))

const ival_good6: E1.Int = functest2(4); // ok
>ival_good6 : Symbol(ival_good6, Decl(enumLiteralBasics.ts, 53, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>functest2 : Symbol(functest2, Decl(enumLiteralBasics.ts, 43, 41))

const ival_good7: E1.Int = functest2(E1.Int | E1.Flag); // ok
>ival_good7 : Symbol(ival_good7, Decl(enumLiteralBasics.ts, 54, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>functest2 : Symbol(functest2, Decl(enumLiteralBasics.ts, 43, 41))
>E1.Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>E1.Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))

const sval_good3: E1.Int = functest2(E1.String);
>sval_good3 : Symbol(sval_good3, Decl(enumLiteralBasics.ts, 55, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>functest2 : Symbol(functest2, Decl(enumLiteralBasics.ts, 43, 41))
>E1.String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))

const sval_bad3: E1.Flag = functest2("string"); // error
>sval_bad3 : Symbol(sval_bad3, Decl(enumLiteralBasics.ts, 56, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 14))
>Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))
>functest2 : Symbol(functest2, Decl(enumLiteralBasics.ts, 43, 41))

