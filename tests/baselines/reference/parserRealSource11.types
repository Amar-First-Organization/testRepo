=== tests/cases/conformance/parser/ecmascript5/parserRealSource11.ts ===
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='typescript.ts' />

module TypeScript {
>TypeScript : typeof TypeScript

    export class ASTSpan {
>ASTSpan : ASTSpan

        public minChar: number = -1;  // -1 = "undefined" or "compiler generated"
>minChar : number
>-1 : -1
>1 : 1

        public limChar: number = -1;  // -1 = "undefined" or "compiler generated"   
>limChar : number
>-1 : -1
>1 : 1
    }

    export class AST extends ASTSpan {
>AST : AST
>ASTSpan : ASTSpan

        public type: Type = null;
>type : any (error)
>null : null

        public flags = ASTFlags.Writeable;
>flags : any (error)
>ASTFlags.Writeable : any (error)
>ASTFlags : any (error)
>Writeable : any (error)

        // REVIEW: for diagnostic purposes
        public passCreated: number = CompilerDiagnostics.analysisPass;
>passCreated : number
>CompilerDiagnostics.analysisPass : any (error)
>CompilerDiagnostics : any (error)
>analysisPass : any (error)

        public preComments: Comment[] = null;
>preComments : Comment[]
>null : null

        public postComments: Comment[] = null;
>postComments : Comment[]
>null : null

        public isParenthesized = false;
>isParenthesized : boolean
>false : false

        constructor (public nodeType: NodeType) {
>nodeType : any (error)

            super();
>super() : void
>super : typeof ASTSpan
        }

        public isExpression() { return false; }
>isExpression : () => boolean
>false : false

        public isStatementOrExpression() { return false; }
>isStatementOrExpression : () => boolean
>false : false

        public isCompoundStatement() { return false; }
>isCompoundStatement : () => boolean
>false : false

        public isLeaf() { return this.isStatementOrExpression() && (!this.isCompoundStatement()); }
>isLeaf : () => boolean
>this.isStatementOrExpression() && (!this.isCompoundStatement()) : boolean
>this.isStatementOrExpression() : boolean
>this.isStatementOrExpression : () => boolean
>this : this
>isStatementOrExpression : () => boolean
>(!this.isCompoundStatement()) : boolean
>!this.isCompoundStatement() : boolean
>this.isCompoundStatement() : boolean
>this.isCompoundStatement : () => boolean
>this : this
>isCompoundStatement : () => boolean

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any
>typeFlow : any (error)

            switch (this.nodeType) {
>this.nodeType : any (error)
>this : this
>nodeType : any (error)

                case NodeType.Error:
>NodeType.Error : any (error)
>NodeType : any (error)
>Error : any (error)

                case NodeType.EmptyExpr:
>NodeType.EmptyExpr : any (error)
>NodeType : any (error)
>EmptyExpr : any (error)

                    this.type = typeFlow.anyType;
>this.type = typeFlow.anyType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.anyType : any (error)
>typeFlow : any (error)
>anyType : any (error)

                    break;
                case NodeType.This:
>NodeType.This : any (error)
>NodeType : any (error)
>This : any (error)

                    return typeFlow.typeCheckThis(this);
>typeFlow.typeCheckThis(this) : any (error)
>typeFlow.typeCheckThis : any (error)
>typeFlow : any (error)
>typeCheckThis : any (error)
>this : this

                case NodeType.Null:
>NodeType.Null : any (error)
>NodeType : any (error)
>Null : any (error)

                    this.type = typeFlow.nullType;
>this.type = typeFlow.nullType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.nullType : any (error)
>typeFlow : any (error)
>nullType : any (error)

                    break;
                case NodeType.False:
>NodeType.False : any (error)
>NodeType : any (error)
>False : any (error)

                case NodeType.True:
>NodeType.True : any (error)
>NodeType : any (error)
>True : any (error)

                    this.type = typeFlow.booleanType;
>this.type = typeFlow.booleanType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.booleanType : any (error)
>typeFlow : any (error)
>booleanType : any (error)

                    break;
                case NodeType.Super:
>NodeType.Super : any (error)
>NodeType : any (error)
>Super : any (error)

                    return typeFlow.typeCheckSuper(this);
>typeFlow.typeCheckSuper(this) : any (error)
>typeFlow.typeCheckSuper : any (error)
>typeFlow : any (error)
>typeCheckSuper : any (error)
>this : this

                case NodeType.EndCode:
>NodeType.EndCode : any (error)
>NodeType : any (error)
>EndCode : any (error)

                case NodeType.Empty:
>NodeType.Empty : any (error)
>NodeType : any (error)
>Empty : any (error)

                case NodeType.Void:
>NodeType.Void : any (error)
>NodeType : any (error)
>Void : any (error)

                    this.type = typeFlow.voidType;
>this.type = typeFlow.voidType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.voidType : any (error)
>typeFlow : any (error)
>voidType : any (error)

                    break;
                default:
                    throw new Error("please implement in derived class");
>new Error("please implement in derived class") : Error
>Error : ErrorConstructor
>"please implement in derived class" : "please implement in derived class"
            }
            return this;
>this : this
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            switch (this.nodeType) {
>this.nodeType : any (error)
>this : this
>nodeType : any (error)

                case NodeType.This:
>NodeType.This : any (error)
>NodeType : any (error)
>This : any (error)

                    emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

                    if (emitter.thisFnc && (hasFlag(emitter.thisFnc.fncFlags, FncFlags.IsFatArrowFunction))) {
>emitter.thisFnc && (hasFlag(emitter.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) : any
>emitter.thisFnc : any (error)
>emitter : any (error)
>thisFnc : any (error)
>(hasFlag(emitter.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) : any (error)
>hasFlag(emitter.thisFnc.fncFlags, FncFlags.IsFatArrowFunction) : any (error)
>hasFlag : any (error)
>emitter.thisFnc.fncFlags : any (error)
>emitter.thisFnc : any (error)
>emitter : any (error)
>thisFnc : any (error)
>fncFlags : any (error)
>FncFlags.IsFatArrowFunction : any (error)
>FncFlags : any (error)
>IsFatArrowFunction : any (error)

                        emitter.writeToOutput("_this");
>emitter.writeToOutput("_this") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"_this" : "_this"
                    }
                    else {
                        emitter.writeToOutput("this");
>emitter.writeToOutput("this") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"this" : "this"
                    }
                    emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

                    break;
                case NodeType.Null:
>NodeType.Null : any (error)
>NodeType : any (error)
>Null : any (error)

                    emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

                    emitter.writeToOutput("null");
>emitter.writeToOutput("null") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"null" : "null"

                    emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

                    break;
                case NodeType.False:
>NodeType.False : any (error)
>NodeType : any (error)
>False : any (error)

                    emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

                    emitter.writeToOutput("false");
>emitter.writeToOutput("false") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"false" : "false"

                    emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

                    break;
                case NodeType.True:
>NodeType.True : any (error)
>NodeType : any (error)
>True : any (error)

                    emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

                    emitter.writeToOutput("true");
>emitter.writeToOutput("true") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"true" : "true"

                    emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

                    break;
                case NodeType.Super:
>NodeType.Super : any (error)
>NodeType : any (error)
>Super : any (error)

                    emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

                    emitter.emitSuperReference();
>emitter.emitSuperReference() : any (error)
>emitter.emitSuperReference : any (error)
>emitter : any (error)
>emitSuperReference : any (error)

                    emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

                    break;
                case NodeType.EndCode:
>NodeType.EndCode : any (error)
>NodeType : any (error)
>EndCode : any (error)

                    break;
                case NodeType.Error:
>NodeType.Error : any (error)
>NodeType : any (error)
>Error : any (error)

                case NodeType.EmptyExpr:
>NodeType.EmptyExpr : any (error)
>NodeType : any (error)
>EmptyExpr : any (error)

                    break;

                case NodeType.Empty:
>NodeType.Empty : any (error)
>NodeType : any (error)
>Empty : any (error)

                    emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

                    emitter.writeToOutput("; ");
>emitter.writeToOutput("; ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"; " : "; "

                    emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

                    break;
                case NodeType.Void:
>NodeType.Void : any (error)
>NodeType : any (error)
>Void : any (error)

                    emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

                    emitter.writeToOutput("void ");
>emitter.writeToOutput("void ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"void " : "void "

                    emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

                    break;
                default:
                    throw new Error("please implement in derived class");
>new Error("please implement in derived class") : Error
>Error : ErrorConstructor
>"please implement in derived class" : "please implement in derived class"
            }
            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public print(context: PrintContext) {
>print : (context: any (error)) => void
>context : any (error)

            context.startLine();
>context.startLine() : any (error)
>context.startLine : any (error)
>context : any (error)
>startLine : any (error)

            var lineCol = { line: -1, col: -1 };
>lineCol : { line: number; col: number; }
>{ line: -1, col: -1 } : { line: number; col: number; }
>line : number
>-1 : -1
>1 : 1
>col : number
>-1 : -1
>1 : 1

            var limLineCol = { line: -1, col: -1 };
>limLineCol : { line: number; col: number; }
>{ line: -1, col: -1 } : { line: number; col: number; }
>line : number
>-1 : -1
>1 : 1
>col : number
>-1 : -1
>1 : 1

            if (context.parser !== null) {
>context.parser !== null : boolean
>context.parser : any (error)
>context : any (error)
>parser : any (error)
>null : null

                context.parser.getSourceLineCol(lineCol, this.minChar);
>context.parser.getSourceLineCol(lineCol, this.minChar) : any (error)
>context.parser.getSourceLineCol : any (error)
>context.parser : any (error)
>context : any (error)
>parser : any (error)
>getSourceLineCol : any (error)
>lineCol : { line: number; col: number; }
>this.minChar : number
>this : this
>minChar : number

                context.parser.getSourceLineCol(limLineCol, this.limChar);
>context.parser.getSourceLineCol(limLineCol, this.limChar) : any (error)
>context.parser.getSourceLineCol : any (error)
>context.parser : any (error)
>context : any (error)
>parser : any (error)
>getSourceLineCol : any (error)
>limLineCol : { line: number; col: number; }
>this.limChar : number
>this : this
>limChar : number

                context.write("(" + lineCol.line + "," + lineCol.col + ")--" +
>context.write("(" + lineCol.line + "," + lineCol.col + ")--" +                              "(" + limLineCol.line + "," + limLineCol.col + "): ") : any (error)
>context.write : any (error)
>context : any (error)
>write : any (error)
>"(" + lineCol.line + "," + lineCol.col + ")--" +                              "(" + limLineCol.line + "," + limLineCol.col + "): " : string
>"(" + lineCol.line + "," + lineCol.col + ")--" +                              "(" + limLineCol.line + "," + limLineCol.col : string
>"(" + lineCol.line + "," + lineCol.col + ")--" +                              "(" + limLineCol.line + "," : string
>"(" + lineCol.line + "," + lineCol.col + ")--" +                              "(" + limLineCol.line : string
>"(" + lineCol.line + "," + lineCol.col + ")--" +                              "(" : string
>"(" + lineCol.line + "," + lineCol.col + ")--" : string
>"(" + lineCol.line + "," + lineCol.col : string
>"(" + lineCol.line + "," : string
>"(" + lineCol.line : string
>"(" : "("
>lineCol.line : number
>lineCol : { line: number; col: number; }
>line : number
>"," : ","
>lineCol.col : number
>lineCol : { line: number; col: number; }
>col : number
>")--" : ")--"

                              "(" + limLineCol.line + "," + limLineCol.col + "): ");
>"(" : "("
>limLineCol.line : number
>limLineCol : { line: number; col: number; }
>line : number
>"," : ","
>limLineCol.col : number
>limLineCol : { line: number; col: number; }
>col : number
>"): " : "): "
            }
            var lab = this.printLabel();
>lab : any
>this.printLabel() : any
>this.printLabel : () => any
>this : this
>printLabel : () => any

            if (hasFlag(this.flags, ASTFlags.Error)) {
>hasFlag(this.flags, ASTFlags.Error) : any (error)
>hasFlag : any (error)
>this.flags : any (error)
>this : this
>flags : any (error)
>ASTFlags.Error : any (error)
>ASTFlags : any (error)
>Error : any (error)

                lab += " (Error)";
>lab += " (Error)" : string
>lab : any
>" (Error)" : " (Error)"
            }
            context.writeLine(lab);
>context.writeLine(lab) : any (error)
>context.writeLine : any (error)
>context : any (error)
>writeLine : any (error)
>lab : any
        }

        public printLabel() {
>printLabel : () => any

            if (nodeTypeTable[this.nodeType] !== undefined) {
>nodeTypeTable[this.nodeType] !== undefined : boolean
>nodeTypeTable[this.nodeType] : any (error)
>nodeTypeTable : any (error)
>this.nodeType : any (error)
>this : this
>nodeType : any (error)
>undefined : undefined

                return nodeTypeTable[this.nodeType];
>nodeTypeTable[this.nodeType] : any (error)
>nodeTypeTable : any (error)
>this.nodeType : any (error)
>this : this
>nodeType : any (error)
            }
            else {
                return (<any>NodeType)._map[this.nodeType];
>(<any>NodeType)._map[this.nodeType] : any
>(<any>NodeType)._map : any
>(<any>NodeType) : any
><any>NodeType : any
>NodeType : any (error)
>_map : any
>this.nodeType : any (error)
>this : this
>nodeType : any (error)
            }
        }

        public addToControlFlow(context: ControlFlowContext): void {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            // by default, AST adds itself to current basic block and does not check its children
            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false

            context.addContent(this);
>context.addContent(this) : any (error)
>context.addContent : any (error)
>context : any (error)
>addContent : any (error)
>this : this
        }

        public netFreeUses(container: Symbol, freeUses: StringHashTable) {
>netFreeUses : (container: Symbol, freeUses: any (error)) => void
>container : Symbol
>freeUses : any (error)
        }

        public treeViewLabel() {
>treeViewLabel : () => any

            return (<any>NodeType)._map[this.nodeType];
>(<any>NodeType)._map[this.nodeType] : any
>(<any>NodeType)._map : any
>(<any>NodeType) : any
><any>NodeType : any
>NodeType : any (error)
>_map : any
>this.nodeType : any (error)
>this : this
>nodeType : any (error)
        }

        public static getResolvedIdentifierName(name: string): string {
>getResolvedIdentifierName : (name: string) => string
>name : string

            if (!name) return "";
>!name : boolean
>name : string
>"" : ""

            var resolved = "";
>resolved : string
>"" : ""

            var start = 0;
>start : number
>0 : 0

            var i = 0;
>i : number
>0 : 0

            while(i <= name.length - 6) {
>i <= name.length - 6 : boolean
>i : number
>name.length - 6 : number
>name.length : number
>name : string
>length : number
>6 : 6

                // Look for escape sequence \uxxxx
                if (name.charAt(i) == '\\' && name.charAt(i+1) == 'u') {
>name.charAt(i) == '\\' && name.charAt(i+1) == 'u' : boolean
>name.charAt(i) == '\\' : boolean
>name.charAt(i) : string
>name.charAt : (pos: number) => string
>name : string
>charAt : (pos: number) => string
>i : number
>'\\' : "\\"
>name.charAt(i+1) == 'u' : boolean
>name.charAt(i+1) : string
>name.charAt : (pos: number) => string
>name : string
>charAt : (pos: number) => string
>i+1 : number
>i : number
>1 : 1
>'u' : "u"

                    var charCode = parseInt(name.substr(i + 2, 4), 16);
>charCode : number
>parseInt(name.substr(i + 2, 4), 16) : number
>parseInt : (s: string, radix?: number) => number
>name.substr(i + 2, 4) : string
>name.substr : (from: number, length?: number) => string
>name : string
>substr : (from: number, length?: number) => string
>i + 2 : number
>i : number
>2 : 2
>4 : 4
>16 : 16

                    resolved += name.substr(start, i - start);
>resolved += name.substr(start, i - start) : string
>resolved : string
>name.substr(start, i - start) : string
>name.substr : (from: number, length?: number) => string
>name : string
>substr : (from: number, length?: number) => string
>start : number
>i - start : number
>i : number
>start : number

                    resolved += String.fromCharCode(charCode);
>resolved += String.fromCharCode(charCode) : string
>resolved : string
>String.fromCharCode(charCode) : string
>String.fromCharCode : (...codes: number[]) => string
>String : StringConstructor
>fromCharCode : (...codes: number[]) => string
>charCode : number

                    i += 6;
>i += 6 : number
>i : number
>6 : 6

                    start = i;
>start = i : number
>start : number
>i : number

                    continue;
                } 
                i++;
>i++ : number
>i : number
            }
            // Append remaining string
            resolved += name.substring(start);
>resolved += name.substring(start) : string
>resolved : string
>name.substring(start) : string
>name.substring : (start: number, end?: number) => string
>name : string
>substring : (start: number, end?: number) => string
>start : number

            return resolved;
>resolved : string
        }
    }

    export class IncompleteAST extends AST {
>IncompleteAST : IncompleteAST
>AST : AST

        constructor (min: number, lim: number) {
>min : number
>lim : number

            super(NodeType.Error);
>super(NodeType.Error) : void
>super : typeof AST
>NodeType.Error : any (error)
>NodeType : any (error)
>Error : any (error)

            this.minChar = min;
>this.minChar = min : number
>this.minChar : number
>this : this
>minChar : number
>min : number

            this.limChar = lim;
>this.limChar = lim : number
>this.limChar : number
>this : this
>limChar : number
>lim : number
        }
    }

    export class ASTList extends AST {
>ASTList : ASTList
>AST : AST

        public enclosingScope: SymbolScope = null;
>enclosingScope : any (error)
>null : null

        public members: AST[] = new AST[];
>members : AST[]
>new AST[] : any
>AST[] : any
>AST : typeof AST
> : any (error)

        constructor () {
            super(NodeType.List);
>super(NodeType.List) : void
>super : typeof AST
>NodeType.List : any (error)
>NodeType : any (error)
>List : any (error)
        }

        public addToControlFlow(context: ControlFlowContext) {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            var len = this.members.length;
>len : number
>this.members.length : number
>this.members : AST[]
>this : this
>members : AST[]
>length : number

            for (var i = 0; i < len; i++) {
>i : number
>0 : 0
>i < len : boolean
>i : number
>len : number
>i++ : number
>i : number

                if (context.noContinuation) {
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)

                    context.addUnreachable(this.members[i]);
>context.addUnreachable(this.members[i]) : any (error)
>context.addUnreachable : any (error)
>context : any (error)
>addUnreachable : any (error)
>this.members[i] : AST
>this.members : AST[]
>this : this
>members : AST[]
>i : number

                    break;
                }
                else {
                    this.members[i] = context.walk(this.members[i], this);
>this.members[i] = context.walk(this.members[i], this) : any (error)
>this.members[i] : AST
>this.members : AST[]
>this : this
>members : AST[]
>i : number
>context.walk(this.members[i], this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.members[i] : AST
>this.members : AST[]
>this : this
>members : AST[]
>i : number
>this : this
                }
            }
            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false
        }

        public append(ast: AST) {
>append : (ast: AST) => this
>ast : AST

            this.members[this.members.length] = ast;
>this.members[this.members.length] = ast : AST
>this.members[this.members.length] : AST
>this.members : AST[]
>this : this
>members : AST[]
>this.members.length : number
>this.members : AST[]
>this : this
>members : AST[]
>length : number
>ast : AST

            return this;
>this : this
        }

        public appendAll(ast: AST) {
>appendAll : (ast: AST) => this
>ast : AST

            if (ast.nodeType == NodeType.List) {
>ast.nodeType == NodeType.List : boolean
>ast.nodeType : any (error)
>ast : AST
>nodeType : any (error)
>NodeType.List : any (error)
>NodeType : any (error)
>List : any (error)

                var list = <ASTList>ast;
>list : ASTList
><ASTList>ast : ASTList
>ast : AST

                for (var i = 0, len = list.members.length; i < len; i++) {
>i : number
>0 : 0
>len : number
>list.members.length : number
>list.members : AST[]
>list : ASTList
>members : AST[]
>length : number
>i < len : boolean
>i : number
>len : number
>i++ : number
>i : number

                    this.append(list.members[i]);
>this.append(list.members[i]) : this
>this.append : (ast: AST) => this
>this : this
>append : (ast: AST) => this
>list.members[i] : AST
>list.members : AST[]
>list : ASTList
>members : AST[]
>i : number
                }
            }
            else {
                this.append(ast);
>this.append(ast) : this
>this.append : (ast: AST) => this
>this : this
>append : (ast: AST) => this
>ast : AST
            }
            return this;
>this : this
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.emitJavascriptList(this, null, TokenID.Semicolon, startLine, false, false);
>emitter.emitJavascriptList(this, null, TokenID.Semicolon, startLine, false, false) : any (error)
>emitter.emitJavascriptList : any (error)
>emitter : any (error)
>emitJavascriptList : any (error)
>this : this
>null : null
>TokenID.Semicolon : any (error)
>TokenID : any (error)
>Semicolon : any (error)
>startLine : boolean
>false : false
>false : false

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            var len = this.members.length;
>len : number
>this.members.length : number
>this.members : AST[]
>this : this
>members : AST[]
>length : number

            typeFlow.nestingLevel++;
>typeFlow.nestingLevel++ : number
>typeFlow.nestingLevel : any (error)
>typeFlow : any (error)
>nestingLevel : any (error)

            for (var i = 0; i < len; i++) {
>i : number
>0 : 0
>i < len : boolean
>i : number
>len : number
>i++ : number
>i : number

                if (this.members[i]) {
>this.members[i] : AST
>this.members : AST[]
>this : this
>members : AST[]
>i : number

                    this.members[i] = this.members[i].typeCheck(typeFlow);
>this.members[i] = this.members[i].typeCheck(typeFlow) : any
>this.members[i] : AST
>this.members : AST[]
>this : this
>members : AST[]
>i : number
>this.members[i].typeCheck(typeFlow) : any
>this.members[i].typeCheck : (typeFlow: any (error)) => any
>this.members[i] : AST
>this.members : AST[]
>this : this
>members : AST[]
>i : number
>typeCheck : (typeFlow: any (error)) => any
>typeFlow : any (error)
                }
            }
            typeFlow.nestingLevel--;
>typeFlow.nestingLevel-- : number
>typeFlow.nestingLevel : any (error)
>typeFlow : any (error)
>nestingLevel : any (error)

            return this;
>this : this
        }
    }

    export class Identifier extends AST {
>Identifier : Identifier
>AST : AST

        public sym: Symbol = null;
>sym : Symbol
>null : null

        public cloId = -1;
>cloId : number
>-1 : -1
>1 : 1

        public text: string;
>text : string

        // 'actualText' is the text that the user has entered for the identifier. the text might 
        // include any Unicode escape sequences (e.g.: \u0041 for 'A'). 'text', however, contains 
        // the resolved value of any escape sequences in the actual text; so in the previous 
        // example, actualText = '\u0041', text = 'A'.
        //
        // For purposes of finding a symbol, use text, as this will allow you to match all 
        // variations of the variable text. For full-fidelity translation of the user input, such
        // as emitting, use the actualText field.
        // 
        // Note: 
        //    To change text, and to avoid running into a situation where 'actualText' does not 
        //    match 'text', always use setText.
        constructor (public actualText: string, public hasEscapeSequence?: boolean) {
>actualText : string
>hasEscapeSequence : boolean

            super(NodeType.Name);
>super(NodeType.Name) : void
>super : typeof AST
>NodeType.Name : any (error)
>NodeType : any (error)
>Name : any (error)

            this.setText(actualText, hasEscapeSequence);
>this.setText(actualText, hasEscapeSequence) : void
>this.setText : (actualText: string, hasEscapeSequence?: boolean) => void
>this : this
>setText : (actualText: string, hasEscapeSequence?: boolean) => void
>actualText : string
>hasEscapeSequence : boolean
        }

        public setText(actualText: string, hasEscapeSequence?: boolean) {
>setText : (actualText: string, hasEscapeSequence?: boolean) => void
>actualText : string
>hasEscapeSequence : boolean

            this.actualText = actualText;
>this.actualText = actualText : string
>this.actualText : string
>this : this
>actualText : string
>actualText : string

            if (hasEscapeSequence) {
>hasEscapeSequence : boolean

                this.text = AST.getResolvedIdentifierName(actualText);
>this.text = AST.getResolvedIdentifierName(actualText) : string
>this.text : string
>this : this
>text : string
>AST.getResolvedIdentifierName(actualText) : string
>AST.getResolvedIdentifierName : (name: string) => string
>AST : typeof AST
>getResolvedIdentifierName : (name: string) => string
>actualText : string
            }
            else {
                this.text = actualText;
>this.text = actualText : string
>this.text : string
>this : this
>text : string
>actualText : string
            }
        }

        public isMissing() { return false; }
>isMissing : () => boolean
>false : false

        public isLeaf() { return true; }
>isLeaf : () => boolean
>true : true

        public treeViewLabel() {
>treeViewLabel : () => string

            return "id: " + this.actualText;
>"id: " + this.actualText : string
>"id: " : "id: "
>this.actualText : string
>this : this
>actualText : string
        }

        public printLabel() {
>printLabel : () => string

            if (this.actualText) {
>this.actualText : string
>this : this
>actualText : string

                return "id: " + this.actualText;
>"id: " + this.actualText : string
>"id: " : "id: "
>this.actualText : string
>this : this
>actualText : string
            }
            else {
                return "name node";
>"name node" : "name node"
            }
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckName(this);
>typeFlow.typeCheckName(this) : any (error)
>typeFlow.typeCheckName : any (error)
>typeFlow : any (error)
>typeCheckName : any (error)
>this : this
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitJavascriptName(this, true);
>emitter.emitJavascriptName(this, true) : any (error)
>emitter.emitJavascriptName : any (error)
>emitter : any (error)
>emitJavascriptName : any (error)
>this : this
>true : true
        }

        public static fromToken(token: Token): Identifier {
>fromToken : (token: any (error)) => Identifier
>token : any (error)

            return new Identifier(token.getText(), (<IdentifierToken>token).hasEscapeSequence);
>new Identifier(token.getText(), (<IdentifierToken>token).hasEscapeSequence) : Identifier
>Identifier : typeof Identifier
>token.getText() : any (error)
>token.getText : any (error)
>token : any (error)
>getText : any (error)
>(<IdentifierToken>token).hasEscapeSequence : any (error)
>(<IdentifierToken>token) : any (error)
><IdentifierToken>token : any (error)
>token : any (error)
>hasEscapeSequence : any (error)
        }
    }

    export class MissingIdentifier extends Identifier {
>MissingIdentifier : MissingIdentifier
>Identifier : Identifier

        constructor () {
            super("__missing");
>super("__missing") : void
>super : typeof Identifier
>"__missing" : "__missing"
        }

        public isMissing() {
>isMissing : () => boolean

            return true;
>true : true
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            // Emit nothing for a missing ID
        }
    }

    export class Label extends AST {
>Label : Label
>AST : AST

        constructor (public id: Identifier) {
>id : Identifier

            super(NodeType.Label);
>super(NodeType.Label) : void
>super : typeof AST
>NodeType.Label : any (error)
>NodeType : any (error)
>Label : any (error)
        }

        public printLabel() { return this.id.actualText + ":"; }
>printLabel : () => string
>this.id.actualText + ":" : string
>this.id.actualText : string
>this.id : Identifier
>this : this
>id : Identifier
>actualText : string
>":" : ":"

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            this.type = typeFlow.voidType;
>this.type = typeFlow.voidType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.voidType : any (error)
>typeFlow : any (error)
>voidType : any (error)

            return this;
>this : this
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.recordSourceMappingStart(this.id);
>emitter.recordSourceMappingStart(this.id) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this.id : Identifier
>this : this
>id : Identifier

            emitter.writeToOutput(this.id.actualText);
>emitter.writeToOutput(this.id.actualText) : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>this.id.actualText : string
>this.id : Identifier
>this : this
>id : Identifier
>actualText : string

            emitter.recordSourceMappingEnd(this.id);
>emitter.recordSourceMappingEnd(this.id) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this.id : Identifier
>this : this
>id : Identifier

            emitter.writeLineToOutput(":");
>emitter.writeLineToOutput(":") : any (error)
>emitter.writeLineToOutput : any (error)
>emitter : any (error)
>writeLineToOutput : any (error)
>":" : ":"

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }
    }

    export class Expression extends AST {
>Expression : Expression
>AST : AST

        constructor (nodeType: NodeType) {
>nodeType : any (error)

            super(nodeType);
>super(nodeType) : void
>super : typeof AST
>nodeType : any (error)
        }

        public isExpression() { return true; }
>isExpression : () => boolean
>true : true

        public isStatementOrExpression() { return true; }
>isStatementOrExpression : () => boolean
>true : true
    }

    export class UnaryExpression extends Expression {
>UnaryExpression : UnaryExpression
>Expression : Expression

        public targetType: Type = null; // Target type for an object literal (null if no target type)
>targetType : any (error)
>null : null

        public castTerm: AST = null;
>castTerm : AST
>null : null

        constructor (nodeType: NodeType, public operand: AST) {
>nodeType : any (error)
>operand : AST

            super(nodeType);
>super(nodeType) : void
>super : typeof Expression
>nodeType : any (error)
        }

        public addToControlFlow(context: ControlFlowContext): void {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            super.addToControlFlow(context);
>super.addToControlFlow(context) : void
>super.addToControlFlow : (context: any (error)) => void
>super : Expression
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            // TODO: add successor as catch block/finally block if present
            if (this.nodeType == NodeType.Throw) {
>this.nodeType == NodeType.Throw : boolean
>this.nodeType : any (error)
>this : this
>nodeType : any (error)
>NodeType.Throw : any (error)
>NodeType : any (error)
>Throw : any (error)

                context.returnStmt();
>context.returnStmt() : any (error)
>context.returnStmt : any (error)
>context : any (error)
>returnStmt : any (error)
            }
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any
>typeFlow : any (error)

            switch (this.nodeType) {
>this.nodeType : any (error)
>this : this
>nodeType : any (error)

                case NodeType.Not:
>NodeType.Not : any (error)
>NodeType : any (error)
>Not : any (error)

                    return typeFlow.typeCheckBitNot(this);
>typeFlow.typeCheckBitNot(this) : any (error)
>typeFlow.typeCheckBitNot : any (error)
>typeFlow : any (error)
>typeCheckBitNot : any (error)
>this : this

                case NodeType.LogNot:
>NodeType.LogNot : any (error)
>NodeType : any (error)
>LogNot : any (error)

                    return typeFlow.typeCheckLogNot(this);
>typeFlow.typeCheckLogNot(this) : any (error)
>typeFlow.typeCheckLogNot : any (error)
>typeFlow : any (error)
>typeCheckLogNot : any (error)
>this : this

                case NodeType.Pos:
>NodeType.Pos : any (error)
>NodeType : any (error)
>Pos : any (error)

                case NodeType.Neg:
>NodeType.Neg : any (error)
>NodeType : any (error)
>Neg : any (error)

                    return typeFlow.typeCheckUnaryNumberOperator(this);
>typeFlow.typeCheckUnaryNumberOperator(this) : any (error)
>typeFlow.typeCheckUnaryNumberOperator : any (error)
>typeFlow : any (error)
>typeCheckUnaryNumberOperator : any (error)
>this : this

                case NodeType.IncPost:
>NodeType.IncPost : any (error)
>NodeType : any (error)
>IncPost : any (error)

                case NodeType.IncPre:
>NodeType.IncPre : any (error)
>NodeType : any (error)
>IncPre : any (error)

                case NodeType.DecPost:
>NodeType.DecPost : any (error)
>NodeType : any (error)
>DecPost : any (error)

                case NodeType.DecPre:
>NodeType.DecPre : any (error)
>NodeType : any (error)
>DecPre : any (error)

                    return typeFlow.typeCheckIncOrDec(this);
>typeFlow.typeCheckIncOrDec(this) : any (error)
>typeFlow.typeCheckIncOrDec : any (error)
>typeFlow : any (error)
>typeCheckIncOrDec : any (error)
>this : this

                case NodeType.ArrayLit:
>NodeType.ArrayLit : any (error)
>NodeType : any (error)
>ArrayLit : any (error)

                    typeFlow.typeCheckArrayLit(this);
>typeFlow.typeCheckArrayLit(this) : any (error)
>typeFlow.typeCheckArrayLit : any (error)
>typeFlow : any (error)
>typeCheckArrayLit : any (error)
>this : this

                    return this;
>this : this

                case NodeType.ObjectLit:
>NodeType.ObjectLit : any (error)
>NodeType : any (error)
>ObjectLit : any (error)

                    typeFlow.typeCheckObjectLit(this);
>typeFlow.typeCheckObjectLit(this) : any (error)
>typeFlow.typeCheckObjectLit : any (error)
>typeFlow : any (error)
>typeCheckObjectLit : any (error)
>this : this

                    return this;
>this : this

                case NodeType.Throw:
>NodeType.Throw : any (error)
>NodeType : any (error)
>Throw : any (error)

                    this.operand = typeFlow.typeCheck(this.operand);
>this.operand = typeFlow.typeCheck(this.operand) : any (error)
>this.operand : AST
>this : this
>operand : AST
>typeFlow.typeCheck(this.operand) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.operand : AST
>this : this
>operand : AST

                    this.type = typeFlow.voidType;
>this.type = typeFlow.voidType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.voidType : any (error)
>typeFlow : any (error)
>voidType : any (error)

                    return this;
>this : this

                case NodeType.Typeof:
>NodeType.Typeof : any (error)
>NodeType : any (error)
>Typeof : any (error)

                    this.operand = typeFlow.typeCheck(this.operand);
>this.operand = typeFlow.typeCheck(this.operand) : any (error)
>this.operand : AST
>this : this
>operand : AST
>typeFlow.typeCheck(this.operand) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.operand : AST
>this : this
>operand : AST

                    this.type = typeFlow.stringType;
>this.type = typeFlow.stringType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.stringType : any (error)
>typeFlow : any (error)
>stringType : any (error)

                    return this;
>this : this

                case NodeType.Delete:
>NodeType.Delete : any (error)
>NodeType : any (error)
>Delete : any (error)

                    this.operand = typeFlow.typeCheck(this.operand);
>this.operand = typeFlow.typeCheck(this.operand) : any (error)
>this.operand : AST
>this : this
>operand : AST
>typeFlow.typeCheck(this.operand) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.operand : AST
>this : this
>operand : AST

                    this.type = typeFlow.booleanType;
>this.type = typeFlow.booleanType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.booleanType : any (error)
>typeFlow : any (error)
>booleanType : any (error)

                    break;

                case NodeType.TypeAssertion:
>NodeType.TypeAssertion : any (error)
>NodeType : any (error)
>TypeAssertion : any (error)

                    this.castTerm = typeFlow.typeCheck(this.castTerm);
>this.castTerm = typeFlow.typeCheck(this.castTerm) : any (error)
>this.castTerm : AST
>this : this
>castTerm : AST
>typeFlow.typeCheck(this.castTerm) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.castTerm : AST
>this : this
>castTerm : AST

                    var applyTargetType = !this.operand.isParenthesized;
>applyTargetType : boolean
>!this.operand.isParenthesized : boolean
>this.operand.isParenthesized : boolean
>this.operand : AST
>this : this
>operand : AST
>isParenthesized : boolean

                    var targetType = applyTargetType ? this.castTerm.type : null;
>targetType : any
>applyTargetType ? this.castTerm.type : null : any
>applyTargetType : boolean
>this.castTerm.type : any (error)
>this.castTerm : AST
>this : this
>castTerm : AST
>type : any (error)
>null : null

                    typeFlow.checker.typeCheckWithContextualType(targetType, typeFlow.checker.inProvisionalTypecheckMode(), true, this.operand);
>typeFlow.checker.typeCheckWithContextualType(targetType, typeFlow.checker.inProvisionalTypecheckMode(), true, this.operand) : any (error)
>typeFlow.checker.typeCheckWithContextualType : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>typeCheckWithContextualType : any (error)
>targetType : any
>typeFlow.checker.inProvisionalTypecheckMode() : any (error)
>typeFlow.checker.inProvisionalTypecheckMode : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>inProvisionalTypecheckMode : any (error)
>true : true
>this.operand : AST
>this : this
>operand : AST

                    typeFlow.castWithCoercion(this.operand, this.castTerm.type, false, true);
>typeFlow.castWithCoercion(this.operand, this.castTerm.type, false, true) : any (error)
>typeFlow.castWithCoercion : any (error)
>typeFlow : any (error)
>castWithCoercion : any (error)
>this.operand : AST
>this : this
>operand : AST
>this.castTerm.type : any (error)
>this.castTerm : AST
>this : this
>castTerm : AST
>type : any (error)
>false : false
>true : true

                    this.type = this.castTerm.type;
>this.type = this.castTerm.type : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>this.castTerm.type : any (error)
>this.castTerm : AST
>this : this
>castTerm : AST
>type : any (error)

                    return this;
>this : this

                case NodeType.Void:
>NodeType.Void : any (error)
>NodeType : any (error)
>Void : any (error)

                    // REVIEW - Although this is good to do for completeness's sake,
                    // this shouldn't be strictly necessary from the void operator's
                    // point of view
                    this.operand = typeFlow.typeCheck(this.operand);
>this.operand = typeFlow.typeCheck(this.operand) : any (error)
>this.operand : AST
>this : this
>operand : AST
>typeFlow.typeCheck(this.operand) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.operand : AST
>this : this
>operand : AST

                    this.type = typeFlow.checker.undefinedType;
>this.type = typeFlow.checker.undefinedType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.checker.undefinedType : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>undefinedType : any (error)

                    break;

                default:
                    throw new Error("please implement in derived class");
>new Error("please implement in derived class") : Error
>Error : ErrorConstructor
>"please implement in derived class" : "please implement in derived class"
            }
            return this;
>this : this
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            switch (this.nodeType) {
>this.nodeType : any (error)
>this : this
>nodeType : any (error)

                case NodeType.IncPost:
>NodeType.IncPost : any (error)
>NodeType : any (error)
>IncPost : any (error)

                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);
>emitter.emitJavascript(this.operand, TokenID.PlusPlus, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.PlusPlus : any (error)
>TokenID : any (error)
>PlusPlus : any (error)
>false : false

                    emitter.writeToOutput("++");
>emitter.writeToOutput("++") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"++" : "++"

                    break;
                case NodeType.LogNot:
>NodeType.LogNot : any (error)
>NodeType : any (error)
>LogNot : any (error)

                    emitter.writeToOutput("!");
>emitter.writeToOutput("!") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"!" : "!"

                    emitter.emitJavascript(this.operand, TokenID.Exclamation, false);
>emitter.emitJavascript(this.operand, TokenID.Exclamation, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.Exclamation : any (error)
>TokenID : any (error)
>Exclamation : any (error)
>false : false

                    break;
                case NodeType.DecPost:
>NodeType.DecPost : any (error)
>NodeType : any (error)
>DecPost : any (error)

                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);
>emitter.emitJavascript(this.operand, TokenID.MinusMinus, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.MinusMinus : any (error)
>TokenID : any (error)
>MinusMinus : any (error)
>false : false

                    emitter.writeToOutput("--");
>emitter.writeToOutput("--") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"--" : "--"

                    break;
                case NodeType.ObjectLit:
>NodeType.ObjectLit : any (error)
>NodeType : any (error)
>ObjectLit : any (error)

                    emitter.emitObjectLiteral(<ASTList>this.operand);
>emitter.emitObjectLiteral(<ASTList>this.operand) : any (error)
>emitter.emitObjectLiteral : any (error)
>emitter : any (error)
>emitObjectLiteral : any (error)
><ASTList>this.operand : ASTList
>this.operand : AST
>this : this
>operand : AST

                    break;
                case NodeType.ArrayLit:
>NodeType.ArrayLit : any (error)
>NodeType : any (error)
>ArrayLit : any (error)

                    emitter.emitArrayLiteral(<ASTList>this.operand);
>emitter.emitArrayLiteral(<ASTList>this.operand) : any (error)
>emitter.emitArrayLiteral : any (error)
>emitter : any (error)
>emitArrayLiteral : any (error)
><ASTList>this.operand : ASTList
>this.operand : AST
>this : this
>operand : AST

                    break;
                case NodeType.Not:
>NodeType.Not : any (error)
>NodeType : any (error)
>Not : any (error)

                    emitter.writeToOutput("~");
>emitter.writeToOutput("~") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"~" : "~"

                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
>emitter.emitJavascript(this.operand, TokenID.Tilde, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.Tilde : any (error)
>TokenID : any (error)
>Tilde : any (error)
>false : false

                    break;
                case NodeType.Neg:
>NodeType.Neg : any (error)
>NodeType : any (error)
>Neg : any (error)

                    emitter.writeToOutput("-");
>emitter.writeToOutput("-") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"-" : "-"

                    if (this.operand.nodeType == NodeType.Neg) {
>this.operand.nodeType == NodeType.Neg : boolean
>this.operand.nodeType : any (error)
>this.operand : AST
>this : this
>operand : AST
>nodeType : any (error)
>NodeType.Neg : any (error)
>NodeType : any (error)
>Neg : any (error)

                        this.operand.isParenthesized = true;
>this.operand.isParenthesized = true : true
>this.operand.isParenthesized : boolean
>this.operand : AST
>this : this
>operand : AST
>isParenthesized : boolean
>true : true
                    }
                    emitter.emitJavascript(this.operand, TokenID.Minus, false);
>emitter.emitJavascript(this.operand, TokenID.Minus, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.Minus : any (error)
>TokenID : any (error)
>Minus : any (error)
>false : false

                    break;
                case NodeType.Pos:
>NodeType.Pos : any (error)
>NodeType : any (error)
>Pos : any (error)

                    emitter.writeToOutput("+");
>emitter.writeToOutput("+") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"+" : "+"

                    if (this.operand.nodeType == NodeType.Pos) {
>this.operand.nodeType == NodeType.Pos : boolean
>this.operand.nodeType : any (error)
>this.operand : AST
>this : this
>operand : AST
>nodeType : any (error)
>NodeType.Pos : any (error)
>NodeType : any (error)
>Pos : any (error)

                        this.operand.isParenthesized = true;
>this.operand.isParenthesized = true : true
>this.operand.isParenthesized : boolean
>this.operand : AST
>this : this
>operand : AST
>isParenthesized : boolean
>true : true
                    }
                    emitter.emitJavascript(this.operand, TokenID.Plus, false);
>emitter.emitJavascript(this.operand, TokenID.Plus, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.Plus : any (error)
>TokenID : any (error)
>Plus : any (error)
>false : false

                    break;
                case NodeType.IncPre:
>NodeType.IncPre : any (error)
>NodeType : any (error)
>IncPre : any (error)

                    emitter.writeToOutput("++");
>emitter.writeToOutput("++") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"++" : "++"

                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);
>emitter.emitJavascript(this.operand, TokenID.PlusPlus, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.PlusPlus : any (error)
>TokenID : any (error)
>PlusPlus : any (error)
>false : false

                    break;
                case NodeType.DecPre:
>NodeType.DecPre : any (error)
>NodeType : any (error)
>DecPre : any (error)

                    emitter.writeToOutput("--");
>emitter.writeToOutput("--") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"--" : "--"

                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);
>emitter.emitJavascript(this.operand, TokenID.MinusMinus, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.MinusMinus : any (error)
>TokenID : any (error)
>MinusMinus : any (error)
>false : false

                    break;
                case NodeType.Throw:
>NodeType.Throw : any (error)
>NodeType : any (error)
>Throw : any (error)

                    emitter.writeToOutput("throw ");
>emitter.writeToOutput("throw ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"throw " : "throw "

                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
>emitter.emitJavascript(this.operand, TokenID.Tilde, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.Tilde : any (error)
>TokenID : any (error)
>Tilde : any (error)
>false : false

                    emitter.writeToOutput(";");
>emitter.writeToOutput(";") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>";" : ";"

                    break;
                case NodeType.Typeof:
>NodeType.Typeof : any (error)
>NodeType : any (error)
>Typeof : any (error)

                    emitter.writeToOutput("typeof ");
>emitter.writeToOutput("typeof ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"typeof " : "typeof "

                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
>emitter.emitJavascript(this.operand, TokenID.Tilde, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.Tilde : any (error)
>TokenID : any (error)
>Tilde : any (error)
>false : false

                    break;
                case NodeType.Delete:
>NodeType.Delete : any (error)
>NodeType : any (error)
>Delete : any (error)

                    emitter.writeToOutput("delete ");
>emitter.writeToOutput("delete ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"delete " : "delete "

                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
>emitter.emitJavascript(this.operand, TokenID.Tilde, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.Tilde : any (error)
>TokenID : any (error)
>Tilde : any (error)
>false : false

                    break;
                case NodeType.Void:
>NodeType.Void : any (error)
>NodeType : any (error)
>Void : any (error)

                    emitter.writeToOutput("void ");
>emitter.writeToOutput("void ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"void " : "void "

                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
>emitter.emitJavascript(this.operand, TokenID.Tilde, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.Tilde : any (error)
>TokenID : any (error)
>Tilde : any (error)
>false : false

                    break;
                case NodeType.TypeAssertion:
>NodeType.TypeAssertion : any (error)
>NodeType : any (error)
>TypeAssertion : any (error)

                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
>emitter.emitJavascript(this.operand, TokenID.Tilde, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand : AST
>this : this
>operand : AST
>TokenID.Tilde : any (error)
>TokenID : any (error)
>Tilde : any (error)
>false : false

                    break;
                default:
                    throw new Error("please implement in derived class");
>new Error("please implement in derived class") : Error
>Error : ErrorConstructor
>"please implement in derived class" : "please implement in derived class"
            }
            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }
    }

    export class CallExpression extends Expression {
>CallExpression : CallExpression
>Expression : Expression

        constructor (nodeType: NodeType,
>nodeType : any (error)

                     public target: AST,
>target : AST

                     public arguments: ASTList) {
>arguments : ASTList

            super(nodeType);
>super(nodeType) : void
>super : typeof Expression
>nodeType : any (error)

            this.minChar = this.target.minChar;
>this.minChar = this.target.minChar : number
>this.minChar : number
>this : this
>minChar : number
>this.target.minChar : number
>this.target : AST
>this : this
>target : AST
>minChar : number
        }

        public signature: Signature = null;
>signature : any (error)
>null : null

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            if (this.nodeType == NodeType.New) {
>this.nodeType == NodeType.New : boolean
>this.nodeType : any (error)
>this : this
>nodeType : any (error)
>NodeType.New : any (error)
>NodeType : any (error)
>New : any (error)

                return typeFlow.typeCheckNew(this);
>typeFlow.typeCheckNew(this) : any (error)
>typeFlow.typeCheckNew : any (error)
>typeFlow : any (error)
>typeCheckNew : any (error)
>this : this
            }
            else {
                return typeFlow.typeCheckCall(this);
>typeFlow.typeCheckCall(this) : any (error)
>typeFlow.typeCheckCall : any (error)
>typeFlow : any (error)
>typeCheckCall : any (error)
>this : this
            }
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            if (this.nodeType == NodeType.New) {
>this.nodeType == NodeType.New : boolean
>this.nodeType : any (error)
>this : this
>nodeType : any (error)
>NodeType.New : any (error)
>NodeType : any (error)
>New : any (error)

                emitter.emitNew(this.target, this.arguments);
>emitter.emitNew(this.target, this.arguments) : any (error)
>emitter.emitNew : any (error)
>emitter : any (error)
>emitNew : any (error)
>this.target : AST
>this : this
>target : AST
>this.arguments : ASTList
>this : this
>arguments : ASTList
            }
            else {
                emitter.emitCall(this, this.target, this.arguments);
>emitter.emitCall(this, this.target, this.arguments) : any (error)
>emitter.emitCall : any (error)
>emitter : any (error)
>emitCall : any (error)
>this : this
>this.target : AST
>this : this
>target : AST
>this.arguments : ASTList
>this : this
>arguments : ASTList
            }

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }
    }

    export class BinaryExpression extends Expression {
>BinaryExpression : BinaryExpression
>Expression : Expression

        constructor (nodeType: NodeType, public operand1: AST, public operand2: AST) {
>nodeType : any (error)
>operand1 : AST
>operand2 : AST

            super(nodeType);
>super(nodeType) : void
>super : typeof Expression
>nodeType : any (error)
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any
>typeFlow : any (error)

            switch (this.nodeType) {
>this.nodeType : any (error)
>this : this
>nodeType : any (error)

                case NodeType.Dot:
>NodeType.Dot : any (error)
>NodeType : any (error)
>Dot : any (error)

                    return typeFlow.typeCheckDotOperator(this);
>typeFlow.typeCheckDotOperator(this) : any (error)
>typeFlow.typeCheckDotOperator : any (error)
>typeFlow : any (error)
>typeCheckDotOperator : any (error)
>this : this

                case NodeType.Asg:
>NodeType.Asg : any (error)
>NodeType : any (error)
>Asg : any (error)

                    return typeFlow.typeCheckAsgOperator(this);
>typeFlow.typeCheckAsgOperator(this) : any (error)
>typeFlow.typeCheckAsgOperator : any (error)
>typeFlow : any (error)
>typeCheckAsgOperator : any (error)
>this : this

                case NodeType.Add:
>NodeType.Add : any (error)
>NodeType : any (error)
>Add : any (error)

                case NodeType.Sub:
>NodeType.Sub : any (error)
>NodeType : any (error)
>Sub : any (error)

                case NodeType.Mul:
>NodeType.Mul : any (error)
>NodeType : any (error)
>Mul : any (error)

                case NodeType.Div:
>NodeType.Div : any (error)
>NodeType : any (error)
>Div : any (error)

                case NodeType.Mod:
>NodeType.Mod : any (error)
>NodeType : any (error)
>Mod : any (error)

                case NodeType.Or:
>NodeType.Or : any (error)
>NodeType : any (error)
>Or : any (error)

                case NodeType.And:
>NodeType.And : any (error)
>NodeType : any (error)
>And : any (error)

                    return typeFlow.typeCheckArithmeticOperator(this, false);
>typeFlow.typeCheckArithmeticOperator(this, false) : any (error)
>typeFlow.typeCheckArithmeticOperator : any (error)
>typeFlow : any (error)
>typeCheckArithmeticOperator : any (error)
>this : this
>false : false

                case NodeType.Xor:
>NodeType.Xor : any (error)
>NodeType : any (error)
>Xor : any (error)

                    return typeFlow.typeCheckBitwiseOperator(this, false);
>typeFlow.typeCheckBitwiseOperator(this, false) : any (error)
>typeFlow.typeCheckBitwiseOperator : any (error)
>typeFlow : any (error)
>typeCheckBitwiseOperator : any (error)
>this : this
>false : false

                case NodeType.Ne:
>NodeType.Ne : any (error)
>NodeType : any (error)
>Ne : any (error)

                case NodeType.Eq:
>NodeType.Eq : any (error)
>NodeType : any (error)
>Eq : any (error)

                    var text: string;
>text : string

                    if (typeFlow.checker.styleSettings.eqeqeq) {
>typeFlow.checker.styleSettings.eqeqeq : any (error)
>typeFlow.checker.styleSettings : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>styleSettings : any (error)
>eqeqeq : any (error)

                        text = nodeTypeTable[this.nodeType];
>text = nodeTypeTable[this.nodeType] : any (error)
>text : string
>nodeTypeTable[this.nodeType] : any (error)
>nodeTypeTable : any (error)
>this.nodeType : any (error)
>this : this
>nodeType : any (error)

                        typeFlow.checker.errorReporter.styleError(this, "use of " + text);
>typeFlow.checker.errorReporter.styleError(this, "use of " + text) : any (error)
>typeFlow.checker.errorReporter.styleError : any (error)
>typeFlow.checker.errorReporter : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>errorReporter : any (error)
>styleError : any (error)
>this : this
>"use of " + text : string
>"use of " : "use of "
>text : string
                    }
                    else if (typeFlow.checker.styleSettings.eqnull) {
>typeFlow.checker.styleSettings.eqnull : any (error)
>typeFlow.checker.styleSettings : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>styleSettings : any (error)
>eqnull : any (error)

                        text = nodeTypeTable[this.nodeType];
>text = nodeTypeTable[this.nodeType] : any (error)
>text : string
>nodeTypeTable[this.nodeType] : any (error)
>nodeTypeTable : any (error)
>this.nodeType : any (error)
>this : this
>nodeType : any (error)

                        if ((this.operand2 !== null) && (this.operand2.nodeType == NodeType.Null)) {
>(this.operand2 !== null) && (this.operand2.nodeType == NodeType.Null) : boolean
>(this.operand2 !== null) : boolean
>this.operand2 !== null : boolean
>this.operand2 : AST
>this : this
>operand2 : AST
>null : null
>(this.operand2.nodeType == NodeType.Null) : boolean
>this.operand2.nodeType == NodeType.Null : boolean
>this.operand2.nodeType : any (error)
>this.operand2 : AST
>this : this
>operand2 : AST
>nodeType : any (error)
>NodeType.Null : any (error)
>NodeType : any (error)
>Null : any (error)

                            typeFlow.checker.errorReporter.styleError(this, "use of " + text + " to compare with null");
>typeFlow.checker.errorReporter.styleError(this, "use of " + text + " to compare with null") : any (error)
>typeFlow.checker.errorReporter.styleError : any (error)
>typeFlow.checker.errorReporter : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>errorReporter : any (error)
>styleError : any (error)
>this : this
>"use of " + text + " to compare with null" : string
>"use of " + text : string
>"use of " : "use of "
>text : string
>" to compare with null" : " to compare with null"
                        }
                    }
                case NodeType.Eqv:
>NodeType.Eqv : any (error)
>NodeType : any (error)
>Eqv : any (error)

                case NodeType.NEqv:
>NodeType.NEqv : any (error)
>NodeType : any (error)
>NEqv : any (error)

                case NodeType.Lt:
>NodeType.Lt : any (error)
>NodeType : any (error)
>Lt : any (error)

                case NodeType.Le:
>NodeType.Le : any (error)
>NodeType : any (error)
>Le : any (error)

                case NodeType.Ge:
>NodeType.Ge : any (error)
>NodeType : any (error)
>Ge : any (error)

                case NodeType.Gt:
>NodeType.Gt : any (error)
>NodeType : any (error)
>Gt : any (error)

                    return typeFlow.typeCheckBooleanOperator(this);
>typeFlow.typeCheckBooleanOperator(this) : any (error)
>typeFlow.typeCheckBooleanOperator : any (error)
>typeFlow : any (error)
>typeCheckBooleanOperator : any (error)
>this : this

                case NodeType.Index:
>NodeType.Index : any (error)
>NodeType : any (error)
>Index : any (error)

                    return typeFlow.typeCheckIndex(this);
>typeFlow.typeCheckIndex(this) : any (error)
>typeFlow.typeCheckIndex : any (error)
>typeFlow : any (error)
>typeCheckIndex : any (error)
>this : this

                case NodeType.Member:
>NodeType.Member : any (error)
>NodeType : any (error)
>Member : any (error)

                    this.type = typeFlow.voidType;
>this.type = typeFlow.voidType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.voidType : any (error)
>typeFlow : any (error)
>voidType : any (error)

                    return this;
>this : this

                case NodeType.LogOr:
>NodeType.LogOr : any (error)
>NodeType : any (error)
>LogOr : any (error)

                    return typeFlow.typeCheckLogOr(this);
>typeFlow.typeCheckLogOr(this) : any (error)
>typeFlow.typeCheckLogOr : any (error)
>typeFlow : any (error)
>typeCheckLogOr : any (error)
>this : this

                case NodeType.LogAnd:
>NodeType.LogAnd : any (error)
>NodeType : any (error)
>LogAnd : any (error)

                    return typeFlow.typeCheckLogAnd(this);
>typeFlow.typeCheckLogAnd(this) : any (error)
>typeFlow.typeCheckLogAnd : any (error)
>typeFlow : any (error)
>typeCheckLogAnd : any (error)
>this : this

                case NodeType.AsgAdd:
>NodeType.AsgAdd : any (error)
>NodeType : any (error)
>AsgAdd : any (error)

                case NodeType.AsgSub:
>NodeType.AsgSub : any (error)
>NodeType : any (error)
>AsgSub : any (error)

                case NodeType.AsgMul:
>NodeType.AsgMul : any (error)
>NodeType : any (error)
>AsgMul : any (error)

                case NodeType.AsgDiv:
>NodeType.AsgDiv : any (error)
>NodeType : any (error)
>AsgDiv : any (error)

                case NodeType.AsgMod:
>NodeType.AsgMod : any (error)
>NodeType : any (error)
>AsgMod : any (error)

                case NodeType.AsgOr:
>NodeType.AsgOr : any (error)
>NodeType : any (error)
>AsgOr : any (error)

                case NodeType.AsgAnd:
>NodeType.AsgAnd : any (error)
>NodeType : any (error)
>AsgAnd : any (error)

                    return typeFlow.typeCheckArithmeticOperator(this, true);
>typeFlow.typeCheckArithmeticOperator(this, true) : any (error)
>typeFlow.typeCheckArithmeticOperator : any (error)
>typeFlow : any (error)
>typeCheckArithmeticOperator : any (error)
>this : this
>true : true

                case NodeType.AsgXor:
>NodeType.AsgXor : any (error)
>NodeType : any (error)
>AsgXor : any (error)

                    return typeFlow.typeCheckBitwiseOperator(this, true);
>typeFlow.typeCheckBitwiseOperator(this, true) : any (error)
>typeFlow.typeCheckBitwiseOperator : any (error)
>typeFlow : any (error)
>typeCheckBitwiseOperator : any (error)
>this : this
>true : true

                case NodeType.Lsh:
>NodeType.Lsh : any (error)
>NodeType : any (error)
>Lsh : any (error)

                case NodeType.Rsh:
>NodeType.Rsh : any (error)
>NodeType : any (error)
>Rsh : any (error)

                case NodeType.Rs2:
>NodeType.Rs2 : any (error)
>NodeType : any (error)
>Rs2 : any (error)

                    return typeFlow.typeCheckShift(this, false);
>typeFlow.typeCheckShift(this, false) : any (error)
>typeFlow.typeCheckShift : any (error)
>typeFlow : any (error)
>typeCheckShift : any (error)
>this : this
>false : false

                case NodeType.AsgLsh:
>NodeType.AsgLsh : any (error)
>NodeType : any (error)
>AsgLsh : any (error)

                case NodeType.AsgRsh:
>NodeType.AsgRsh : any (error)
>NodeType : any (error)
>AsgRsh : any (error)

                case NodeType.AsgRs2:
>NodeType.AsgRs2 : any (error)
>NodeType : any (error)
>AsgRs2 : any (error)

                    return typeFlow.typeCheckShift(this, true);
>typeFlow.typeCheckShift(this, true) : any (error)
>typeFlow.typeCheckShift : any (error)
>typeFlow : any (error)
>typeCheckShift : any (error)
>this : this
>true : true

                case NodeType.Comma:
>NodeType.Comma : any (error)
>NodeType : any (error)
>Comma : any (error)

                    return typeFlow.typeCheckCommaOperator(this);
>typeFlow.typeCheckCommaOperator(this) : any (error)
>typeFlow.typeCheckCommaOperator : any (error)
>typeFlow : any (error)
>typeCheckCommaOperator : any (error)
>this : this

                case NodeType.InstOf:
>NodeType.InstOf : any (error)
>NodeType : any (error)
>InstOf : any (error)

                    return typeFlow.typeCheckInstOf(this);
>typeFlow.typeCheckInstOf(this) : any (error)
>typeFlow.typeCheckInstOf : any (error)
>typeFlow : any (error)
>typeCheckInstOf : any (error)
>this : this

                case NodeType.In:
>NodeType.In : any (error)
>NodeType : any (error)
>In : any (error)

                    return typeFlow.typeCheckInOperator(this);
>typeFlow.typeCheckInOperator(this) : any (error)
>typeFlow.typeCheckInOperator : any (error)
>typeFlow : any (error)
>typeCheckInOperator : any (error)
>this : this

                case NodeType.From:
>NodeType.From : any (error)
>NodeType : any (error)
>From : any (error)

                    typeFlow.checker.errorReporter.simpleError(this, "Illegal use of 'from' keyword in binary expression");
>typeFlow.checker.errorReporter.simpleError(this, "Illegal use of 'from' keyword in binary expression") : any (error)
>typeFlow.checker.errorReporter.simpleError : any (error)
>typeFlow.checker.errorReporter : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>errorReporter : any (error)
>simpleError : any (error)
>this : this
>"Illegal use of 'from' keyword in binary expression" : "Illegal use of 'from' keyword in binary expression"

                    break;
                default:
                    throw new Error("please implement in derived class");
>new Error("please implement in derived class") : Error
>Error : ErrorConstructor
>"please implement in derived class" : "please implement in derived class"
            }
            return this;
>this : this
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            var binTokenId = nodeTypeToTokTable[this.nodeType];
>binTokenId : any (error)
>nodeTypeToTokTable[this.nodeType] : any (error)
>nodeTypeToTokTable : any (error)
>this.nodeType : any (error)
>this : this
>nodeType : any (error)

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            if (binTokenId != undefined) {
>binTokenId != undefined : boolean
>binTokenId : any (error)
>undefined : undefined

                emitter.emitJavascript(this.operand1, binTokenId, false);
>emitter.emitJavascript(this.operand1, binTokenId, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand1 : AST
>this : this
>operand1 : AST
>binTokenId : any (error)
>false : false

                if (tokenTable[binTokenId].text == "instanceof") {
>tokenTable[binTokenId].text == "instanceof" : boolean
>tokenTable[binTokenId].text : any (error)
>tokenTable[binTokenId] : any (error)
>tokenTable : any (error)
>binTokenId : any (error)
>text : any (error)
>"instanceof" : "instanceof"

                    emitter.writeToOutput(" instanceof ");
>emitter.writeToOutput(" instanceof ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>" instanceof " : " instanceof "
                }
                else if (tokenTable[binTokenId].text == "in") {
>tokenTable[binTokenId].text == "in" : boolean
>tokenTable[binTokenId].text : any (error)
>tokenTable[binTokenId] : any (error)
>tokenTable : any (error)
>binTokenId : any (error)
>text : any (error)
>"in" : "in"

                    emitter.writeToOutput(" in ");
>emitter.writeToOutput(" in ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>" in " : " in "
                }
                else {
                    emitter.writeToOutputTrimmable(" " + tokenTable[binTokenId].text + " ");
>emitter.writeToOutputTrimmable(" " + tokenTable[binTokenId].text + " ") : any (error)
>emitter.writeToOutputTrimmable : any (error)
>emitter : any (error)
>writeToOutputTrimmable : any (error)
>" " + tokenTable[binTokenId].text + " " : string
>" " + tokenTable[binTokenId].text : string
>" " : " "
>tokenTable[binTokenId].text : any (error)
>tokenTable[binTokenId] : any (error)
>tokenTable : any (error)
>binTokenId : any (error)
>text : any (error)
>" " : " "
                }

                emitter.emitJavascript(this.operand2, binTokenId, false);
>emitter.emitJavascript(this.operand2, binTokenId, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand2 : AST
>this : this
>operand2 : AST
>binTokenId : any (error)
>false : false
            }
            else {
                switch (this.nodeType) {
>this.nodeType : any (error)
>this : this
>nodeType : any (error)

                    case NodeType.Dot:
>NodeType.Dot : any (error)
>NodeType : any (error)
>Dot : any (error)

                        if (!emitter.tryEmitConstant(this)) {
>!emitter.tryEmitConstant(this) : boolean
>emitter.tryEmitConstant(this) : any (error)
>emitter.tryEmitConstant : any (error)
>emitter : any (error)
>tryEmitConstant : any (error)
>this : this

                            emitter.emitJavascript(this.operand1, TokenID.Dot, false);
>emitter.emitJavascript(this.operand1, TokenID.Dot, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand1 : AST
>this : this
>operand1 : AST
>TokenID.Dot : any (error)
>TokenID : any (error)
>Dot : any (error)
>false : false

                            emitter.writeToOutput(".");
>emitter.writeToOutput(".") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"." : "."

                            emitter.emitJavascriptName(<Identifier>this.operand2, false);
>emitter.emitJavascriptName(<Identifier>this.operand2, false) : any (error)
>emitter.emitJavascriptName : any (error)
>emitter : any (error)
>emitJavascriptName : any (error)
><Identifier>this.operand2 : Identifier
>this.operand2 : AST
>this : this
>operand2 : AST
>false : false
                        }
                        break;
                    case NodeType.Index:
>NodeType.Index : any (error)
>NodeType : any (error)
>Index : any (error)

                        emitter.emitIndex(this.operand1, this.operand2);
>emitter.emitIndex(this.operand1, this.operand2) : any (error)
>emitter.emitIndex : any (error)
>emitter : any (error)
>emitIndex : any (error)
>this.operand1 : AST
>this : this
>operand1 : AST
>this.operand2 : AST
>this : this
>operand2 : AST

                        break;

                    case NodeType.Member:
>NodeType.Member : any (error)
>NodeType : any (error)
>Member : any (error)

                        if (this.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>this.operand2).isAccessor()) {
>this.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>this.operand2).isAccessor() : any
>this.operand2.nodeType == NodeType.FuncDecl : boolean
>this.operand2.nodeType : any (error)
>this.operand2 : AST
>this : this
>operand2 : AST
>nodeType : any (error)
>NodeType.FuncDecl : any (error)
>NodeType : any (error)
>FuncDecl : any (error)
>(<FuncDecl>this.operand2).isAccessor() : any
>(<FuncDecl>this.operand2).isAccessor : () => any
>(<FuncDecl>this.operand2) : FuncDecl
><FuncDecl>this.operand2 : FuncDecl
>this.operand2 : AST
>this : this
>operand2 : AST
>isAccessor : () => any

                            var funcDecl = <FuncDecl>this.operand2;
>funcDecl : FuncDecl
><FuncDecl>this.operand2 : FuncDecl
>this.operand2 : AST
>this : this
>operand2 : AST

                            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
>hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) : any (error)
>hasFlag : any (error)
>funcDecl.fncFlags : any (error)
>funcDecl : FuncDecl
>fncFlags : any (error)
>FncFlags.GetAccessor : any (error)
>FncFlags : any (error)
>GetAccessor : any (error)

                                emitter.writeToOutput("get ");
>emitter.writeToOutput("get ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"get " : "get "
                            }
                            else {
                                emitter.writeToOutput("set ");
>emitter.writeToOutput("set ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"set " : "set "
                            }
                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);
>emitter.emitJavascript(this.operand1, TokenID.Colon, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand1 : AST
>this : this
>operand1 : AST
>TokenID.Colon : any (error)
>TokenID : any (error)
>Colon : any (error)
>false : false
                        }
                        else {
                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);
>emitter.emitJavascript(this.operand1, TokenID.Colon, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand1 : AST
>this : this
>operand1 : AST
>TokenID.Colon : any (error)
>TokenID : any (error)
>Colon : any (error)
>false : false

                            emitter.writeToOutputTrimmable(": ");
>emitter.writeToOutputTrimmable(": ") : any (error)
>emitter.writeToOutputTrimmable : any (error)
>emitter : any (error)
>writeToOutputTrimmable : any (error)
>": " : ": "
                        }
                        emitter.emitJavascript(this.operand2, TokenID.Comma, false);
>emitter.emitJavascript(this.operand2, TokenID.Comma, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand2 : AST
>this : this
>operand2 : AST
>TokenID.Comma : any (error)
>TokenID : any (error)
>Comma : any (error)
>false : false

                        break;
                    case NodeType.Comma:
>NodeType.Comma : any (error)
>NodeType : any (error)
>Comma : any (error)

                        emitter.emitJavascript(this.operand1, TokenID.Comma, false);
>emitter.emitJavascript(this.operand1, TokenID.Comma, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand1 : AST
>this : this
>operand1 : AST
>TokenID.Comma : any (error)
>TokenID : any (error)
>Comma : any (error)
>false : false

                        if (emitter.emitState.inObjectLiteral) {
>emitter.emitState.inObjectLiteral : any (error)
>emitter.emitState : any (error)
>emitter : any (error)
>emitState : any (error)
>inObjectLiteral : any (error)

                            emitter.writeLineToOutput(", ");
>emitter.writeLineToOutput(", ") : any (error)
>emitter.writeLineToOutput : any (error)
>emitter : any (error)
>writeLineToOutput : any (error)
>", " : ", "
                        }
                        else {
                            emitter.writeToOutput(",");
>emitter.writeToOutput(",") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"," : ","
                        }
                        emitter.emitJavascript(this.operand2, TokenID.Comma, false);
>emitter.emitJavascript(this.operand2, TokenID.Comma, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand2 : AST
>this : this
>operand2 : AST
>TokenID.Comma : any (error)
>TokenID : any (error)
>Comma : any (error)
>false : false

                        break;
                    case NodeType.Is:
>NodeType.Is : any (error)
>NodeType : any (error)
>Is : any (error)

                        throw new Error("should be de-sugared during type check");
>new Error("should be de-sugared during type check") : Error
>Error : ErrorConstructor
>"should be de-sugared during type check" : "should be de-sugared during type check"

                    default:
                        throw new Error("please implement in derived class");
>new Error("please implement in derived class") : Error
>Error : ErrorConstructor
>"please implement in derived class" : "please implement in derived class"
                }
            }
            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }
    }

    export class ConditionalExpression extends Expression {
>ConditionalExpression : ConditionalExpression
>Expression : Expression

        constructor (public operand1: AST,
>operand1 : AST

                     public operand2: AST,
>operand2 : AST

                     public operand3: AST) {
>operand3 : AST

            super(NodeType.ConditionalExpression);
>super(NodeType.ConditionalExpression) : void
>super : typeof Expression
>NodeType.ConditionalExpression : any (error)
>NodeType : any (error)
>ConditionalExpression : any (error)
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckQMark(this);
>typeFlow.typeCheckQMark(this) : any (error)
>typeFlow.typeCheckQMark : any (error)
>typeFlow : any (error)
>typeCheckQMark : any (error)
>this : this
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.emitJavascript(this.operand1, TokenID.Question, false);
>emitter.emitJavascript(this.operand1, TokenID.Question, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand1 : AST
>this : this
>operand1 : AST
>TokenID.Question : any (error)
>TokenID : any (error)
>Question : any (error)
>false : false

            emitter.writeToOutput(" ? ");
>emitter.writeToOutput(" ? ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>" ? " : " ? "

            emitter.emitJavascript(this.operand2, TokenID.Question, false);
>emitter.emitJavascript(this.operand2, TokenID.Question, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand2 : AST
>this : this
>operand2 : AST
>TokenID.Question : any (error)
>TokenID : any (error)
>Question : any (error)
>false : false

            emitter.writeToOutput(" : ");
>emitter.writeToOutput(" : ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>" : " : " : "

            emitter.emitJavascript(this.operand3, TokenID.Question, false);
>emitter.emitJavascript(this.operand3, TokenID.Question, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.operand3 : AST
>this : this
>operand3 : AST
>TokenID.Question : any (error)
>TokenID : any (error)
>Question : any (error)
>false : false

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }
    }

    export class NumberLiteral extends Expression {
>NumberLiteral : NumberLiteral
>Expression : Expression

        constructor (public value: number, public hasEmptyFraction?: boolean) {
>value : number
>hasEmptyFraction : boolean

            super(NodeType.NumberLit);
>super(NodeType.NumberLit) : void
>super : typeof Expression
>NodeType.NumberLit : any (error)
>NodeType : any (error)
>NumberLit : any (error)
        }

        public isNegativeZero = false;
>isNegativeZero : boolean
>false : false

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            this.type = typeFlow.doubleType;
>this.type = typeFlow.doubleType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.doubleType : any (error)
>typeFlow : any (error)
>doubleType : any (error)

            return this;
>this : this
        }

        public treeViewLabel() {
>treeViewLabel : () => string

            return "num: " + this.printLabel();
>"num: " + this.printLabel() : string
>"num: " : "num: "
>this.printLabel() : string
>this.printLabel : () => string
>this : this
>printLabel : () => string
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            if (this.isNegativeZero) {
>this.isNegativeZero : boolean
>this : this
>isNegativeZero : boolean

                emitter.writeToOutput("-");
>emitter.writeToOutput("-") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"-" : "-"
            }

            emitter.writeToOutput(this.value.toString());
>emitter.writeToOutput(this.value.toString()) : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>this.value.toString() : string
>this.value.toString : (radix?: number) => string
>this.value : number
>this : this
>value : number
>toString : (radix?: number) => string

            if (this.hasEmptyFraction)
>this.hasEmptyFraction : boolean
>this : this
>hasEmptyFraction : boolean

                emitter.writeToOutput(".0");
>emitter.writeToOutput(".0") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>".0" : ".0"

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public printLabel() {
>printLabel : () => string

            if (Math.floor(this.value) != this.value) {
>Math.floor(this.value) != this.value : boolean
>Math.floor(this.value) : number
>Math.floor : (x: number) => number
>Math : Math
>floor : (x: number) => number
>this.value : number
>this : this
>value : number
>this.value : number
>this : this
>value : number

                return this.value.toFixed(2).toString();
>this.value.toFixed(2).toString() : string
>this.value.toFixed(2).toString : () => string
>this.value.toFixed(2) : string
>this.value.toFixed : (fractionDigits?: number) => string
>this.value : number
>this : this
>value : number
>toFixed : (fractionDigits?: number) => string
>2 : 2
>toString : () => string
            }
            else if (this.hasEmptyFraction) {
>this.hasEmptyFraction : boolean
>this : this
>hasEmptyFraction : boolean

                return this.value.toString() + ".0";
>this.value.toString() + ".0" : string
>this.value.toString() : string
>this.value.toString : (radix?: number) => string
>this.value : number
>this : this
>value : number
>toString : (radix?: number) => string
>".0" : ".0"
            }
            else {
                return this.value.toString();
>this.value.toString() : string
>this.value.toString : (radix?: number) => string
>this.value : number
>this : this
>value : number
>toString : (radix?: number) => string
            }
        }
    }

    export class RegexLiteral extends Expression {
>RegexLiteral : RegexLiteral
>Expression : Expression

        constructor (public regex) {
>regex : any

            super(NodeType.Regex);
>super(NodeType.Regex) : void
>super : typeof Expression
>NodeType.Regex : any (error)
>NodeType : any (error)
>Regex : any (error)
        }
        
        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            this.type = typeFlow.regexType;
>this.type = typeFlow.regexType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.regexType : any (error)
>typeFlow : any (error)
>regexType : any (error)

            return this;
>this : this
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.writeToOutput(this.regex.toString());
>emitter.writeToOutput(this.regex.toString()) : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>this.regex.toString() : any
>this.regex.toString : any
>this.regex : any
>this : this
>regex : any
>toString : any

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }
    }

    export class StringLiteral extends Expression {
>StringLiteral : StringLiteral
>Expression : Expression

        constructor (public text: string) {
>text : string

            super(NodeType.QString);
>super(NodeType.QString) : void
>super : typeof Expression
>NodeType.QString : any (error)
>NodeType : any (error)
>QString : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.emitStringLiteral(this.text);
>emitter.emitStringLiteral(this.text) : any (error)
>emitter.emitStringLiteral : any (error)
>emitter : any (error)
>emitStringLiteral : any (error)
>this.text : string
>this : this
>text : string

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            this.type = typeFlow.stringType;
>this.type = typeFlow.stringType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.stringType : any (error)
>typeFlow : any (error)
>stringType : any (error)

            return this;
>this : this
        }

        public treeViewLabel() {
>treeViewLabel : () => string

            return "st: " + this.text;
>"st: " + this.text : string
>"st: " : "st: "
>this.text : string
>this : this
>text : string
        }

        public printLabel() {
>printLabel : () => string

            return this.text;
>this.text : string
>this : this
>text : string
        }
    }

    export class ModuleElement extends AST {
>ModuleElement : ModuleElement
>AST : AST

        constructor (nodeType: NodeType) {
>nodeType : any (error)

            super(nodeType);
>super(nodeType) : void
>super : typeof AST
>nodeType : any (error)
        }
    }

    export class ImportDeclaration extends ModuleElement {
>ImportDeclaration : ImportDeclaration
>ModuleElement : ModuleElement

        public isStatementOrExpression() { return true; }
>isStatementOrExpression : () => boolean
>true : true

        public varFlags = VarFlags.None;
>varFlags : any (error)
>VarFlags.None : any (error)
>VarFlags : any (error)
>None : any (error)

        public isDynamicImport = false;
>isDynamicImport : boolean
>false : false

        constructor (public id: Identifier, public alias: AST) {
>id : Identifier
>alias : AST

            super(NodeType.ImportDeclaration);
>super(NodeType.ImportDeclaration) : void
>super : typeof ModuleElement
>NodeType.ImportDeclaration : any (error)
>NodeType : any (error)
>ImportDeclaration : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            var mod = <ModuleType>this.alias.type;
>mod : any (error)
><ModuleType>this.alias.type : any (error)
>this.alias.type : any (error)
>this.alias : AST
>this : this
>alias : AST
>type : any (error)

            // REVIEW: Only modules may be aliased for now, though there's no real
            // restriction on what the type symbol may be
            if (!this.isDynamicImport || (this.id.sym && !(<TypeSymbol>this.id.sym).onlyReferencedAsTypeRef)) {
>!this.isDynamicImport || (this.id.sym && !(<TypeSymbol>this.id.sym).onlyReferencedAsTypeRef) : boolean
>!this.isDynamicImport : boolean
>this.isDynamicImport : boolean
>this : this
>isDynamicImport : boolean
>(this.id.sym && !(<TypeSymbol>this.id.sym).onlyReferencedAsTypeRef) : boolean
>this.id.sym && !(<TypeSymbol>this.id.sym).onlyReferencedAsTypeRef : boolean
>this.id.sym : Symbol
>this.id : Identifier
>this : this
>id : Identifier
>sym : Symbol
>!(<TypeSymbol>this.id.sym).onlyReferencedAsTypeRef : boolean
>(<TypeSymbol>this.id.sym).onlyReferencedAsTypeRef : any (error)
>(<TypeSymbol>this.id.sym) : any (error)
><TypeSymbol>this.id.sym : any (error)
>this.id.sym : Symbol
>this.id : Identifier
>this : this
>id : Identifier
>sym : Symbol
>onlyReferencedAsTypeRef : any (error)

                var prevModAliasId = emitter.modAliasId;
>prevModAliasId : any (error)
>emitter.modAliasId : any (error)
>emitter : any (error)
>modAliasId : any (error)

                var prevFirstModAlias = emitter.firstModAlias;
>prevFirstModAlias : any (error)
>emitter.firstModAlias : any (error)
>emitter : any (error)
>firstModAlias : any (error)

                emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

                emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

                emitter.writeToOutput("var " + this.id.actualText + " = ");
>emitter.writeToOutput("var " + this.id.actualText + " = ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"var " + this.id.actualText + " = " : string
>"var " + this.id.actualText : string
>"var " : "var "
>this.id.actualText : string
>this.id : Identifier
>this : this
>id : Identifier
>actualText : string
>" = " : " = "

                emitter.modAliasId = this.id.actualText;
>emitter.modAliasId = this.id.actualText : string
>emitter.modAliasId : any (error)
>emitter : any (error)
>modAliasId : any (error)
>this.id.actualText : string
>this.id : Identifier
>this : this
>id : Identifier
>actualText : string

                emitter.firstModAlias = this.firstAliasedModToString();
>emitter.firstModAlias = this.firstAliasedModToString() : string
>emitter.firstModAlias : any (error)
>emitter : any (error)
>firstModAlias : any (error)
>this.firstAliasedModToString() : string
>this.firstAliasedModToString : () => string
>this : this
>firstAliasedModToString : () => string

                emitter.emitJavascript(this.alias, TokenID.Tilde, false);
>emitter.emitJavascript(this.alias, TokenID.Tilde, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.alias : AST
>this : this
>alias : AST
>TokenID.Tilde : any (error)
>TokenID : any (error)
>Tilde : any (error)
>false : false

                // the dynamic import case will insert the semi-colon automatically
                if (!this.isDynamicImport) {
>!this.isDynamicImport : boolean
>this.isDynamicImport : boolean
>this : this
>isDynamicImport : boolean

                    emitter.writeToOutput(";");
>emitter.writeToOutput(";") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>";" : ";"
                }
                emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false

                emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

                emitter.modAliasId = prevModAliasId;
>emitter.modAliasId = prevModAliasId : any (error)
>emitter.modAliasId : any (error)
>emitter : any (error)
>modAliasId : any (error)
>prevModAliasId : any (error)

                emitter.firstModAlias = prevFirstModAlias;
>emitter.firstModAlias = prevFirstModAlias : any (error)
>emitter.firstModAlias : any (error)
>emitter : any (error)
>firstModAlias : any (error)
>prevFirstModAlias : any (error)
            }
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckImportDecl(this);
>typeFlow.typeCheckImportDecl(this) : any (error)
>typeFlow.typeCheckImportDecl : any (error)
>typeFlow : any (error)
>typeCheckImportDecl : any (error)
>this : this
        }

        public getAliasName(aliasAST?: AST = this.alias) : string {
>getAliasName : (aliasAST?: AST) => string
>aliasAST : AST
>this.alias : AST
>this : this
>alias : AST

            if (aliasAST.nodeType == NodeType.Name) {
>aliasAST.nodeType == NodeType.Name : boolean
>aliasAST.nodeType : any (error)
>aliasAST : AST
>nodeType : any (error)
>NodeType.Name : any (error)
>NodeType : any (error)
>Name : any (error)

                return (<Identifier>aliasAST).actualText;
>(<Identifier>aliasAST).actualText : string
>(<Identifier>aliasAST) : Identifier
><Identifier>aliasAST : Identifier
>aliasAST : AST
>actualText : string

            } else {
                var dotExpr = <BinaryExpression>aliasAST;
>dotExpr : BinaryExpression
><BinaryExpression>aliasAST : BinaryExpression
>aliasAST : AST

                return this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2);
>this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2) : string
>this.getAliasName(dotExpr.operand1) + "." : string
>this.getAliasName(dotExpr.operand1) : string
>this.getAliasName : (aliasAST?: AST) => string
>this : this
>getAliasName : (aliasAST?: AST) => string
>dotExpr.operand1 : AST
>dotExpr : BinaryExpression
>operand1 : AST
>"." : "."
>this.getAliasName(dotExpr.operand2) : string
>this.getAliasName : (aliasAST?: AST) => string
>this : this
>getAliasName : (aliasAST?: AST) => string
>dotExpr.operand2 : AST
>dotExpr : BinaryExpression
>operand2 : AST
            }
        }

        public firstAliasedModToString() {
>firstAliasedModToString : () => string

            if (this.alias.nodeType == NodeType.Name) {
>this.alias.nodeType == NodeType.Name : boolean
>this.alias.nodeType : any (error)
>this.alias : AST
>this : this
>alias : AST
>nodeType : any (error)
>NodeType.Name : any (error)
>NodeType : any (error)
>Name : any (error)

                return (<Identifier>this.alias).actualText;
>(<Identifier>this.alias).actualText : string
>(<Identifier>this.alias) : Identifier
><Identifier>this.alias : Identifier
>this.alias : AST
>this : this
>alias : AST
>actualText : string
            }
            else {
                var dotExpr = <BinaryExpression>this.alias;
>dotExpr : BinaryExpression
><BinaryExpression>this.alias : BinaryExpression
>this.alias : AST
>this : this
>alias : AST

                var firstMod = <Identifier>dotExpr.operand1;
>firstMod : Identifier
><Identifier>dotExpr.operand1 : Identifier
>dotExpr.operand1 : AST
>dotExpr : BinaryExpression
>operand1 : AST

                return firstMod.actualText;
>firstMod.actualText : string
>firstMod : Identifier
>actualText : string
            }
        }
    }

    export class BoundDecl extends AST {
>BoundDecl : BoundDecl
>AST : AST

        public init: AST = null;
>init : AST
>null : null

        public typeExpr: AST = null;
>typeExpr : AST
>null : null

        public varFlags = VarFlags.None;
>varFlags : any (error)
>VarFlags.None : any (error)
>VarFlags : any (error)
>None : any (error)

        public sym: Symbol = null;
>sym : Symbol
>null : null

        constructor (public id: Identifier, nodeType: NodeType, public nestingLevel: number) {
>id : Identifier
>nodeType : any (error)
>nestingLevel : number

            super(nodeType);
>super(nodeType) : void
>super : typeof AST
>nodeType : any (error)
        }

        public isStatementOrExpression() { return true; }
>isStatementOrExpression : () => boolean
>true : true

        public isPrivate() { return hasFlag(this.varFlags, VarFlags.Private); }
>isPrivate : () => any (error)
>hasFlag(this.varFlags, VarFlags.Private) : any (error)
>hasFlag : any (error)
>this.varFlags : any (error)
>this : this
>varFlags : any (error)
>VarFlags.Private : any (error)
>VarFlags : any (error)
>Private : any (error)

        public isPublic() { return hasFlag(this.varFlags, VarFlags.Public); }
>isPublic : () => any (error)
>hasFlag(this.varFlags, VarFlags.Public) : any (error)
>hasFlag : any (error)
>this.varFlags : any (error)
>this : this
>varFlags : any (error)
>VarFlags.Public : any (error)
>VarFlags : any (error)
>Public : any (error)

        public isProperty() { return hasFlag(this.varFlags, VarFlags.Property); }
>isProperty : () => any (error)
>hasFlag(this.varFlags, VarFlags.Property) : any (error)
>hasFlag : any (error)
>this.varFlags : any (error)
>this : this
>varFlags : any (error)
>VarFlags.Property : any (error)
>VarFlags : any (error)
>Property : any (error)

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckBoundDecl(this);
>typeFlow.typeCheckBoundDecl(this) : any (error)
>typeFlow.typeCheckBoundDecl : any (error)
>typeFlow : any (error)
>typeCheckBoundDecl : any (error)
>this : this
        }

        public printLabel() {
>printLabel : () => any

            return this.treeViewLabel();
>this.treeViewLabel() : any
>this.treeViewLabel : () => any
>this : this
>treeViewLabel : () => any
        }
    }

    export class VarDecl extends BoundDecl {
>VarDecl : VarDecl
>BoundDecl : BoundDecl

        constructor (id: Identifier, nest: number) {
>id : Identifier
>nest : number

            super(id, NodeType.VarDecl, nest);
>super(id, NodeType.VarDecl, nest) : void
>super : typeof BoundDecl
>id : Identifier
>NodeType.VarDecl : any (error)
>NodeType : any (error)
>VarDecl : any (error)
>nest : number
        }

        public isAmbient() { return hasFlag(this.varFlags, VarFlags.Ambient); }
>isAmbient : () => any (error)
>hasFlag(this.varFlags, VarFlags.Ambient) : any (error)
>hasFlag : any (error)
>this.varFlags : any (error)
>this : this
>varFlags : any (error)
>VarFlags.Ambient : any (error)
>VarFlags : any (error)
>Ambient : any (error)

        public isExported() { return hasFlag(this.varFlags, VarFlags.Exported); }
>isExported : () => any (error)
>hasFlag(this.varFlags, VarFlags.Exported) : any (error)
>hasFlag : any (error)
>this.varFlags : any (error)
>this : this
>varFlags : any (error)
>VarFlags.Exported : any (error)
>VarFlags : any (error)
>Exported : any (error)

        public isStatic() { return hasFlag(this.varFlags, VarFlags.Static); }
>isStatic : () => any (error)
>hasFlag(this.varFlags, VarFlags.Static) : any (error)
>hasFlag : any (error)
>this.varFlags : any (error)
>this : this
>varFlags : any (error)
>VarFlags.Static : any (error)
>VarFlags : any (error)
>Static : any (error)

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitJavascriptVarDecl(this, tokenId);
>emitter.emitJavascriptVarDecl(this, tokenId) : any (error)
>emitter.emitJavascriptVarDecl : any (error)
>emitter : any (error)
>emitJavascriptVarDecl : any (error)
>this : this
>tokenId : any (error)
        }

        public treeViewLabel() {
>treeViewLabel : () => string

            return "var " + this.id.actualText;
>"var " + this.id.actualText : string
>"var " : "var "
>this.id.actualText : string
>this.id : Identifier
>this : this
>id : Identifier
>actualText : string
        }
    }

    export class ArgDecl extends BoundDecl {
>ArgDecl : ArgDecl
>BoundDecl : BoundDecl

        constructor (id: Identifier) {
>id : Identifier

            super(id, NodeType.ArgDecl, 0);
>super(id, NodeType.ArgDecl, 0) : void
>super : typeof BoundDecl
>id : Identifier
>NodeType.ArgDecl : any (error)
>NodeType : any (error)
>ArgDecl : any (error)
>0 : 0
        }

        public isOptional = false;
>isOptional : boolean
>false : false

        public isOptionalArg() { return this.isOptional || this.init; }
>isOptionalArg : () => true | AST
>this.isOptional || this.init : true | AST
>this.isOptional : boolean
>this : this
>isOptional : boolean
>this.init : AST
>this : this
>init : AST

        public treeViewLabel() {
>treeViewLabel : () => string

            return "arg: " + this.id.actualText;
>"arg: " + this.id.actualText : string
>"arg: " : "arg: "
>this.id.actualText : string
>this.id : Identifier
>this : this
>id : Identifier
>actualText : string
        }

        public parameterPropertySym: FieldSymbol = null;
>parameterPropertySym : any (error)
>null : null

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.writeToOutput(this.id.actualText);
>emitter.writeToOutput(this.id.actualText) : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>this.id.actualText : string
>this.id : Identifier
>this : this
>id : Identifier
>actualText : string

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }
    }

    var internalId = 0;
>internalId : number
>0 : 0

    export class FuncDecl extends AST {
>FuncDecl : FuncDecl
>AST : AST

        public hint: string = null;
>hint : string
>null : null

        public fncFlags = FncFlags.None;
>fncFlags : any (error)
>FncFlags.None : any (error)
>FncFlags : any (error)
>None : any (error)

        public returnTypeAnnotation: AST = null;
>returnTypeAnnotation : AST
>null : null

        public symbols: IHashTable;
>symbols : any (error)

        public variableArgList = false;
>variableArgList : boolean
>false : false

        public signature: Signature;
>signature : any (error)

        public envids: Identifier[];
>envids : Identifier[]

        public jumpRefs: Identifier[] = null;
>jumpRefs : Identifier[]
>null : null

        public internalNameCache: string = null;
>internalNameCache : string
>null : null

        public tmp1Declared = false;
>tmp1Declared : boolean
>false : false

        public enclosingFnc: FuncDecl = null;
>enclosingFnc : FuncDecl
>null : null

        public freeVariables: Symbol[] = [];
>freeVariables : Symbol[]
>[] : undefined[]

        public unitIndex = -1;
>unitIndex : number
>-1 : -1
>1 : 1

        public classDecl: NamedDeclaration = null;
>classDecl : NamedDeclaration
>null : null

        public boundToProperty: VarDecl = null;
>boundToProperty : VarDecl
>null : null

        public isOverload = false;
>isOverload : boolean
>false : false

        public innerStaticFuncs: FuncDecl[] = [];
>innerStaticFuncs : FuncDecl[]
>[] : undefined[]

        public isTargetTypedAsMethod = false;
>isTargetTypedAsMethod : boolean
>false : false

        public isInlineCallLiteral = false;
>isInlineCallLiteral : boolean
>false : false

        public accessorSymbol: Symbol = null;
>accessorSymbol : Symbol
>null : null

        public leftCurlyCount = 0;
>leftCurlyCount : number
>0 : 0

        public rightCurlyCount = 0;
>rightCurlyCount : number
>0 : 0

        public returnStatementsWithExpressions: ReturnStatement[] = [];
>returnStatementsWithExpressions : ReturnStatement[]
>[] : undefined[]

        public scopeType: Type = null; // Type of the FuncDecl, before target typing
>scopeType : any (error)
>null : null

        public endingToken: ASTSpan = null;
>endingToken : ASTSpan
>null : null

        constructor (public name: Identifier, public bod: ASTList, public isConstructor: boolean,
>name : Identifier
>bod : ASTList
>isConstructor : boolean

                     public arguments: ASTList, public vars: ASTList, public scopes: ASTList, public statics: ASTList,
>arguments : ASTList
>vars : ASTList
>scopes : ASTList
>statics : ASTList

            nodeType: number) {
>nodeType : number

            super(nodeType);
>super(nodeType) : void
>super : typeof AST
>nodeType : number
        }

        public internalName(): string {
>internalName : () => string

            if (this.internalNameCache == null) {
>this.internalNameCache == null : boolean
>this.internalNameCache : string
>this : this
>internalNameCache : string
>null : null

                var extName = this.getNameText();
>extName : string
>this.getNameText() : string
>this.getNameText : () => string
>this : this
>getNameText : () => string

                if (extName) {
>extName : string

                    this.internalNameCache = "_internal_" + extName;
>this.internalNameCache = "_internal_" + extName : string
>this.internalNameCache : string
>this : this
>internalNameCache : string
>"_internal_" + extName : string
>"_internal_" : "_internal_"
>extName : string
                }
                else {
                    this.internalNameCache = "_internal_" + internalId++;
>this.internalNameCache = "_internal_" + internalId++ : string
>this.internalNameCache : string
>this : this
>internalNameCache : string
>"_internal_" + internalId++ : string
>"_internal_" : "_internal_"
>internalId++ : number
>internalId : number
                }
            }
            return this.internalNameCache;
>this.internalNameCache : string
>this : this
>internalNameCache : string
        }

        public hasSelfReference() { return hasFlag(this.fncFlags, FncFlags.HasSelfReference); }
>hasSelfReference : () => any (error)
>hasFlag(this.fncFlags, FncFlags.HasSelfReference) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.HasSelfReference : any (error)
>FncFlags : any (error)
>HasSelfReference : any (error)

        public setHasSelfReference() { this.fncFlags |= FncFlags.HasSelfReference; }
>setHasSelfReference : () => void
>this.fncFlags |= FncFlags.HasSelfReference : number
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.HasSelfReference : any (error)
>FncFlags : any (error)
>HasSelfReference : any (error)

        public addCloRef(id: Identifier, sym: Symbol): number {
>addCloRef : (id: Identifier, sym: Symbol) => number
>id : Identifier
>sym : Symbol

            if (this.envids == null) {
>this.envids == null : boolean
>this.envids : Identifier[]
>this : this
>envids : Identifier[]
>null : null

                this.envids = new Identifier[];
>this.envids = new Identifier[] : any
>this.envids : Identifier[]
>this : this
>envids : Identifier[]
>new Identifier[] : any
>Identifier[] : any
>Identifier : typeof Identifier
> : any (error)
            }
            this.envids[this.envids.length] = id;
>this.envids[this.envids.length] = id : Identifier
>this.envids[this.envids.length] : Identifier
>this.envids : Identifier[]
>this : this
>envids : Identifier[]
>this.envids.length : number
>this.envids : Identifier[]
>this : this
>envids : Identifier[]
>length : number
>id : Identifier

            var outerFnc = this.enclosingFnc;
>outerFnc : FuncDecl
>this.enclosingFnc : FuncDecl
>this : this
>enclosingFnc : FuncDecl

            if (sym) {
>sym : Symbol

                while (outerFnc && (outerFnc.type.symbol != sym.container)) {
>outerFnc && (outerFnc.type.symbol != sym.container) : boolean
>outerFnc : FuncDecl
>(outerFnc.type.symbol != sym.container) : boolean
>outerFnc.type.symbol != sym.container : boolean
>outerFnc.type.symbol : any (error)
>outerFnc.type : any (error)
>outerFnc : FuncDecl
>type : any (error)
>symbol : any (error)
>sym.container : any (error)
>sym : Symbol
>container : any (error)

                    outerFnc.addJumpRef(sym);
>outerFnc.addJumpRef(sym) : void
>outerFnc.addJumpRef : (sym: Symbol) => void
>outerFnc : FuncDecl
>addJumpRef : (sym: Symbol) => void
>sym : Symbol

                    outerFnc = outerFnc.enclosingFnc;
>outerFnc = outerFnc.enclosingFnc : FuncDecl
>outerFnc : FuncDecl
>outerFnc.enclosingFnc : FuncDecl
>outerFnc : FuncDecl
>enclosingFnc : FuncDecl
                }
            }
            return this.envids.length - 1;
>this.envids.length - 1 : number
>this.envids.length : number
>this.envids : Identifier[]
>this : this
>envids : Identifier[]
>length : number
>1 : 1
        }

        public addJumpRef(sym: Symbol): void {
>addJumpRef : (sym: Symbol) => void
>sym : Symbol

            if (this.jumpRefs == null) {
>this.jumpRefs == null : boolean
>this.jumpRefs : Identifier[]
>this : this
>jumpRefs : Identifier[]
>null : null

                this.jumpRefs = new Identifier[];
>this.jumpRefs = new Identifier[] : any
>this.jumpRefs : Identifier[]
>this : this
>jumpRefs : Identifier[]
>new Identifier[] : any
>Identifier[] : any
>Identifier : typeof Identifier
> : any (error)
            }
            var id = new Identifier(sym.name);
>id : Identifier
>new Identifier(sym.name) : Identifier
>Identifier : typeof Identifier
>sym.name : any (error)
>sym : Symbol
>name : any (error)

            this.jumpRefs[this.jumpRefs.length] = id;
>this.jumpRefs[this.jumpRefs.length] = id : Identifier
>this.jumpRefs[this.jumpRefs.length] : Identifier
>this.jumpRefs : Identifier[]
>this : this
>jumpRefs : Identifier[]
>this.jumpRefs.length : number
>this.jumpRefs : Identifier[]
>this : this
>jumpRefs : Identifier[]
>length : number
>id : Identifier

            id.sym = sym;
>id.sym = sym : Symbol
>id.sym : Symbol
>id : Identifier
>sym : Symbol
>sym : Symbol

            id.cloId = this.addCloRef(id, null);
>id.cloId = this.addCloRef(id, null) : number
>id.cloId : number
>id : Identifier
>cloId : number
>this.addCloRef(id, null) : number
>this.addCloRef : (id: Identifier, sym: Symbol) => number
>this : this
>addCloRef : (id: Identifier, sym: Symbol) => number
>id : Identifier
>null : null
        }

        public buildControlFlow(): ControlFlowContext {
>buildControlFlow : () => any (error)

            var entry = new BasicBlock();
>entry : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            var exit = new BasicBlock();
>exit : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            var context = new ControlFlowContext(entry, exit);
>context : any (error)
>new ControlFlowContext(entry, exit) : any (error)
>ControlFlowContext : any (error)
>entry : any (error)
>exit : any (error)

            var controlFlowPrefix = (ast: AST, parent: AST, walker: IAstWalker) => {
>controlFlowPrefix : (ast: AST, parent: AST, walker: any (error)) => AST
>(ast: AST, parent: AST, walker: IAstWalker) => {                ast.addToControlFlow(walker.state);                return ast;            } : (ast: AST, parent: AST, walker: any (error)) => AST
>ast : AST
>parent : AST
>walker : any (error)

                ast.addToControlFlow(walker.state);
>ast.addToControlFlow(walker.state) : void
>ast.addToControlFlow : (context: any (error)) => void
>ast : AST
>addToControlFlow : (context: any (error)) => void
>walker.state : any (error)
>walker : any (error)
>state : any (error)

                return ast;
>ast : AST
            }

            var walker = getAstWalkerFactory().getWalker(controlFlowPrefix, null, null, context);
>walker : any (error)
>getAstWalkerFactory().getWalker(controlFlowPrefix, null, null, context) : any (error)
>getAstWalkerFactory().getWalker : any (error)
>getAstWalkerFactory() : any (error)
>getAstWalkerFactory : any (error)
>getWalker : any (error)
>controlFlowPrefix : (ast: AST, parent: AST, walker: any (error)) => AST
>null : null
>null : null
>context : any (error)

            context.walker = walker;
>context.walker = walker : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>walker : any (error)

            walker.walk(this.bod, this);
>walker.walk(this.bod, this) : any (error)
>walker.walk : any (error)
>walker : any (error)
>walk : any (error)
>this.bod : ASTList
>this : this
>bod : ASTList
>this : this

            return context;
>context : any (error)
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckFunction(this);
>typeFlow.typeCheckFunction(this) : any (error)
>typeFlow.typeCheckFunction : any (error)
>typeFlow : any (error)
>typeCheckFunction : any (error)
>this : this
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitJavascriptFunction(this);
>emitter.emitJavascriptFunction(this) : any (error)
>emitter.emitJavascriptFunction : any (error)
>emitter : any (error)
>emitJavascriptFunction : any (error)
>this : this
        }

        public getNameText() {
>getNameText : () => string

            if (this.name) {
>this.name : Identifier
>this : this
>name : Identifier

                return this.name.actualText;
>this.name.actualText : string
>this.name : Identifier
>this : this
>name : Identifier
>actualText : string
            }
            else {
                return this.hint;
>this.hint : string
>this : this
>hint : string
            }
        }

        public isMethod() {
>isMethod : () => boolean

            return (this.fncFlags & FncFlags.Method) != FncFlags.None;
>(this.fncFlags & FncFlags.Method) != FncFlags.None : boolean
>(this.fncFlags & FncFlags.Method) : number
>this.fncFlags & FncFlags.Method : number
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.Method : any (error)
>FncFlags : any (error)
>Method : any (error)
>FncFlags.None : any (error)
>FncFlags : any (error)
>None : any (error)
        }

        public isCallMember() { return hasFlag(this.fncFlags, FncFlags.CallMember); }
>isCallMember : () => any (error)
>hasFlag(this.fncFlags, FncFlags.CallMember) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.CallMember : any (error)
>FncFlags : any (error)
>CallMember : any (error)

        public isConstructMember() { return hasFlag(this.fncFlags, FncFlags.ConstructMember); }
>isConstructMember : () => any (error)
>hasFlag(this.fncFlags, FncFlags.ConstructMember) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.ConstructMember : any (error)
>FncFlags : any (error)
>ConstructMember : any (error)

        public isIndexerMember() { return hasFlag(this.fncFlags, FncFlags.IndexerMember); }
>isIndexerMember : () => any (error)
>hasFlag(this.fncFlags, FncFlags.IndexerMember) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.IndexerMember : any (error)
>FncFlags : any (error)
>IndexerMember : any (error)

        public isSpecialFn() { return this.isCallMember() || this.isIndexerMember() || this.isConstructMember(); }
>isSpecialFn : () => any
>this.isCallMember() || this.isIndexerMember() || this.isConstructMember() : any
>this.isCallMember() || this.isIndexerMember() : any
>this.isCallMember() : any (error)
>this.isCallMember : () => any (error)
>this : this
>isCallMember : () => any (error)
>this.isIndexerMember() : any (error)
>this.isIndexerMember : () => any (error)
>this : this
>isIndexerMember : () => any (error)
>this.isConstructMember() : any (error)
>this.isConstructMember : () => any (error)
>this : this
>isConstructMember : () => any (error)

        public isAnonymousFn() { return this.name === null; }
>isAnonymousFn : () => boolean
>this.name === null : boolean
>this.name : Identifier
>this : this
>name : Identifier
>null : null

        public isAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor) || hasFlag(this.fncFlags, FncFlags.SetAccessor); }
>isAccessor : () => any
>hasFlag(this.fncFlags, FncFlags.GetAccessor) || hasFlag(this.fncFlags, FncFlags.SetAccessor) : any
>hasFlag(this.fncFlags, FncFlags.GetAccessor) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.GetAccessor : any (error)
>FncFlags : any (error)
>GetAccessor : any (error)
>hasFlag(this.fncFlags, FncFlags.SetAccessor) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.SetAccessor : any (error)
>FncFlags : any (error)
>SetAccessor : any (error)

        public isGetAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor); }
>isGetAccessor : () => any (error)
>hasFlag(this.fncFlags, FncFlags.GetAccessor) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.GetAccessor : any (error)
>FncFlags : any (error)
>GetAccessor : any (error)

        public isSetAccessor() { return hasFlag(this.fncFlags, FncFlags.SetAccessor); }
>isSetAccessor : () => any (error)
>hasFlag(this.fncFlags, FncFlags.SetAccessor) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.SetAccessor : any (error)
>FncFlags : any (error)
>SetAccessor : any (error)

        public isAmbient() { return hasFlag(this.fncFlags, FncFlags.Ambient); }
>isAmbient : () => any (error)
>hasFlag(this.fncFlags, FncFlags.Ambient) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.Ambient : any (error)
>FncFlags : any (error)
>Ambient : any (error)

        public isExported() { return hasFlag(this.fncFlags, FncFlags.Exported); }
>isExported : () => any (error)
>hasFlag(this.fncFlags, FncFlags.Exported) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.Exported : any (error)
>FncFlags : any (error)
>Exported : any (error)

        public isPrivate() { return hasFlag(this.fncFlags, FncFlags.Private); }
>isPrivate : () => any (error)
>hasFlag(this.fncFlags, FncFlags.Private) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.Private : any (error)
>FncFlags : any (error)
>Private : any (error)

        public isPublic() { return hasFlag(this.fncFlags, FncFlags.Public); }
>isPublic : () => any (error)
>hasFlag(this.fncFlags, FncFlags.Public) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.Public : any (error)
>FncFlags : any (error)
>Public : any (error)

        public isStatic() { return hasFlag(this.fncFlags, FncFlags.Static); }
>isStatic : () => any (error)
>hasFlag(this.fncFlags, FncFlags.Static) : any (error)
>hasFlag : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.Static : any (error)
>FncFlags : any (error)
>Static : any (error)

        public treeViewLabel() {
>treeViewLabel : () => string

            if (this.name == null) {
>this.name == null : boolean
>this.name : Identifier
>this : this
>name : Identifier
>null : null

                return "funcExpr";
>"funcExpr" : "funcExpr"
            }
            else {
                return "func: " + this.name.actualText
>"func: " + this.name.actualText : string
>"func: " : "func: "
>this.name.actualText : string
>this.name : Identifier
>this : this
>name : Identifier
>actualText : string
            }
        }

        public ClearFlags(): void {
>ClearFlags : () => void

            this.fncFlags = FncFlags.None;
>this.fncFlags = FncFlags.None : any (error)
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.None : any (error)
>FncFlags : any (error)
>None : any (error)
        }

        public isSignature() { return (this.fncFlags & FncFlags.Signature) != FncFlags.None; }
>isSignature : () => boolean
>(this.fncFlags & FncFlags.Signature) != FncFlags.None : boolean
>(this.fncFlags & FncFlags.Signature) : number
>this.fncFlags & FncFlags.Signature : number
>this.fncFlags : any (error)
>this : this
>fncFlags : any (error)
>FncFlags.Signature : any (error)
>FncFlags : any (error)
>Signature : any (error)
>FncFlags.None : any (error)
>FncFlags : any (error)
>None : any (error)

        public hasStaticDeclarations() { return (!this.isConstructor && (this.statics.members.length > 0 || this.innerStaticFuncs.length > 0)); }
>hasStaticDeclarations : () => boolean
>(!this.isConstructor && (this.statics.members.length > 0 || this.innerStaticFuncs.length > 0)) : boolean
>!this.isConstructor && (this.statics.members.length > 0 || this.innerStaticFuncs.length > 0) : boolean
>!this.isConstructor : boolean
>this.isConstructor : boolean
>this : this
>isConstructor : boolean
>(this.statics.members.length > 0 || this.innerStaticFuncs.length > 0) : boolean
>this.statics.members.length > 0 || this.innerStaticFuncs.length > 0 : boolean
>this.statics.members.length > 0 : boolean
>this.statics.members.length : number
>this.statics.members : AST[]
>this.statics : ASTList
>this : this
>statics : ASTList
>members : AST[]
>length : number
>0 : 0
>this.innerStaticFuncs.length > 0 : boolean
>this.innerStaticFuncs.length : number
>this.innerStaticFuncs : FuncDecl[]
>this : this
>innerStaticFuncs : FuncDecl[]
>length : number
>0 : 0
    }

    export class LocationInfo {
>LocationInfo : LocationInfo

        constructor (public filename: string, public lineMap: number[], public unitIndex) { }
>filename : string
>lineMap : number[]
>unitIndex : any
    }

    export var unknownLocationInfo = new LocationInfo("unknown", null, -1);
>unknownLocationInfo : LocationInfo
>new LocationInfo("unknown", null, -1) : LocationInfo
>LocationInfo : typeof LocationInfo
>"unknown" : "unknown"
>null : null
>-1 : -1
>1 : 1

    export class Script extends FuncDecl {
>Script : Script
>FuncDecl : FuncDecl

        public locationInfo: LocationInfo = null;
>locationInfo : LocationInfo
>null : null

        public referencedFiles: IFileReference[] = [];
>referencedFiles : any (error)[]
>[] : undefined[]

        public requiresGlobal = false;
>requiresGlobal : boolean
>false : false

        public requiresInherits = false;
>requiresInherits : boolean
>false : false

        public isResident = false;
>isResident : boolean
>false : false

        public isDeclareFile = false;
>isDeclareFile : boolean
>false : false

        public hasBeenTypeChecked = false;
>hasBeenTypeChecked : boolean
>false : false

        public topLevelMod: ModuleDeclaration = null;
>topLevelMod : ModuleDeclaration
>null : null

        public leftCurlyCount = 0;
>leftCurlyCount : number
>0 : 0

        public rightCurlyCount = 0;
>rightCurlyCount : number
>0 : 0

        public vars: ASTList;
>vars : ASTList

        public scopes: ASTList;
>scopes : ASTList

        // Remember if the script contains Unicode chars, that is needed when generating code for this script object to decide the output file correct encoding.
        public containsUnicodeChar = false;
>containsUnicodeChar : boolean
>false : false

        public containsUnicodeCharInComment = false;
>containsUnicodeCharInComment : boolean
>false : false

        constructor (vars: ASTList, scopes: ASTList) {
>vars : ASTList
>scopes : ASTList

            super(new Identifier("script"), null, false, null, vars, scopes, null, NodeType.Script);
>super(new Identifier("script"), null, false, null, vars, scopes, null, NodeType.Script) : void
>super : typeof FuncDecl
>new Identifier("script") : Identifier
>Identifier : typeof Identifier
>"script" : "script"
>null : null
>false : false
>null : null
>vars : ASTList
>scopes : ASTList
>null : null
>NodeType.Script : any (error)
>NodeType : any (error)
>Script : any (error)

            this.vars = vars;
>this.vars = vars : ASTList
>this.vars : ASTList
>this : this
>vars : ASTList
>vars : ASTList

            this.scopes = scopes;
>this.scopes = scopes : ASTList
>this.scopes : ASTList
>this : this
>scopes : ASTList
>scopes : ASTList
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckScript(this);
>typeFlow.typeCheckScript(this) : any (error)
>typeFlow.typeCheckScript : any (error)
>typeFlow : any (error)
>typeCheckScript : any (error)
>this : this
        }

        public treeViewLabel() {
>treeViewLabel : () => string

            return "Script";
>"Script" : "Script"
        }

        public emitRequired() {
>emitRequired : () => boolean

            if (!this.isDeclareFile && !this.isResident && this.bod) {
>!this.isDeclareFile && !this.isResident && this.bod : ASTList
>!this.isDeclareFile && !this.isResident : boolean
>!this.isDeclareFile : boolean
>this.isDeclareFile : boolean
>this : this
>isDeclareFile : boolean
>!this.isResident : boolean
>this.isResident : boolean
>this : this
>isResident : boolean
>this.bod : ASTList
>this : this
>bod : ASTList

                for (var i = 0, len = this.bod.members.length; i < len; i++) {
>i : number
>0 : 0
>len : number
>this.bod.members.length : number
>this.bod.members : AST[]
>this.bod : ASTList
>this : this
>bod : ASTList
>members : AST[]
>length : number
>i < len : boolean
>i : number
>len : number
>i++ : number
>i : number

                    var stmt = this.bod.members[i];
>stmt : AST
>this.bod.members[i] : AST
>this.bod.members : AST[]
>this.bod : ASTList
>this : this
>bod : ASTList
>members : AST[]
>i : number

                    if (stmt.nodeType == NodeType.ModuleDeclaration) {
>stmt.nodeType == NodeType.ModuleDeclaration : boolean
>stmt.nodeType : any (error)
>stmt : AST
>nodeType : any (error)
>NodeType.ModuleDeclaration : any (error)
>NodeType : any (error)
>ModuleDeclaration : any (error)

                        if (!hasFlag((<ModuleDeclaration>stmt).modFlags, ModuleFlags.ShouldEmitModuleDecl | ModuleFlags.Ambient)) {
>!hasFlag((<ModuleDeclaration>stmt).modFlags, ModuleFlags.ShouldEmitModuleDecl | ModuleFlags.Ambient) : boolean
>hasFlag((<ModuleDeclaration>stmt).modFlags, ModuleFlags.ShouldEmitModuleDecl | ModuleFlags.Ambient) : any (error)
>hasFlag : any (error)
>(<ModuleDeclaration>stmt).modFlags : any (error)
>(<ModuleDeclaration>stmt) : ModuleDeclaration
><ModuleDeclaration>stmt : ModuleDeclaration
>stmt : AST
>modFlags : any (error)
>ModuleFlags.ShouldEmitModuleDecl | ModuleFlags.Ambient : number
>ModuleFlags.ShouldEmitModuleDecl : any (error)
>ModuleFlags : any (error)
>ShouldEmitModuleDecl : any (error)
>ModuleFlags.Ambient : any (error)
>ModuleFlags : any (error)
>Ambient : any (error)

                            return true;
>true : true
                        }
                    }
                    else if (stmt.nodeType == NodeType.ClassDeclaration) {
>stmt.nodeType == NodeType.ClassDeclaration : boolean
>stmt.nodeType : any (error)
>stmt : AST
>nodeType : any (error)
>NodeType.ClassDeclaration : any (error)
>NodeType : any (error)
>ClassDeclaration : any (error)

                        if (!hasFlag((<InterfaceDeclaration>stmt).varFlags, VarFlags.Ambient)) {
>!hasFlag((<InterfaceDeclaration>stmt).varFlags, VarFlags.Ambient) : boolean
>hasFlag((<InterfaceDeclaration>stmt).varFlags, VarFlags.Ambient) : any (error)
>hasFlag : any (error)
>(<InterfaceDeclaration>stmt).varFlags : any (error)
>(<InterfaceDeclaration>stmt) : InterfaceDeclaration
><InterfaceDeclaration>stmt : InterfaceDeclaration
>stmt : AST
>varFlags : any (error)
>VarFlags.Ambient : any (error)
>VarFlags : any (error)
>Ambient : any (error)

                            return true;
>true : true
                        }
                    }
                    else if (stmt.nodeType == NodeType.VarDecl) {
>stmt.nodeType == NodeType.VarDecl : boolean
>stmt.nodeType : any (error)
>stmt : AST
>nodeType : any (error)
>NodeType.VarDecl : any (error)
>NodeType : any (error)
>VarDecl : any (error)

                        if (!hasFlag((<VarDecl>stmt).varFlags, VarFlags.Ambient)) {
>!hasFlag((<VarDecl>stmt).varFlags, VarFlags.Ambient) : boolean
>hasFlag((<VarDecl>stmt).varFlags, VarFlags.Ambient) : any (error)
>hasFlag : any (error)
>(<VarDecl>stmt).varFlags : any (error)
>(<VarDecl>stmt) : VarDecl
><VarDecl>stmt : VarDecl
>stmt : AST
>varFlags : any (error)
>VarFlags.Ambient : any (error)
>VarFlags : any (error)
>Ambient : any (error)

                            return true;
>true : true
                        }
                    }
                    else if (stmt.nodeType == NodeType.FuncDecl) {
>stmt.nodeType == NodeType.FuncDecl : boolean
>stmt.nodeType : any (error)
>stmt : AST
>nodeType : any (error)
>NodeType.FuncDecl : any (error)
>NodeType : any (error)
>FuncDecl : any (error)

                        if (!(<FuncDecl>stmt).isSignature()) {
>!(<FuncDecl>stmt).isSignature() : boolean
>(<FuncDecl>stmt).isSignature() : boolean
>(<FuncDecl>stmt).isSignature : () => boolean
>(<FuncDecl>stmt) : FuncDecl
><FuncDecl>stmt : FuncDecl
>stmt : AST
>isSignature : () => boolean

                            return true;
>true : true
                        }
                    }
                    else if (stmt.nodeType != NodeType.InterfaceDeclaration && stmt.nodeType != NodeType.Empty) {
>stmt.nodeType != NodeType.InterfaceDeclaration && stmt.nodeType != NodeType.Empty : boolean
>stmt.nodeType != NodeType.InterfaceDeclaration : boolean
>stmt.nodeType : any (error)
>stmt : AST
>nodeType : any (error)
>NodeType.InterfaceDeclaration : any (error)
>NodeType : any (error)
>InterfaceDeclaration : any (error)
>stmt.nodeType != NodeType.Empty : boolean
>stmt.nodeType : any (error)
>stmt : AST
>nodeType : any (error)
>NodeType.Empty : any (error)
>NodeType : any (error)
>Empty : any (error)

                        return true;
>true : true
                    }
                }
            }
            return false;
>false : false
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            if (this.emitRequired()) {
>this.emitRequired() : boolean
>this.emitRequired : () => boolean
>this : this
>emitRequired : () => boolean

                emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

                emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

                emitter.emitJavascriptList(this.bod, null, TokenID.Semicolon, true, false, false, true, this.requiresInherits);
>emitter.emitJavascriptList(this.bod, null, TokenID.Semicolon, true, false, false, true, this.requiresInherits) : any (error)
>emitter.emitJavascriptList : any (error)
>emitter : any (error)
>emitJavascriptList : any (error)
>this.bod : ASTList
>this : this
>bod : ASTList
>null : null
>TokenID.Semicolon : any (error)
>TokenID : any (error)
>Semicolon : any (error)
>true : true
>false : false
>false : false
>true : true
>this.requiresInherits : boolean
>this : this
>requiresInherits : boolean

                emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

                emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
            }
        }
    }

    export class NamedDeclaration extends ModuleElement {
>NamedDeclaration : NamedDeclaration
>ModuleElement : ModuleElement

        public leftCurlyCount = 0;
>leftCurlyCount : number
>0 : 0

        public rightCurlyCount = 0;
>rightCurlyCount : number
>0 : 0

        constructor (nodeType: NodeType,
>nodeType : any (error)

                     public name: Identifier,
>name : Identifier

                     public members: ASTList) {
>members : ASTList

            super(nodeType);
>super(nodeType) : void
>super : typeof ModuleElement
>nodeType : any (error)
        }
    }

    export class ModuleDeclaration extends NamedDeclaration {
>ModuleDeclaration : ModuleDeclaration
>NamedDeclaration : NamedDeclaration

        public modFlags = ModuleFlags.ShouldEmitModuleDecl;
>modFlags : any (error)
>ModuleFlags.ShouldEmitModuleDecl : any (error)
>ModuleFlags : any (error)
>ShouldEmitModuleDecl : any (error)

        public mod: ModuleType;
>mod : any (error)

        public prettyName: string;
>prettyName : string

        public amdDependencies: string[] = [];
>amdDependencies : string[]
>[] : undefined[]

        public vars: ASTList;
>vars : ASTList

        public scopes: ASTList;
>scopes : ASTList

        // Remember if the module contains Unicode chars, that is needed for dynamic module as we will generate a file for each.
        public containsUnicodeChar = false;
>containsUnicodeChar : boolean
>false : false

        public containsUnicodeCharInComment = false;
>containsUnicodeCharInComment : boolean
>false : false

        constructor (name: Identifier, members: ASTList, vars: ASTList, scopes: ASTList, public endingToken: ASTSpan) {
>name : Identifier
>members : ASTList
>vars : ASTList
>scopes : ASTList
>endingToken : ASTSpan

            super(NodeType.ModuleDeclaration, name, members);
>super(NodeType.ModuleDeclaration, name, members) : void
>super : typeof NamedDeclaration
>NodeType.ModuleDeclaration : any (error)
>NodeType : any (error)
>ModuleDeclaration : any (error)
>name : Identifier
>members : ASTList

            this.vars = vars;
>this.vars = vars : ASTList
>this.vars : ASTList
>this : this
>vars : ASTList
>vars : ASTList

            this.scopes = scopes;
>this.scopes = scopes : ASTList
>this.scopes : ASTList
>this : this
>scopes : ASTList
>scopes : ASTList

            this.prettyName = this.name.actualText;
>this.prettyName = this.name.actualText : string
>this.prettyName : string
>this : this
>prettyName : string
>this.name.actualText : string
>this.name : Identifier
>this : this
>name : Identifier
>actualText : string
        }

        public isExported() { return hasFlag(this.modFlags, ModuleFlags.Exported); }
>isExported : () => any (error)
>hasFlag(this.modFlags, ModuleFlags.Exported) : any (error)
>hasFlag : any (error)
>this.modFlags : any (error)
>this : this
>modFlags : any (error)
>ModuleFlags.Exported : any (error)
>ModuleFlags : any (error)
>Exported : any (error)

        public isAmbient() { return hasFlag(this.modFlags, ModuleFlags.Ambient); }
>isAmbient : () => any (error)
>hasFlag(this.modFlags, ModuleFlags.Ambient) : any (error)
>hasFlag : any (error)
>this.modFlags : any (error)
>this : this
>modFlags : any (error)
>ModuleFlags.Ambient : any (error)
>ModuleFlags : any (error)
>Ambient : any (error)

        public isEnum() { return hasFlag(this.modFlags, ModuleFlags.IsEnum); }
>isEnum : () => any (error)
>hasFlag(this.modFlags, ModuleFlags.IsEnum) : any (error)
>hasFlag : any (error)
>this.modFlags : any (error)
>this : this
>modFlags : any (error)
>ModuleFlags.IsEnum : any (error)
>ModuleFlags : any (error)
>IsEnum : any (error)

        public recordNonInterface() {
>recordNonInterface : () => void

            this.modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;
>this.modFlags &= ~ModuleFlags.ShouldEmitModuleDecl : number
>this.modFlags : any (error)
>this : this
>modFlags : any (error)
>~ModuleFlags.ShouldEmitModuleDecl : number
>ModuleFlags.ShouldEmitModuleDecl : any (error)
>ModuleFlags : any (error)
>ShouldEmitModuleDecl : any (error)
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckModule(this);
>typeFlow.typeCheckModule(this) : any (error)
>typeFlow.typeCheckModule : any (error)
>typeFlow : any (error)
>typeCheckModule : any (error)
>this : this
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            if (!hasFlag(this.modFlags, ModuleFlags.ShouldEmitModuleDecl)) {
>!hasFlag(this.modFlags, ModuleFlags.ShouldEmitModuleDecl) : boolean
>hasFlag(this.modFlags, ModuleFlags.ShouldEmitModuleDecl) : any (error)
>hasFlag : any (error)
>this.modFlags : any (error)
>this : this
>modFlags : any (error)
>ModuleFlags.ShouldEmitModuleDecl : any (error)
>ModuleFlags : any (error)
>ShouldEmitModuleDecl : any (error)

                emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

                emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

                emitter.emitJavascriptModule(this);
>emitter.emitJavascriptModule(this) : any (error)
>emitter.emitJavascriptModule : any (error)
>emitter : any (error)
>emitJavascriptModule : any (error)
>this : this

                emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

                emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
            }
        }
    }

    export class TypeDeclaration extends NamedDeclaration {
>TypeDeclaration : TypeDeclaration
>NamedDeclaration : NamedDeclaration

        public varFlags = VarFlags.None;
>varFlags : any (error)
>VarFlags.None : any (error)
>VarFlags : any (error)
>None : any (error)

        constructor (nodeType: NodeType,
>nodeType : any (error)

                     name: Identifier,
>name : Identifier

                     public extendsList: ASTList,
>extendsList : ASTList

                     public implementsList: ASTList,
>implementsList : ASTList

                     members: ASTList) {
>members : ASTList

            super(nodeType, name, members);
>super(nodeType, name, members) : void
>super : typeof NamedDeclaration
>nodeType : any (error)
>name : Identifier
>members : ASTList
        }

        public isExported() { 
>isExported : () => any (error)

            return hasFlag(this.varFlags, VarFlags.Exported);
>hasFlag(this.varFlags, VarFlags.Exported) : any (error)
>hasFlag : any (error)
>this.varFlags : any (error)
>this : this
>varFlags : any (error)
>VarFlags.Exported : any (error)
>VarFlags : any (error)
>Exported : any (error)
        }

        public isAmbient() {
>isAmbient : () => any (error)

            return hasFlag(this.varFlags, VarFlags.Ambient);
>hasFlag(this.varFlags, VarFlags.Ambient) : any (error)
>hasFlag : any (error)
>this.varFlags : any (error)
>this : this
>varFlags : any (error)
>VarFlags.Ambient : any (error)
>VarFlags : any (error)
>Ambient : any (error)
        }
    }

    export class ClassDeclaration extends TypeDeclaration {
>ClassDeclaration : ClassDeclaration
>TypeDeclaration : TypeDeclaration

        public knownMemberNames: any = {};
>knownMemberNames : any
>{} : {}

        public constructorDecl: FuncDecl = null;
>constructorDecl : FuncDecl
>null : null

        public constructorNestingLevel = 0;
>constructorNestingLevel : number
>0 : 0

        public endingToken: ASTSpan = null;
>endingToken : ASTSpan
>null : null

        constructor (name: Identifier,
>name : Identifier

                     members: ASTList,
>members : ASTList

                     extendsList: ASTList,
>extendsList : ASTList

                     implementsList: ASTList) {
>implementsList : ASTList

            super(NodeType.ClassDeclaration, name, extendsList, implementsList, members);
>super(NodeType.ClassDeclaration, name, extendsList, implementsList, members) : void
>super : typeof TypeDeclaration
>NodeType.ClassDeclaration : any (error)
>NodeType : any (error)
>ClassDeclaration : any (error)
>name : Identifier
>extendsList : ASTList
>implementsList : ASTList
>members : ASTList
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckClass(this);
>typeFlow.typeCheckClass(this) : any (error)
>typeFlow.typeCheckClass : any (error)
>typeFlow : any (error)
>typeCheckClass : any (error)
>this : this
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitJavascriptClass(this);
>emitter.emitJavascriptClass(this) : any (error)
>emitter.emitJavascriptClass : any (error)
>emitter : any (error)
>emitJavascriptClass : any (error)
>this : this
        }
    }

    export class InterfaceDeclaration extends TypeDeclaration {
>InterfaceDeclaration : InterfaceDeclaration
>TypeDeclaration : TypeDeclaration

        constructor (name: Identifier,
>name : Identifier

                     members: ASTList,
>members : ASTList

                     extendsList: ASTList,
>extendsList : ASTList

                     implementsList: ASTList) {
>implementsList : ASTList

            super(NodeType.InterfaceDeclaration, name, extendsList, implementsList, members);
>super(NodeType.InterfaceDeclaration, name, extendsList, implementsList, members) : void
>super : typeof TypeDeclaration
>NodeType.InterfaceDeclaration : any (error)
>NodeType : any (error)
>InterfaceDeclaration : any (error)
>name : Identifier
>extendsList : ASTList
>implementsList : ASTList
>members : ASTList
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckInterface(this);
>typeFlow.typeCheckInterface(this) : any (error)
>typeFlow.typeCheckInterface : any (error)
>typeFlow : any (error)
>typeCheckInterface : any (error)
>this : this
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean
        }
    }

    export class Statement extends ModuleElement {
>Statement : Statement
>ModuleElement : ModuleElement

        constructor (nodeType: NodeType) {
>nodeType : any (error)

            super(nodeType);
>super(nodeType) : void
>super : typeof ModuleElement
>nodeType : any (error)

            this.flags |= ASTFlags.IsStatement;
>this.flags |= ASTFlags.IsStatement : number
>this.flags : any (error)
>this : this
>flags : any (error)
>ASTFlags.IsStatement : any (error)
>ASTFlags : any (error)
>IsStatement : any (error)
        }

        public isLoop() { return false; }
>isLoop : () => boolean
>false : false

        public isStatementOrExpression() { return true; }
>isStatementOrExpression : () => boolean
>true : true

        public isCompoundStatement() { return this.isLoop(); }
>isCompoundStatement : () => boolean
>this.isLoop() : boolean
>this.isLoop : () => boolean
>this : this
>isLoop : () => boolean

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            this.type = typeFlow.voidType;
>this.type = typeFlow.voidType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.voidType : any (error)
>typeFlow : any (error)
>voidType : any (error)

            return this;
>this : this
        }
    }

    export class LabeledStatement extends Statement {
>LabeledStatement : LabeledStatement
>Statement : Statement

        constructor (public labels: ASTList, public stmt: AST) {
>labels : ASTList
>stmt : AST

            super(NodeType.LabeledStatement);
>super(NodeType.LabeledStatement) : void
>super : typeof Statement
>NodeType.LabeledStatement : any (error)
>NodeType : any (error)
>LabeledStatement : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            if (this.labels) {
>this.labels : ASTList
>this : this
>labels : ASTList

                var labelsLen = this.labels.members.length;
>labelsLen : number
>this.labels.members.length : number
>this.labels.members : AST[]
>this.labels : ASTList
>this : this
>labels : ASTList
>members : AST[]
>length : number

                for (var i = 0; i < labelsLen; i++) {
>i : number
>0 : 0
>i < labelsLen : boolean
>i : number
>labelsLen : number
>i++ : number
>i : number

                    this.labels.members[i].emit(emitter, tokenId, startLine);
>this.labels.members[i].emit(emitter, tokenId, startLine) : void
>this.labels.members[i].emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>this.labels.members[i] : AST
>this.labels.members : AST[]
>this.labels : ASTList
>this : this
>labels : ASTList
>members : AST[]
>i : number
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean
                }
            }
            this.stmt.emit(emitter, tokenId, true);
>this.stmt.emit(emitter, tokenId, true) : void
>this.stmt.emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>this.stmt : AST
>this : this
>stmt : AST
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>true : true

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            typeFlow.typeCheck(this.labels);
>typeFlow.typeCheck(this.labels) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.labels : ASTList
>this : this
>labels : ASTList

            this.stmt = this.stmt.typeCheck(typeFlow);
>this.stmt = this.stmt.typeCheck(typeFlow) : any
>this.stmt : AST
>this : this
>stmt : AST
>this.stmt.typeCheck(typeFlow) : any
>this.stmt.typeCheck : (typeFlow: any (error)) => any
>this.stmt : AST
>this : this
>stmt : AST
>typeCheck : (typeFlow: any (error)) => any
>typeFlow : any (error)

            return this;
>this : this
        }

        public addToControlFlow(context: ControlFlowContext): void {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            var beforeBB = context.current;
>beforeBB : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

            var bb = new BasicBlock();
>bb : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            context.current = bb;
>context.current = bb : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>bb : any (error)

            beforeBB.addSuccessor(bb);
>beforeBB.addSuccessor(bb) : any (error)
>beforeBB.addSuccessor : any (error)
>beforeBB : any (error)
>addSuccessor : any (error)
>bb : any (error)
        }
    }

    export class Block extends Statement {
>Block : Block
>Statement : Statement

        constructor (public statements: ASTList,
>statements : ASTList

                     public isStatementBlock: boolean) {
>isStatementBlock : boolean

            super(NodeType.Block);
>super(NodeType.Block) : void
>super : typeof Statement
>NodeType.Block : any (error)
>NodeType : any (error)
>Block : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            if (this.isStatementBlock) {
>this.isStatementBlock : boolean
>this : this
>isStatementBlock : boolean

                emitter.writeLineToOutput(" {");
>emitter.writeLineToOutput(" {") : any (error)
>emitter.writeLineToOutput : any (error)
>emitter : any (error)
>writeLineToOutput : any (error)
>" {" : " {"

                emitter.indenter.increaseIndent();
>emitter.indenter.increaseIndent() : any (error)
>emitter.indenter.increaseIndent : any (error)
>emitter.indenter : any (error)
>emitter : any (error)
>indenter : any (error)
>increaseIndent : any (error)

            } else {
                emitter.setInVarBlock(this.statements.members.length);
>emitter.setInVarBlock(this.statements.members.length) : any (error)
>emitter.setInVarBlock : any (error)
>emitter : any (error)
>setInVarBlock : any (error)
>this.statements.members.length : number
>this.statements.members : AST[]
>this.statements : ASTList
>this : this
>statements : ASTList
>members : AST[]
>length : number
            }
            var temp = emitter.setInObjectLiteral(false);
>temp : any (error)
>emitter.setInObjectLiteral(false) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>false : false

            if (this.statements) {
>this.statements : ASTList
>this : this
>statements : ASTList

                emitter.emitJavascriptList(this.statements, null, TokenID.Semicolon, true, false, false);
>emitter.emitJavascriptList(this.statements, null, TokenID.Semicolon, true, false, false) : any (error)
>emitter.emitJavascriptList : any (error)
>emitter : any (error)
>emitJavascriptList : any (error)
>this.statements : ASTList
>this : this
>statements : ASTList
>null : null
>TokenID.Semicolon : any (error)
>TokenID : any (error)
>Semicolon : any (error)
>true : true
>false : false
>false : false
            }
            if (this.isStatementBlock) {
>this.isStatementBlock : boolean
>this : this
>isStatementBlock : boolean

                emitter.indenter.decreaseIndent();
>emitter.indenter.decreaseIndent() : any (error)
>emitter.indenter.decreaseIndent : any (error)
>emitter.indenter : any (error)
>emitter : any (error)
>indenter : any (error)
>decreaseIndent : any (error)

                emitter.emitIndent();
>emitter.emitIndent() : any (error)
>emitter.emitIndent : any (error)
>emitter : any (error)
>emitIndent : any (error)

                emitter.writeToOutput("}");
>emitter.writeToOutput("}") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"}" : "}"
            }
            emitter.setInObjectLiteral(temp);
>emitter.setInObjectLiteral(temp) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>temp : any (error)

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public addToControlFlow(context: ControlFlowContext) {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            var afterIfNeeded = new BasicBlock();
>afterIfNeeded : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            context.pushStatement(this, context.current, afterIfNeeded);
>context.pushStatement(this, context.current, afterIfNeeded) : any (error)
>context.pushStatement : any (error)
>context : any (error)
>pushStatement : any (error)
>this : this
>context.current : any (error)
>context : any (error)
>current : any (error)
>afterIfNeeded : any (error)

            if (this.statements) {
>this.statements : ASTList
>this : this
>statements : ASTList

                context.walk(this.statements, this);
>context.walk(this.statements, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.statements : ASTList
>this : this
>statements : ASTList
>this : this
            }
            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false

            context.popStatement();
>context.popStatement() : any (error)
>context.popStatement : any (error)
>context : any (error)
>popStatement : any (error)

            if (afterIfNeeded.predecessors.length > 0) {
>afterIfNeeded.predecessors.length > 0 : boolean
>afterIfNeeded.predecessors.length : any (error)
>afterIfNeeded.predecessors : any (error)
>afterIfNeeded : any (error)
>predecessors : any (error)
>length : any (error)
>0 : 0

                context.current.addSuccessor(afterIfNeeded);
>context.current.addSuccessor(afterIfNeeded) : any (error)
>context.current.addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>addSuccessor : any (error)
>afterIfNeeded : any (error)

                context.current = afterIfNeeded;
>context.current = afterIfNeeded : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>afterIfNeeded : any (error)
            }
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            if (!typeFlow.checker.styleSettings.emptyBlocks) {
>!typeFlow.checker.styleSettings.emptyBlocks : boolean
>typeFlow.checker.styleSettings.emptyBlocks : any (error)
>typeFlow.checker.styleSettings : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>styleSettings : any (error)
>emptyBlocks : any (error)

                if ((this.statements === null) || (this.statements.members.length == 0)) {
>(this.statements === null) || (this.statements.members.length == 0) : boolean
>(this.statements === null) : boolean
>this.statements === null : boolean
>this.statements : ASTList
>this : this
>statements : ASTList
>null : null
>(this.statements.members.length == 0) : boolean
>this.statements.members.length == 0 : boolean
>this.statements.members.length : number
>this.statements.members : AST[]
>this.statements : ASTList
>this : this
>statements : ASTList
>members : AST[]
>length : number
>0 : 0

                    typeFlow.checker.errorReporter.styleError(this, "empty block");
>typeFlow.checker.errorReporter.styleError(this, "empty block") : any (error)
>typeFlow.checker.errorReporter.styleError : any (error)
>typeFlow.checker.errorReporter : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>errorReporter : any (error)
>styleError : any (error)
>this : this
>"empty block" : "empty block"
                }
            }

            typeFlow.typeCheck(this.statements);
>typeFlow.typeCheck(this.statements) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.statements : ASTList
>this : this
>statements : ASTList

            return this;
>this : this
        }
    }

    export class Jump extends Statement {
>Jump : Jump
>Statement : Statement

        public target: string = null;
>target : string
>null : null

        public hasExplicitTarget() { return (this.target); }
>hasExplicitTarget : () => string
>(this.target) : string
>this.target : string
>this : this
>target : string

        public resolvedTarget: Statement = null;
>resolvedTarget : Statement
>null : null

        constructor (nodeType: NodeType) {
>nodeType : any (error)

            super(nodeType);
>super(nodeType) : void
>super : typeof Statement
>nodeType : any (error)
        }

        public setResolvedTarget(parser: Parser, stmt: Statement): boolean {
>setResolvedTarget : (parser: any (error), stmt: Statement) => boolean
>parser : any (error)
>stmt : Statement

            if (stmt.isLoop()) {
>stmt.isLoop() : boolean
>stmt.isLoop : () => boolean
>stmt : Statement
>isLoop : () => boolean

                this.resolvedTarget = stmt;
>this.resolvedTarget = stmt : Statement
>this.resolvedTarget : Statement
>this : this
>resolvedTarget : Statement
>stmt : Statement

                return true;
>true : true
            }
            if (this.nodeType === NodeType.Continue) {
>this.nodeType === NodeType.Continue : boolean
>this.nodeType : any (error)
>this : this
>nodeType : any (error)
>NodeType.Continue : any (error)
>NodeType : any (error)
>Continue : any (error)

                parser.reportParseError("continue statement applies only to loops");
>parser.reportParseError("continue statement applies only to loops") : any (error)
>parser.reportParseError : any (error)
>parser : any (error)
>reportParseError : any (error)
>"continue statement applies only to loops" : "continue statement applies only to loops"

                return false;
>false : false
            }
            else {
                if ((stmt.nodeType == NodeType.Switch) || this.hasExplicitTarget()) {
>(stmt.nodeType == NodeType.Switch) || this.hasExplicitTarget() : string | true
>(stmt.nodeType == NodeType.Switch) : boolean
>stmt.nodeType == NodeType.Switch : boolean
>stmt.nodeType : any (error)
>stmt : Statement
>nodeType : any (error)
>NodeType.Switch : any (error)
>NodeType : any (error)
>Switch : any (error)
>this.hasExplicitTarget() : string
>this.hasExplicitTarget : () => string
>this : this
>hasExplicitTarget : () => string

                    this.resolvedTarget = stmt;
>this.resolvedTarget = stmt : Statement
>this.resolvedTarget : Statement
>this : this
>resolvedTarget : Statement
>stmt : Statement

                    return true;
>true : true
                }
                else {
                    parser.reportParseError("break statement with no label can apply only to a loop or switch statement");
>parser.reportParseError("break statement with no label can apply only to a loop or switch statement") : any (error)
>parser.reportParseError : any (error)
>parser : any (error)
>reportParseError : any (error)
>"break statement with no label can apply only to a loop or switch statement" : "break statement with no label can apply only to a loop or switch statement"

                    return false;
>false : false
                }
            }
        }

        public addToControlFlow(context: ControlFlowContext): void {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            super.addToControlFlow(context);
>super.addToControlFlow(context) : void
>super.addToControlFlow : (context: any (error)) => void
>super : Statement
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            context.unconditionalBranch(this.resolvedTarget, (this.nodeType == NodeType.Continue));
>context.unconditionalBranch(this.resolvedTarget, (this.nodeType == NodeType.Continue)) : any (error)
>context.unconditionalBranch : any (error)
>context : any (error)
>unconditionalBranch : any (error)
>this.resolvedTarget : Statement
>this : this
>resolvedTarget : Statement
>(this.nodeType == NodeType.Continue) : boolean
>this.nodeType == NodeType.Continue : boolean
>this.nodeType : any (error)
>this : this
>nodeType : any (error)
>NodeType.Continue : any (error)
>NodeType : any (error)
>Continue : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            if (this.nodeType == NodeType.Break) {
>this.nodeType == NodeType.Break : boolean
>this.nodeType : any (error)
>this : this
>nodeType : any (error)
>NodeType.Break : any (error)
>NodeType : any (error)
>Break : any (error)

                emitter.writeToOutput("break");
>emitter.writeToOutput("break") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"break" : "break"
            }
            else {
                emitter.writeToOutput("continue");
>emitter.writeToOutput("continue") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"continue" : "continue"
            }
            if (this.hasExplicitTarget()) {
>this.hasExplicitTarget() : string
>this.hasExplicitTarget : () => string
>this : this
>hasExplicitTarget : () => string

                emitter.writeToOutput(" " + this.target);
>emitter.writeToOutput(" " + this.target) : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>" " + this.target : string
>" " : " "
>this.target : string
>this : this
>target : string
            }
            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.writeToOutput(";");
>emitter.writeToOutput(";") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>";" : ";"

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }
    }

    export class WhileStatement extends Statement {
>WhileStatement : WhileStatement
>Statement : Statement

        public body: AST = null;
>body : AST
>null : null

        constructor (public cond: AST) {
>cond : AST

            super(NodeType.While);
>super(NodeType.While) : void
>super : typeof Statement
>NodeType.While : any (error)
>NodeType : any (error)
>While : any (error)
        }

        public isLoop() { return true; }
>isLoop : () => boolean
>true : true

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            var temp = emitter.setInObjectLiteral(false);
>temp : any (error)
>emitter.setInObjectLiteral(false) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>false : false

            emitter.writeToOutput("while(");
>emitter.writeToOutput("while(") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"while(" : "while("

            emitter.emitJavascript(this.cond, TokenID.While, false);
>emitter.emitJavascript(this.cond, TokenID.While, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.cond : AST
>this : this
>cond : AST
>TokenID.While : any (error)
>TokenID : any (error)
>While : any (error)
>false : false

            emitter.writeToOutput(")");
>emitter.writeToOutput(")") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>")" : ")"

            emitter.emitJavascriptStatements(this.body, false, false);
>emitter.emitJavascriptStatements(this.body, false, false) : any (error)
>emitter.emitJavascriptStatements : any (error)
>emitter : any (error)
>emitJavascriptStatements : any (error)
>this.body : AST
>this : this
>body : AST
>false : false
>false : false

            emitter.setInObjectLiteral(temp);
>emitter.setInObjectLiteral(temp) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>temp : any (error)

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckWhile(this);
>typeFlow.typeCheckWhile(this) : any (error)
>typeFlow.typeCheckWhile : any (error)
>typeFlow : any (error)
>typeCheckWhile : any (error)
>this : this
        }

        public addToControlFlow(context: ControlFlowContext): void {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            var loopHeader = context.current;
>loopHeader : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

            var loopStart = new BasicBlock();
>loopStart : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            var afterLoop = new BasicBlock();
>afterLoop : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            loopHeader.addSuccessor(loopStart);
>loopHeader.addSuccessor(loopStart) : any (error)
>loopHeader.addSuccessor : any (error)
>loopHeader : any (error)
>addSuccessor : any (error)
>loopStart : any (error)

            context.current = loopStart;
>context.current = loopStart : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>loopStart : any (error)

            context.addContent(this.cond);
>context.addContent(this.cond) : any (error)
>context.addContent : any (error)
>context : any (error)
>addContent : any (error)
>this.cond : AST
>this : this
>cond : AST

            var condBlock = context.current;
>condBlock : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

            var targetInfo: ITargetInfo = null;
>targetInfo : any (error)
>null : null

            if (this.body) {
>this.body : AST
>this : this
>body : AST

                context.current = new BasicBlock();
>context.current = new BasicBlock() : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

                condBlock.addSuccessor(context.current);
>condBlock.addSuccessor(context.current) : any (error)
>condBlock.addSuccessor : any (error)
>condBlock : any (error)
>addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

                context.pushStatement(this, loopStart, afterLoop);
>context.pushStatement(this, loopStart, afterLoop) : any (error)
>context.pushStatement : any (error)
>context : any (error)
>pushStatement : any (error)
>this : this
>loopStart : any (error)
>afterLoop : any (error)

                context.walk(this.body, this);
>context.walk(this.body, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.body : AST
>this : this
>body : AST
>this : this

                targetInfo = context.popStatement();
>targetInfo = context.popStatement() : any (error)
>targetInfo : any (error)
>context.popStatement() : any (error)
>context.popStatement : any (error)
>context : any (error)
>popStatement : any (error)
            }
            if (!(context.noContinuation)) {
>!(context.noContinuation) : boolean
>(context.noContinuation) : any (error)
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)

                var loopEnd = context.current;
>loopEnd : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

                loopEnd.addSuccessor(loopStart);
>loopEnd.addSuccessor(loopStart) : any (error)
>loopEnd.addSuccessor : any (error)
>loopEnd : any (error)
>addSuccessor : any (error)
>loopStart : any (error)
            }
            context.current = afterLoop;
>context.current = afterLoop : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>afterLoop : any (error)

            condBlock.addSuccessor(afterLoop);
>condBlock.addSuccessor(afterLoop) : any (error)
>condBlock.addSuccessor : any (error)
>condBlock : any (error)
>addSuccessor : any (error)
>afterLoop : any (error)

            // TODO: check for while (true) and then only continue if afterLoop has predecessors
            context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false

            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false
        }
    }

    export class DoWhileStatement extends Statement {
>DoWhileStatement : DoWhileStatement
>Statement : Statement

        public body: AST = null;
>body : AST
>null : null

        public whileAST: AST = null;
>whileAST : AST
>null : null

        public cond: AST = null;
>cond : AST
>null : null

        public isLoop() { return true; }
>isLoop : () => boolean
>true : true

        constructor () {
            super(NodeType.DoWhile);
>super(NodeType.DoWhile) : void
>super : typeof Statement
>NodeType.DoWhile : any (error)
>NodeType : any (error)
>DoWhile : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            var temp = emitter.setInObjectLiteral(false);
>temp : any (error)
>emitter.setInObjectLiteral(false) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>false : false

            emitter.writeToOutput("do");
>emitter.writeToOutput("do") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"do" : "do"

            emitter.emitJavascriptStatements(this.body, true, false);
>emitter.emitJavascriptStatements(this.body, true, false) : any (error)
>emitter.emitJavascriptStatements : any (error)
>emitter : any (error)
>emitJavascriptStatements : any (error)
>this.body : AST
>this : this
>body : AST
>true : true
>false : false

            emitter.recordSourceMappingStart(this.whileAST);
>emitter.recordSourceMappingStart(this.whileAST) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this.whileAST : AST
>this : this
>whileAST : AST

            emitter.writeToOutput("while");
>emitter.writeToOutput("while") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"while" : "while"

            emitter.recordSourceMappingEnd(this.whileAST);
>emitter.recordSourceMappingEnd(this.whileAST) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this.whileAST : AST
>this : this
>whileAST : AST

            emitter.writeToOutput('(');
>emitter.writeToOutput('(') : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>'(' : "("

            emitter.emitJavascript(this.cond, TokenID.CloseParen, false);
>emitter.emitJavascript(this.cond, TokenID.CloseParen, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.cond : AST
>this : this
>cond : AST
>TokenID.CloseParen : any (error)
>TokenID : any (error)
>CloseParen : any (error)
>false : false

            emitter.writeToOutput(")");
>emitter.writeToOutput(")") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>")" : ")"

            emitter.setInObjectLiteral(temp);
>emitter.setInObjectLiteral(temp) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>temp : any (error)

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckDoWhile(this);
>typeFlow.typeCheckDoWhile(this) : any (error)
>typeFlow.typeCheckDoWhile : any (error)
>typeFlow : any (error)
>typeCheckDoWhile : any (error)
>this : this
        }

        public addToControlFlow(context: ControlFlowContext): void {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            var loopHeader = context.current;
>loopHeader : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

            var loopStart = new BasicBlock();
>loopStart : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            var afterLoop = new BasicBlock();
>afterLoop : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            loopHeader.addSuccessor(loopStart);
>loopHeader.addSuccessor(loopStart) : any (error)
>loopHeader.addSuccessor : any (error)
>loopHeader : any (error)
>addSuccessor : any (error)
>loopStart : any (error)

            context.current = loopStart;
>context.current = loopStart : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>loopStart : any (error)

            var targetInfo: ITargetInfo = null;
>targetInfo : any (error)
>null : null

            if (this.body) {
>this.body : AST
>this : this
>body : AST

                context.pushStatement(this, loopStart, afterLoop);
>context.pushStatement(this, loopStart, afterLoop) : any (error)
>context.pushStatement : any (error)
>context : any (error)
>pushStatement : any (error)
>this : this
>loopStart : any (error)
>afterLoop : any (error)

                context.walk(this.body, this);
>context.walk(this.body, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.body : AST
>this : this
>body : AST
>this : this

                targetInfo = context.popStatement();
>targetInfo = context.popStatement() : any (error)
>targetInfo : any (error)
>context.popStatement() : any (error)
>context.popStatement : any (error)
>context : any (error)
>popStatement : any (error)
            }
            if (!(context.noContinuation)) {
>!(context.noContinuation) : boolean
>(context.noContinuation) : any (error)
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)

                var loopEnd = context.current;
>loopEnd : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

                loopEnd.addSuccessor(loopStart);
>loopEnd.addSuccessor(loopStart) : any (error)
>loopEnd.addSuccessor : any (error)
>loopEnd : any (error)
>addSuccessor : any (error)
>loopStart : any (error)

                context.addContent(this.cond);
>context.addContent(this.cond) : any (error)
>context.addContent : any (error)
>context : any (error)
>addContent : any (error)
>this.cond : AST
>this : this
>cond : AST

                // TODO: check for while (true) 
                context.current = afterLoop;
>context.current = afterLoop : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>afterLoop : any (error)

                loopEnd.addSuccessor(afterLoop);
>loopEnd.addSuccessor(afterLoop) : any (error)
>loopEnd.addSuccessor : any (error)
>loopEnd : any (error)
>addSuccessor : any (error)
>afterLoop : any (error)
            }
            else {
                context.addUnreachable(this.cond);
>context.addUnreachable(this.cond) : any (error)
>context.addUnreachable : any (error)
>context : any (error)
>addUnreachable : any (error)
>this.cond : AST
>this : this
>cond : AST
            }
            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false
        }
    }

    export class IfStatement extends Statement {
>IfStatement : IfStatement
>Statement : Statement

        public thenBod: AST;
>thenBod : AST

        public elseBod: AST = null;
>elseBod : AST
>null : null

        public statement: ASTSpan = new ASTSpan();
>statement : ASTSpan
>new ASTSpan() : ASTSpan
>ASTSpan : typeof ASTSpan

        constructor (public cond: AST) {
>cond : AST

            super(NodeType.If);
>super(NodeType.If) : void
>super : typeof Statement
>NodeType.If : any (error)
>NodeType : any (error)
>If : any (error)
        }

        public isCompoundStatement() { return true; }
>isCompoundStatement : () => boolean
>true : true

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            var temp = emitter.setInObjectLiteral(false);
>temp : any (error)
>emitter.setInObjectLiteral(false) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>false : false

            emitter.recordSourceMappingStart(this.statement);
>emitter.recordSourceMappingStart(this.statement) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this.statement : ASTSpan
>this : this
>statement : ASTSpan

            emitter.writeToOutput("if(");
>emitter.writeToOutput("if(") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"if(" : "if("

            emitter.emitJavascript(this.cond, TokenID.If, false);
>emitter.emitJavascript(this.cond, TokenID.If, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.cond : AST
>this : this
>cond : AST
>TokenID.If : any (error)
>TokenID : any (error)
>If : any (error)
>false : false

            emitter.writeToOutput(")");
>emitter.writeToOutput(")") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>")" : ")"

            emitter.recordSourceMappingEnd(this.statement);
>emitter.recordSourceMappingEnd(this.statement) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this.statement : ASTSpan
>this : this
>statement : ASTSpan

            emitter.emitJavascriptStatements(this.thenBod, true, false);
>emitter.emitJavascriptStatements(this.thenBod, true, false) : any (error)
>emitter.emitJavascriptStatements : any (error)
>emitter : any (error)
>emitJavascriptStatements : any (error)
>this.thenBod : AST
>this : this
>thenBod : AST
>true : true
>false : false

            if (this.elseBod) {
>this.elseBod : AST
>this : this
>elseBod : AST

                emitter.writeToOutput(" else");
>emitter.writeToOutput(" else") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>" else" : " else"

                emitter.emitJavascriptStatements(this.elseBod, true, true);
>emitter.emitJavascriptStatements(this.elseBod, true, true) : any (error)
>emitter.emitJavascriptStatements : any (error)
>emitter : any (error)
>emitJavascriptStatements : any (error)
>this.elseBod : AST
>this : this
>elseBod : AST
>true : true
>true : true
            }
            emitter.setInObjectLiteral(temp);
>emitter.setInObjectLiteral(temp) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>temp : any (error)

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckIf(this);
>typeFlow.typeCheckIf(this) : any (error)
>typeFlow.typeCheckIf : any (error)
>typeFlow : any (error)
>typeCheckIf : any (error)
>this : this
        }

        public addToControlFlow(context: ControlFlowContext): void {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            this.cond.addToControlFlow(context);
>this.cond.addToControlFlow(context) : void
>this.cond.addToControlFlow : (context: any (error)) => void
>this.cond : AST
>this : this
>cond : AST
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            var afterIf = new BasicBlock();
>afterIf : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            var beforeIf = context.current;
>beforeIf : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

            context.pushStatement(this, beforeIf, afterIf);
>context.pushStatement(this, beforeIf, afterIf) : any (error)
>context.pushStatement : any (error)
>context : any (error)
>pushStatement : any (error)
>this : this
>beforeIf : any (error)
>afterIf : any (error)

            var hasContinuation = false;
>hasContinuation : boolean
>false : false

            context.current = new BasicBlock();
>context.current = new BasicBlock() : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            beforeIf.addSuccessor(context.current);
>beforeIf.addSuccessor(context.current) : any (error)
>beforeIf.addSuccessor : any (error)
>beforeIf : any (error)
>addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

            context.walk(this.thenBod, this);
>context.walk(this.thenBod, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.thenBod : AST
>this : this
>thenBod : AST
>this : this

            if (!context.noContinuation) {
>!context.noContinuation : boolean
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)

                hasContinuation = true;
>hasContinuation = true : true
>hasContinuation : boolean
>true : true

                context.current.addSuccessor(afterIf);
>context.current.addSuccessor(afterIf) : any (error)
>context.current.addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>addSuccessor : any (error)
>afterIf : any (error)
            }
            if (this.elseBod) {
>this.elseBod : AST
>this : this
>elseBod : AST

                // current block will be thenBod
                context.current = new BasicBlock();
>context.current = new BasicBlock() : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

                context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false

                beforeIf.addSuccessor(context.current);
>beforeIf.addSuccessor(context.current) : any (error)
>beforeIf.addSuccessor : any (error)
>beforeIf : any (error)
>addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

                context.walk(this.elseBod, this);
>context.walk(this.elseBod, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.elseBod : AST
>this : this
>elseBod : AST
>this : this

                if (!context.noContinuation) {
>!context.noContinuation : boolean
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)

                    hasContinuation = true;
>hasContinuation = true : true
>hasContinuation : boolean
>true : true

                    context.current.addSuccessor(afterIf);
>context.current.addSuccessor(afterIf) : any (error)
>context.current.addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>addSuccessor : any (error)
>afterIf : any (error)
                }
                else {
                    // thenBod created continuation for if statement
                    if (hasContinuation) {
>hasContinuation : boolean

                        context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false
                    }
                }
            }
            else {
                beforeIf.addSuccessor(afterIf);
>beforeIf.addSuccessor(afterIf) : any (error)
>beforeIf.addSuccessor : any (error)
>beforeIf : any (error)
>addSuccessor : any (error)
>afterIf : any (error)

                context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false

                hasContinuation = true;
>hasContinuation = true : true
>hasContinuation : boolean
>true : true
            }
            var targetInfo = context.popStatement();
>targetInfo : any (error)
>context.popStatement() : any (error)
>context.popStatement : any (error)
>context : any (error)
>popStatement : any (error)

            if (afterIf.predecessors.length > 0) {
>afterIf.predecessors.length > 0 : boolean
>afterIf.predecessors.length : any (error)
>afterIf.predecessors : any (error)
>afterIf : any (error)
>predecessors : any (error)
>length : any (error)
>0 : 0

                context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false

                hasContinuation = true;
>hasContinuation = true : true
>hasContinuation : boolean
>true : true
            }
            if (hasContinuation) {
>hasContinuation : boolean

                context.current = afterIf;
>context.current = afterIf : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>afterIf : any (error)
            }
            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false
        }
    }

    export class ReturnStatement extends Statement {
>ReturnStatement : ReturnStatement
>Statement : Statement

        public returnExpression: AST = null;
>returnExpression : AST
>null : null

        constructor () {
            super(NodeType.Return);
>super(NodeType.Return) : void
>super : typeof Statement
>NodeType.Return : any (error)
>NodeType : any (error)
>Return : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            var temp = emitter.setInObjectLiteral(false);
>temp : any (error)
>emitter.setInObjectLiteral(false) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>false : false

            if (this.returnExpression) {
>this.returnExpression : AST
>this : this
>returnExpression : AST

                emitter.writeToOutput("return ");
>emitter.writeToOutput("return ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"return " : "return "

                emitter.emitJavascript(this.returnExpression, TokenID.Semicolon, false);
>emitter.emitJavascript(this.returnExpression, TokenID.Semicolon, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.returnExpression : AST
>this : this
>returnExpression : AST
>TokenID.Semicolon : any (error)
>TokenID : any (error)
>Semicolon : any (error)
>false : false
            }
            else {
                emitter.writeToOutput("return;");
>emitter.writeToOutput("return;") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"return;" : "return;"
            }
            emitter.setInObjectLiteral(temp);
>emitter.setInObjectLiteral(temp) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>temp : any (error)

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public addToControlFlow(context: ControlFlowContext): void {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            super.addToControlFlow(context);
>super.addToControlFlow(context) : void
>super.addToControlFlow : (context: any (error)) => void
>super : Statement
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            context.returnStmt();
>context.returnStmt() : any (error)
>context.returnStmt : any (error)
>context : any (error)
>returnStmt : any (error)
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckReturn(this);
>typeFlow.typeCheckReturn(this) : any (error)
>typeFlow.typeCheckReturn : any (error)
>typeFlow : any (error)
>typeCheckReturn : any (error)
>this : this
        }
    }

    export class EndCode extends AST {
>EndCode : EndCode
>AST : AST

        constructor () {
            super(NodeType.EndCode);
>super(NodeType.EndCode) : void
>super : typeof AST
>NodeType.EndCode : any (error)
>NodeType : any (error)
>EndCode : any (error)
        }
    }

    export class ForInStatement extends Statement {
>ForInStatement : ForInStatement
>Statement : Statement

        constructor (public lval: AST, public obj: AST) {
>lval : AST
>obj : AST

            super(NodeType.ForIn);
>super(NodeType.ForIn) : void
>super : typeof Statement
>NodeType.ForIn : any (error)
>NodeType : any (error)
>ForIn : any (error)

            if (this.lval && (this.lval.nodeType == NodeType.VarDecl)) {
>this.lval && (this.lval.nodeType == NodeType.VarDecl) : boolean
>this.lval : AST
>this : this
>lval : AST
>(this.lval.nodeType == NodeType.VarDecl) : boolean
>this.lval.nodeType == NodeType.VarDecl : boolean
>this.lval.nodeType : any (error)
>this.lval : AST
>this : this
>lval : AST
>nodeType : any (error)
>NodeType.VarDecl : any (error)
>NodeType : any (error)
>VarDecl : any (error)

                (<BoundDecl>this.lval).varFlags |= VarFlags.AutoInit;
>(<BoundDecl>this.lval).varFlags |= VarFlags.AutoInit : number
>(<BoundDecl>this.lval).varFlags : any (error)
>(<BoundDecl>this.lval) : BoundDecl
><BoundDecl>this.lval : BoundDecl
>this.lval : AST
>this : this
>lval : AST
>varFlags : any (error)
>VarFlags.AutoInit : any (error)
>VarFlags : any (error)
>AutoInit : any (error)
            }
        }
        public statement: ASTSpan = new ASTSpan();
>statement : ASTSpan
>new ASTSpan() : ASTSpan
>ASTSpan : typeof ASTSpan

        public body: AST;
>body : AST

        public isLoop() { return true; }
>isLoop : () => boolean
>true : true

        public isFiltered() {
>isFiltered : () => boolean

            if (this.body) {
>this.body : AST
>this : this
>body : AST

                var singleItem: AST = null;
>singleItem : AST
>null : null

                if (this.body.nodeType == NodeType.List) {
>this.body.nodeType == NodeType.List : boolean
>this.body.nodeType : any (error)
>this.body : AST
>this : this
>body : AST
>nodeType : any (error)
>NodeType.List : any (error)
>NodeType : any (error)
>List : any (error)

                    var stmts = <ASTList>this.body;
>stmts : ASTList
><ASTList>this.body : ASTList
>this.body : AST
>this : this
>body : AST

                    if (stmts.members.length == 1) {
>stmts.members.length == 1 : boolean
>stmts.members.length : number
>stmts.members : AST[]
>stmts : ASTList
>members : AST[]
>length : number
>1 : 1

                        singleItem = stmts.members[0];
>singleItem = stmts.members[0] : AST
>singleItem : AST
>stmts.members[0] : AST
>stmts.members : AST[]
>stmts : ASTList
>members : AST[]
>0 : 0
                    }
                }
                else {
                    singleItem = this.body;
>singleItem = this.body : AST
>singleItem : AST
>this.body : AST
>this : this
>body : AST
                }
                // match template for filtering 'own' properties from obj
                if (singleItem !== null) {
>singleItem !== null : boolean
>singleItem : AST
>null : null

                    if (singleItem.nodeType == NodeType.Block) {
>singleItem.nodeType == NodeType.Block : boolean
>singleItem.nodeType : any (error)
>singleItem : AST
>nodeType : any (error)
>NodeType.Block : any (error)
>NodeType : any (error)
>Block : any (error)

                        var block = <Block>singleItem;
>block : Block
><Block>singleItem : Block
>singleItem : AST

                        if ((block.statements !== null) && (block.statements.members.length == 1)) {
>(block.statements !== null) && (block.statements.members.length == 1) : boolean
>(block.statements !== null) : boolean
>block.statements !== null : boolean
>block.statements : ASTList
>block : Block
>statements : ASTList
>null : null
>(block.statements.members.length == 1) : boolean
>block.statements.members.length == 1 : boolean
>block.statements.members.length : number
>block.statements.members : AST[]
>block.statements : ASTList
>block : Block
>statements : ASTList
>members : AST[]
>length : number
>1 : 1

                            singleItem = block.statements.members[0];
>singleItem = block.statements.members[0] : AST
>singleItem : AST
>block.statements.members[0] : AST
>block.statements.members : AST[]
>block.statements : ASTList
>block : Block
>statements : ASTList
>members : AST[]
>0 : 0
                        }
                    }
                    if (singleItem.nodeType == NodeType.If) {
>singleItem.nodeType == NodeType.If : boolean
>singleItem.nodeType : any (error)
>singleItem : AST
>nodeType : any (error)
>NodeType.If : any (error)
>NodeType : any (error)
>If : any (error)

                        var cond = (<IfStatement>singleItem).cond;
>cond : AST
>(<IfStatement>singleItem).cond : AST
>(<IfStatement>singleItem) : IfStatement
><IfStatement>singleItem : IfStatement
>singleItem : AST
>cond : AST

                        if (cond.nodeType == NodeType.Call) {
>cond.nodeType == NodeType.Call : boolean
>cond.nodeType : any (error)
>cond : AST
>nodeType : any (error)
>NodeType.Call : any (error)
>NodeType : any (error)
>Call : any (error)

                            var target = (<CallExpression>cond).target;
>target : AST
>(<CallExpression>cond).target : AST
>(<CallExpression>cond) : CallExpression
><CallExpression>cond : CallExpression
>cond : AST
>target : AST

                            if (target.nodeType == NodeType.Dot) {
>target.nodeType == NodeType.Dot : boolean
>target.nodeType : any (error)
>target : AST
>nodeType : any (error)
>NodeType.Dot : any (error)
>NodeType : any (error)
>Dot : any (error)

                                var binex = <BinaryExpression>target;
>binex : BinaryExpression
><BinaryExpression>target : BinaryExpression
>target : AST

                                if ((binex.operand1.nodeType == NodeType.Name) &&
>(binex.operand1.nodeType == NodeType.Name) &&                                    (this.obj.nodeType == NodeType.Name) &&                                    ((<Identifier>binex.operand1).actualText == (<Identifier>this.obj).actualText) : boolean
>(binex.operand1.nodeType == NodeType.Name) &&                                    (this.obj.nodeType == NodeType.Name) : boolean
>(binex.operand1.nodeType == NodeType.Name) : boolean
>binex.operand1.nodeType == NodeType.Name : boolean
>binex.operand1.nodeType : any (error)
>binex.operand1 : AST
>binex : BinaryExpression
>operand1 : AST
>nodeType : any (error)
>NodeType.Name : any (error)
>NodeType : any (error)
>Name : any (error)

                                    (this.obj.nodeType == NodeType.Name) &&
>(this.obj.nodeType == NodeType.Name) : boolean
>this.obj.nodeType == NodeType.Name : boolean
>this.obj.nodeType : any (error)
>this.obj : AST
>this : this
>obj : AST
>nodeType : any (error)
>NodeType.Name : any (error)
>NodeType : any (error)
>Name : any (error)

                                    ((<Identifier>binex.operand1).actualText == (<Identifier>this.obj).actualText)) {
>((<Identifier>binex.operand1).actualText == (<Identifier>this.obj).actualText) : boolean
>(<Identifier>binex.operand1).actualText == (<Identifier>this.obj).actualText : boolean
>(<Identifier>binex.operand1).actualText : string
>(<Identifier>binex.operand1) : Identifier
><Identifier>binex.operand1 : Identifier
>binex.operand1 : AST
>binex : BinaryExpression
>operand1 : AST
>actualText : string
>(<Identifier>this.obj).actualText : string
>(<Identifier>this.obj) : Identifier
><Identifier>this.obj : Identifier
>this.obj : AST
>this : this
>obj : AST
>actualText : string

                                    var prop = <Identifier>binex.operand2;
>prop : Identifier
><Identifier>binex.operand2 : Identifier
>binex.operand2 : AST
>binex : BinaryExpression
>operand2 : AST

                                    if (prop.actualText == "hasOwnProperty") {
>prop.actualText == "hasOwnProperty" : boolean
>prop.actualText : string
>prop : Identifier
>actualText : string
>"hasOwnProperty" : "hasOwnProperty"

                                        var args = (<CallExpression>cond).arguments;
>args : ASTList
>(<CallExpression>cond).arguments : ASTList
>(<CallExpression>cond) : CallExpression
><CallExpression>cond : CallExpression
>cond : AST
>arguments : ASTList

                                        if ((args !== null) && (args.members.length == 1)) {
>(args !== null) && (args.members.length == 1) : boolean
>(args !== null) : boolean
>args !== null : boolean
>args : ASTList
>null : null
>(args.members.length == 1) : boolean
>args.members.length == 1 : boolean
>args.members.length : number
>args.members : AST[]
>args : ASTList
>members : AST[]
>length : number
>1 : 1

                                            var arg = args.members[0];
>arg : AST
>args.members[0] : AST
>args.members : AST[]
>args : ASTList
>members : AST[]
>0 : 0

                                            if ((arg.nodeType == NodeType.Name) &&
>(arg.nodeType == NodeType.Name) &&                                                 (this.lval.nodeType == NodeType.Name) : boolean
>(arg.nodeType == NodeType.Name) : boolean
>arg.nodeType == NodeType.Name : boolean
>arg.nodeType : any (error)
>arg : AST
>nodeType : any (error)
>NodeType.Name : any (error)
>NodeType : any (error)
>Name : any (error)

                                                 (this.lval.nodeType == NodeType.Name)) {
>(this.lval.nodeType == NodeType.Name) : boolean
>this.lval.nodeType == NodeType.Name : boolean
>this.lval.nodeType : any (error)
>this.lval : AST
>this : this
>lval : AST
>nodeType : any (error)
>NodeType.Name : any (error)
>NodeType : any (error)
>Name : any (error)

                                                if (((<Identifier>this.lval).actualText) == (<Identifier>arg).actualText) {
>((<Identifier>this.lval).actualText) == (<Identifier>arg).actualText : boolean
>((<Identifier>this.lval).actualText) : string
>(<Identifier>this.lval).actualText : string
>(<Identifier>this.lval) : Identifier
><Identifier>this.lval : Identifier
>this.lval : AST
>this : this
>lval : AST
>actualText : string
>(<Identifier>arg).actualText : string
>(<Identifier>arg) : Identifier
><Identifier>arg : Identifier
>arg : AST
>actualText : string

                                                    return true;
>true : true
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
>false : false
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            var temp = emitter.setInObjectLiteral(false);
>temp : any (error)
>emitter.setInObjectLiteral(false) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>false : false

            emitter.recordSourceMappingStart(this.statement);
>emitter.recordSourceMappingStart(this.statement) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this.statement : ASTSpan
>this : this
>statement : ASTSpan

            emitter.writeToOutput("for(");
>emitter.writeToOutput("for(") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"for(" : "for("

            emitter.emitJavascript(this.lval, TokenID.For, false);
>emitter.emitJavascript(this.lval, TokenID.For, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.lval : AST
>this : this
>lval : AST
>TokenID.For : any (error)
>TokenID : any (error)
>For : any (error)
>false : false

            emitter.writeToOutput(" in ");
>emitter.writeToOutput(" in ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>" in " : " in "

            emitter.emitJavascript(this.obj, TokenID.For, false);
>emitter.emitJavascript(this.obj, TokenID.For, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.obj : AST
>this : this
>obj : AST
>TokenID.For : any (error)
>TokenID : any (error)
>For : any (error)
>false : false

            emitter.writeToOutput(")");
>emitter.writeToOutput(")") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>")" : ")"

            emitter.recordSourceMappingEnd(this.statement);
>emitter.recordSourceMappingEnd(this.statement) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this.statement : ASTSpan
>this : this
>statement : ASTSpan

            emitter.emitJavascriptStatements(this.body, true, false);
>emitter.emitJavascriptStatements(this.body, true, false) : any (error)
>emitter.emitJavascriptStatements : any (error)
>emitter : any (error)
>emitJavascriptStatements : any (error)
>this.body : AST
>this : this
>body : AST
>true : true
>false : false

            emitter.setInObjectLiteral(temp);
>emitter.setInObjectLiteral(temp) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>temp : any (error)

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            if (typeFlow.checker.styleSettings.forin) {
>typeFlow.checker.styleSettings.forin : any (error)
>typeFlow.checker.styleSettings : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>styleSettings : any (error)
>forin : any (error)

                if (!this.isFiltered()) {
>!this.isFiltered() : boolean
>this.isFiltered() : boolean
>this.isFiltered : () => boolean
>this : this
>isFiltered : () => boolean

                    typeFlow.checker.errorReporter.styleError(this, "no hasOwnProperty filter");
>typeFlow.checker.errorReporter.styleError(this, "no hasOwnProperty filter") : any (error)
>typeFlow.checker.errorReporter.styleError : any (error)
>typeFlow.checker.errorReporter : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>errorReporter : any (error)
>styleError : any (error)
>this : this
>"no hasOwnProperty filter" : "no hasOwnProperty filter"
                }
            }
            return typeFlow.typeCheckForIn(this);
>typeFlow.typeCheckForIn(this) : any (error)
>typeFlow.typeCheckForIn : any (error)
>typeFlow : any (error)
>typeCheckForIn : any (error)
>this : this
        }

        public addToControlFlow(context: ControlFlowContext): void {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            if (this.lval) {
>this.lval : AST
>this : this
>lval : AST

                context.addContent(this.lval);
>context.addContent(this.lval) : any (error)
>context.addContent : any (error)
>context : any (error)
>addContent : any (error)
>this.lval : AST
>this : this
>lval : AST
            }
            if (this.obj) {
>this.obj : AST
>this : this
>obj : AST

                context.addContent(this.obj);
>context.addContent(this.obj) : any (error)
>context.addContent : any (error)
>context : any (error)
>addContent : any (error)
>this.obj : AST
>this : this
>obj : AST
            }

            var loopHeader = context.current;
>loopHeader : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

            var loopStart = new BasicBlock();
>loopStart : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            var afterLoop = new BasicBlock();
>afterLoop : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            loopHeader.addSuccessor(loopStart);
>loopHeader.addSuccessor(loopStart) : any (error)
>loopHeader.addSuccessor : any (error)
>loopHeader : any (error)
>addSuccessor : any (error)
>loopStart : any (error)

            context.current = loopStart;
>context.current = loopStart : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>loopStart : any (error)

            if (this.body) {
>this.body : AST
>this : this
>body : AST

                context.pushStatement(this, loopStart, afterLoop);
>context.pushStatement(this, loopStart, afterLoop) : any (error)
>context.pushStatement : any (error)
>context : any (error)
>pushStatement : any (error)
>this : this
>loopStart : any (error)
>afterLoop : any (error)

                context.walk(this.body, this);
>context.walk(this.body, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.body : AST
>this : this
>body : AST
>this : this

                context.popStatement();
>context.popStatement() : any (error)
>context.popStatement : any (error)
>context : any (error)
>popStatement : any (error)
            }
            if (!(context.noContinuation)) {
>!(context.noContinuation) : boolean
>(context.noContinuation) : any (error)
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)

                var loopEnd = context.current;
>loopEnd : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

                loopEnd.addSuccessor(loopStart);
>loopEnd.addSuccessor(loopStart) : any (error)
>loopEnd.addSuccessor : any (error)
>loopEnd : any (error)
>addSuccessor : any (error)
>loopStart : any (error)
            }
            context.current = afterLoop;
>context.current = afterLoop : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>afterLoop : any (error)

            context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false

            loopHeader.addSuccessor(afterLoop);
>loopHeader.addSuccessor(afterLoop) : any (error)
>loopHeader.addSuccessor : any (error)
>loopHeader : any (error)
>addSuccessor : any (error)
>afterLoop : any (error)

            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false
        }
    }

    export class ForStatement extends Statement {
>ForStatement : ForStatement
>Statement : Statement

        public cond: AST;
>cond : AST

        public body: AST;
>body : AST

        public incr: AST;
>incr : AST

        constructor (public init: AST) {
>init : AST

            super(NodeType.For);
>super(NodeType.For) : void
>super : typeof Statement
>NodeType.For : any (error)
>NodeType : any (error)
>For : any (error)
        }

        public isLoop() { return true; }
>isLoop : () => boolean
>true : true

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            var temp = emitter.setInObjectLiteral(false);
>temp : any (error)
>emitter.setInObjectLiteral(false) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>false : false

            emitter.writeToOutput("for(");
>emitter.writeToOutput("for(") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"for(" : "for("

            if (this.init) {
>this.init : AST
>this : this
>init : AST

                if (this.init.nodeType != NodeType.List) {
>this.init.nodeType != NodeType.List : boolean
>this.init.nodeType : any (error)
>this.init : AST
>this : this
>init : AST
>nodeType : any (error)
>NodeType.List : any (error)
>NodeType : any (error)
>List : any (error)

                    emitter.emitJavascript(this.init, TokenID.For, false);
>emitter.emitJavascript(this.init, TokenID.For, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.init : AST
>this : this
>init : AST
>TokenID.For : any (error)
>TokenID : any (error)
>For : any (error)
>false : false
                }
                else {
                    emitter.setInVarBlock((<ASTList>this.init).members.length); 
>emitter.setInVarBlock((<ASTList>this.init).members.length) : any (error)
>emitter.setInVarBlock : any (error)
>emitter : any (error)
>setInVarBlock : any (error)
>(<ASTList>this.init).members.length : number
>(<ASTList>this.init).members : AST[]
>(<ASTList>this.init) : ASTList
><ASTList>this.init : ASTList
>this.init : AST
>this : this
>init : AST
>members : AST[]
>length : number

                    emitter.emitJavascriptList(this.init, null, TokenID.For, false, false, false);
>emitter.emitJavascriptList(this.init, null, TokenID.For, false, false, false) : any (error)
>emitter.emitJavascriptList : any (error)
>emitter : any (error)
>emitJavascriptList : any (error)
>this.init : AST
>this : this
>init : AST
>null : null
>TokenID.For : any (error)
>TokenID : any (error)
>For : any (error)
>false : false
>false : false
>false : false
                }
            }
            emitter.writeToOutput("; ");
>emitter.writeToOutput("; ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"; " : "; "

            emitter.emitJavascript(this.cond, TokenID.For, false);
>emitter.emitJavascript(this.cond, TokenID.For, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.cond : AST
>this : this
>cond : AST
>TokenID.For : any (error)
>TokenID : any (error)
>For : any (error)
>false : false

            emitter.writeToOutput("; ");
>emitter.writeToOutput("; ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"; " : "; "

            emitter.emitJavascript(this.incr, TokenID.For, false);
>emitter.emitJavascript(this.incr, TokenID.For, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.incr : AST
>this : this
>incr : AST
>TokenID.For : any (error)
>TokenID : any (error)
>For : any (error)
>false : false

            emitter.writeToOutput(")");
>emitter.writeToOutput(")") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>")" : ")"

            emitter.emitJavascriptStatements(this.body, true, false);
>emitter.emitJavascriptStatements(this.body, true, false) : any (error)
>emitter.emitJavascriptStatements : any (error)
>emitter : any (error)
>emitJavascriptStatements : any (error)
>this.body : AST
>this : this
>body : AST
>true : true
>false : false

            emitter.setInObjectLiteral(temp);
>emitter.setInObjectLiteral(temp) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>temp : any (error)

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckFor(this);
>typeFlow.typeCheckFor(this) : any (error)
>typeFlow.typeCheckFor : any (error)
>typeFlow : any (error)
>typeCheckFor : any (error)
>this : this
        }

        public addToControlFlow(context: ControlFlowContext): void {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            if (this.init) {
>this.init : AST
>this : this
>init : AST

                context.addContent(this.init);
>context.addContent(this.init) : any (error)
>context.addContent : any (error)
>context : any (error)
>addContent : any (error)
>this.init : AST
>this : this
>init : AST
            }
            var loopHeader = context.current;
>loopHeader : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

            var loopStart = new BasicBlock();
>loopStart : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            var afterLoop = new BasicBlock();
>afterLoop : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            loopHeader.addSuccessor(loopStart);
>loopHeader.addSuccessor(loopStart) : any (error)
>loopHeader.addSuccessor : any (error)
>loopHeader : any (error)
>addSuccessor : any (error)
>loopStart : any (error)

            context.current = loopStart;
>context.current = loopStart : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>loopStart : any (error)

            var condBlock: BasicBlock = null;
>condBlock : any (error)
>null : null

            var continueTarget = loopStart;
>continueTarget : any (error)
>loopStart : any (error)

            var incrBB: BasicBlock = null;
>incrBB : any (error)
>null : null

            if (this.incr) {
>this.incr : AST
>this : this
>incr : AST

                incrBB = new BasicBlock();
>incrBB = new BasicBlock() : any (error)
>incrBB : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

                continueTarget = incrBB;
>continueTarget = incrBB : any (error)
>continueTarget : any (error)
>incrBB : any (error)
            }
            if (this.cond) {
>this.cond : AST
>this : this
>cond : AST

                condBlock = context.current;
>condBlock = context.current : any (error)
>condBlock : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

                context.addContent(this.cond);
>context.addContent(this.cond) : any (error)
>context.addContent : any (error)
>context : any (error)
>addContent : any (error)
>this.cond : AST
>this : this
>cond : AST

                context.current = new BasicBlock();
>context.current = new BasicBlock() : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

                condBlock.addSuccessor(context.current);
>condBlock.addSuccessor(context.current) : any (error)
>condBlock.addSuccessor : any (error)
>condBlock : any (error)
>addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
            }
            var targetInfo: ITargetInfo = null;
>targetInfo : any (error)
>null : null

            if (this.body) {
>this.body : AST
>this : this
>body : AST

                context.pushStatement(this, continueTarget, afterLoop);
>context.pushStatement(this, continueTarget, afterLoop) : any (error)
>context.pushStatement : any (error)
>context : any (error)
>pushStatement : any (error)
>this : this
>continueTarget : any (error)
>afterLoop : any (error)

                context.walk(this.body, this);
>context.walk(this.body, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.body : AST
>this : this
>body : AST
>this : this

                targetInfo = context.popStatement();
>targetInfo = context.popStatement() : any (error)
>targetInfo : any (error)
>context.popStatement() : any (error)
>context.popStatement : any (error)
>context : any (error)
>popStatement : any (error)
            }
            if (this.incr) {
>this.incr : AST
>this : this
>incr : AST

                if (context.noContinuation) {
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)

                    if (incrBB.predecessors.length == 0) {
>incrBB.predecessors.length == 0 : boolean
>incrBB.predecessors.length : any (error)
>incrBB.predecessors : any (error)
>incrBB : any (error)
>predecessors : any (error)
>length : any (error)
>0 : 0

                        context.addUnreachable(this.incr);
>context.addUnreachable(this.incr) : any (error)
>context.addUnreachable : any (error)
>context : any (error)
>addUnreachable : any (error)
>this.incr : AST
>this : this
>incr : AST
                    }
                }
                else {
                    context.current.addSuccessor(incrBB);
>context.current.addSuccessor(incrBB) : any (error)
>context.current.addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>addSuccessor : any (error)
>incrBB : any (error)

                    context.current = incrBB;
>context.current = incrBB : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>incrBB : any (error)

                    context.addContent(this.incr);
>context.addContent(this.incr) : any (error)
>context.addContent : any (error)
>context : any (error)
>addContent : any (error)
>this.incr : AST
>this : this
>incr : AST
                }
            }
            var loopEnd = context.current;
>loopEnd : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

            if (!(context.noContinuation)) {
>!(context.noContinuation) : boolean
>(context.noContinuation) : any (error)
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)

                loopEnd.addSuccessor(loopStart);
>loopEnd.addSuccessor(loopStart) : any (error)
>loopEnd.addSuccessor : any (error)
>loopEnd : any (error)
>addSuccessor : any (error)
>loopStart : any (error)

            }
            if (condBlock) {
>condBlock : any (error)

                condBlock.addSuccessor(afterLoop);
>condBlock.addSuccessor(afterLoop) : any (error)
>condBlock.addSuccessor : any (error)
>condBlock : any (error)
>addSuccessor : any (error)
>afterLoop : any (error)

                context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false
            }
            if (afterLoop.predecessors.length > 0) {
>afterLoop.predecessors.length > 0 : boolean
>afterLoop.predecessors.length : any (error)
>afterLoop.predecessors : any (error)
>afterLoop : any (error)
>predecessors : any (error)
>length : any (error)
>0 : 0

                context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false

                context.current = afterLoop;
>context.current = afterLoop : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>afterLoop : any (error)
            }
            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false
        }
    }

    export class WithStatement extends Statement {
>WithStatement : WithStatement
>Statement : Statement

        public body: AST;
>body : AST

        public isCompoundStatement() { return true; }
>isCompoundStatement : () => boolean
>true : true

        public withSym: WithSymbol = null;
>withSym : any (error)
>null : null

        constructor (public expr: AST) {
>expr : AST

            super(NodeType.With);
>super(NodeType.With) : void
>super : typeof Statement
>NodeType.With : any (error)
>NodeType : any (error)
>With : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.writeToOutput("with (");
>emitter.writeToOutput("with (") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"with (" : "with ("

            if (this.expr) {
>this.expr : AST
>this : this
>expr : AST

                emitter.emitJavascript(this.expr, TokenID.With, false);
>emitter.emitJavascript(this.expr, TokenID.With, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.expr : AST
>this : this
>expr : AST
>TokenID.With : any (error)
>TokenID : any (error)
>With : any (error)
>false : false
            }

            emitter.writeToOutput(")");
>emitter.writeToOutput(")") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>")" : ")"

            emitter.emitJavascriptStatements(this.body, true, false);
>emitter.emitJavascriptStatements(this.body, true, false) : any (error)
>emitter.emitJavascriptStatements : any (error)
>emitter : any (error)
>emitJavascriptStatements : any (error)
>this.body : AST
>this : this
>body : AST
>true : true
>false : false

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => any (error)
>typeFlow : any (error)

            return typeFlow.typeCheckWith(this);
>typeFlow.typeCheckWith(this) : any (error)
>typeFlow.typeCheckWith : any (error)
>typeFlow : any (error)
>typeCheckWith : any (error)
>this : this
        }
    }

    export class SwitchStatement extends Statement {
>SwitchStatement : SwitchStatement
>Statement : Statement

        public caseList: ASTList;
>caseList : ASTList

        public defaultCase: CaseStatement = null;
>defaultCase : CaseStatement
>null : null

        public statement: ASTSpan = new ASTSpan();
>statement : ASTSpan
>new ASTSpan() : ASTSpan
>ASTSpan : typeof ASTSpan

        constructor (public val: AST) {
>val : AST

            super(NodeType.Switch);
>super(NodeType.Switch) : void
>super : typeof Statement
>NodeType.Switch : any (error)
>NodeType : any (error)
>Switch : any (error)
        }

        public isCompoundStatement() { return true; }
>isCompoundStatement : () => boolean
>true : true

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            var temp = emitter.setInObjectLiteral(false);
>temp : any (error)
>emitter.setInObjectLiteral(false) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>false : false

            emitter.recordSourceMappingStart(this.statement);
>emitter.recordSourceMappingStart(this.statement) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this.statement : ASTSpan
>this : this
>statement : ASTSpan

            emitter.writeToOutput("switch(");
>emitter.writeToOutput("switch(") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"switch(" : "switch("

            emitter.emitJavascript(this.val, TokenID.Identifier, false);
>emitter.emitJavascript(this.val, TokenID.Identifier, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.val : AST
>this : this
>val : AST
>TokenID.Identifier : any (error)
>TokenID : any (error)
>Identifier : any (error)
>false : false

            emitter.writeToOutput(")"); 
>emitter.writeToOutput(")") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>")" : ")"

            emitter.recordSourceMappingEnd(this.statement);
>emitter.recordSourceMappingEnd(this.statement) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this.statement : ASTSpan
>this : this
>statement : ASTSpan

            emitter.writeLineToOutput(" {");
>emitter.writeLineToOutput(" {") : any (error)
>emitter.writeLineToOutput : any (error)
>emitter : any (error)
>writeLineToOutput : any (error)
>" {" : " {"

            emitter.indenter.increaseIndent();
>emitter.indenter.increaseIndent() : any (error)
>emitter.indenter.increaseIndent : any (error)
>emitter.indenter : any (error)
>emitter : any (error)
>indenter : any (error)
>increaseIndent : any (error)

            var casesLen = this.caseList.members.length;
>casesLen : number
>this.caseList.members.length : number
>this.caseList.members : AST[]
>this.caseList : ASTList
>this : this
>caseList : ASTList
>members : AST[]
>length : number

            for (var i = 0; i < casesLen; i++) {
>i : number
>0 : 0
>i < casesLen : boolean
>i : number
>casesLen : number
>i++ : number
>i : number

                var caseExpr = this.caseList.members[i];
>caseExpr : AST
>this.caseList.members[i] : AST
>this.caseList.members : AST[]
>this.caseList : ASTList
>this : this
>caseList : ASTList
>members : AST[]
>i : number

                emitter.emitJavascript(caseExpr, TokenID.Case, true);
>emitter.emitJavascript(caseExpr, TokenID.Case, true) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>caseExpr : AST
>TokenID.Case : any (error)
>TokenID : any (error)
>Case : any (error)
>true : true

                emitter.writeLineToOutput("");
>emitter.writeLineToOutput("") : any (error)
>emitter.writeLineToOutput : any (error)
>emitter : any (error)
>writeLineToOutput : any (error)
>"" : ""
            }
            emitter.indenter.decreaseIndent();
>emitter.indenter.decreaseIndent() : any (error)
>emitter.indenter.decreaseIndent : any (error)
>emitter.indenter : any (error)
>emitter : any (error)
>indenter : any (error)
>decreaseIndent : any (error)

            emitter.emitIndent();
>emitter.emitIndent() : any (error)
>emitter.emitIndent : any (error)
>emitter : any (error)
>emitIndent : any (error)

            emitter.writeToOutput("}");
>emitter.writeToOutput("}") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"}" : "}"

            emitter.setInObjectLiteral(temp);
>emitter.setInObjectLiteral(temp) : any (error)
>emitter.setInObjectLiteral : any (error)
>emitter : any (error)
>setInObjectLiteral : any (error)
>temp : any (error)

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            var len = this.caseList.members.length;
>len : number
>this.caseList.members.length : number
>this.caseList.members : AST[]
>this.caseList : ASTList
>this : this
>caseList : ASTList
>members : AST[]
>length : number

            this.val = typeFlow.typeCheck(this.val);
>this.val = typeFlow.typeCheck(this.val) : any (error)
>this.val : AST
>this : this
>val : AST
>typeFlow.typeCheck(this.val) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.val : AST
>this : this
>val : AST

            for (var i = 0; i < len; i++) {
>i : number
>0 : 0
>i < len : boolean
>i : number
>len : number
>i++ : number
>i : number

                this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]);
>this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]) : any (error)
>this.caseList.members[i] : AST
>this.caseList.members : AST[]
>this.caseList : ASTList
>this : this
>caseList : ASTList
>members : AST[]
>i : number
>typeFlow.typeCheck(this.caseList.members[i]) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.caseList.members[i] : AST
>this.caseList.members : AST[]
>this.caseList : ASTList
>this : this
>caseList : ASTList
>members : AST[]
>i : number
            }
            this.defaultCase = <CaseStatement>typeFlow.typeCheck(this.defaultCase);
>this.defaultCase = <CaseStatement>typeFlow.typeCheck(this.defaultCase) : CaseStatement
>this.defaultCase : CaseStatement
>this : this
>defaultCase : CaseStatement
><CaseStatement>typeFlow.typeCheck(this.defaultCase) : CaseStatement
>typeFlow.typeCheck(this.defaultCase) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.defaultCase : CaseStatement
>this : this
>defaultCase : CaseStatement

            this.type = typeFlow.voidType;
>this.type = typeFlow.voidType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.voidType : any (error)
>typeFlow : any (error)
>voidType : any (error)

            return this;
>this : this
        }

        // if there are break statements that match this switch, then just link cond block with block after switch
        public addToControlFlow(context: ControlFlowContext) {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            var condBlock = context.current;
>condBlock : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

            context.addContent(this.val);
>context.addContent(this.val) : any (error)
>context.addContent : any (error)
>context : any (error)
>addContent : any (error)
>this.val : AST
>this : this
>val : AST

            var execBlock = new BasicBlock();
>execBlock : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            var afterSwitch = new BasicBlock();
>afterSwitch : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            condBlock.addSuccessor(execBlock);
>condBlock.addSuccessor(execBlock) : any (error)
>condBlock.addSuccessor : any (error)
>condBlock : any (error)
>addSuccessor : any (error)
>execBlock : any (error)

            context.pushSwitch(execBlock);
>context.pushSwitch(execBlock) : any (error)
>context.pushSwitch : any (error)
>context : any (error)
>pushSwitch : any (error)
>execBlock : any (error)

            context.current = execBlock;
>context.current = execBlock : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>execBlock : any (error)

            context.pushStatement(this, execBlock, afterSwitch);
>context.pushStatement(this, execBlock, afterSwitch) : any (error)
>context.pushStatement : any (error)
>context : any (error)
>pushStatement : any (error)
>this : this
>execBlock : any (error)
>afterSwitch : any (error)

            context.walk(this.caseList, this);
>context.walk(this.caseList, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.caseList : ASTList
>this : this
>caseList : ASTList
>this : this

            context.popSwitch();
>context.popSwitch() : any (error)
>context.popSwitch : any (error)
>context : any (error)
>popSwitch : any (error)

            var targetInfo = context.popStatement();
>targetInfo : any (error)
>context.popStatement() : any (error)
>context.popStatement : any (error)
>context : any (error)
>popStatement : any (error)

            var hasCondContinuation = (this.defaultCase == null);
>hasCondContinuation : boolean
>(this.defaultCase == null) : boolean
>this.defaultCase == null : boolean
>this.defaultCase : CaseStatement
>this : this
>defaultCase : CaseStatement
>null : null

            if (this.defaultCase == null) {
>this.defaultCase == null : boolean
>this.defaultCase : CaseStatement
>this : this
>defaultCase : CaseStatement
>null : null

                condBlock.addSuccessor(afterSwitch);
>condBlock.addSuccessor(afterSwitch) : any (error)
>condBlock.addSuccessor : any (error)
>condBlock : any (error)
>addSuccessor : any (error)
>afterSwitch : any (error)
            }
            if (afterSwitch.predecessors.length > 0) {
>afterSwitch.predecessors.length > 0 : boolean
>afterSwitch.predecessors.length : any (error)
>afterSwitch.predecessors : any (error)
>afterSwitch : any (error)
>predecessors : any (error)
>length : any (error)
>0 : 0

                context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false

                context.current = afterSwitch;
>context.current = afterSwitch : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>afterSwitch : any (error)
            }
            else {
                context.noContinuation = true;
>context.noContinuation = true : true
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>true : true
            }
            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false
        }
    }

    export class CaseStatement extends Statement {
>CaseStatement : CaseStatement
>Statement : Statement

        public expr: AST = null;
>expr : AST
>null : null

        public body: ASTList;
>body : ASTList

        constructor () {
            super(NodeType.Case);
>super(NodeType.Case) : void
>super : typeof Statement
>NodeType.Case : any (error)
>NodeType : any (error)
>Case : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            if (this.expr) {
>this.expr : AST
>this : this
>expr : AST

                emitter.writeToOutput("case ");
>emitter.writeToOutput("case ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"case " : "case "

                emitter.emitJavascript(this.expr, TokenID.Identifier, false);
>emitter.emitJavascript(this.expr, TokenID.Identifier, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.expr : AST
>this : this
>expr : AST
>TokenID.Identifier : any (error)
>TokenID : any (error)
>Identifier : any (error)
>false : false
            }
            else {
                emitter.writeToOutput("default");
>emitter.writeToOutput("default") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"default" : "default"
            }
            emitter.writeToOutput(":");
>emitter.writeToOutput(":") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>":" : ":"

            emitter.emitJavascriptStatements(this.body, false, false);
>emitter.emitJavascriptStatements(this.body, false, false) : any (error)
>emitter.emitJavascriptStatements : any (error)
>emitter : any (error)
>emitJavascriptStatements : any (error)
>this.body : ASTList
>this : this
>body : ASTList
>false : false
>false : false

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            this.expr = typeFlow.typeCheck(this.expr);
>this.expr = typeFlow.typeCheck(this.expr) : any (error)
>this.expr : AST
>this : this
>expr : AST
>typeFlow.typeCheck(this.expr) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.expr : AST
>this : this
>expr : AST

            typeFlow.typeCheck(this.body);
>typeFlow.typeCheck(this.body) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.body : ASTList
>this : this
>body : ASTList

            this.type = typeFlow.voidType;
>this.type = typeFlow.voidType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.voidType : any (error)
>typeFlow : any (error)
>voidType : any (error)

            return this;
>this : this
        }

        // TODO: more reasoning about unreachable cases (such as duplicate literals as case expressions)
        // for now, assume all cases are reachable, regardless of whether some cases fall through
        public addToControlFlow(context: ControlFlowContext) {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            var execBlock = new BasicBlock();
>execBlock : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            var sw = context.currentSwitch[context.currentSwitch.length - 1];
>sw : any (error)
>context.currentSwitch[context.currentSwitch.length - 1] : any (error)
>context.currentSwitch : any (error)
>context : any (error)
>currentSwitch : any (error)
>context.currentSwitch.length - 1 : number
>context.currentSwitch.length : any (error)
>context.currentSwitch : any (error)
>context : any (error)
>currentSwitch : any (error)
>length : any (error)
>1 : 1

            // TODO: fall-through from previous (+ to end of switch)
            if (this.expr) {
>this.expr : AST
>this : this
>expr : AST

                var exprBlock = new BasicBlock();
>exprBlock : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

                context.current = exprBlock;
>context.current = exprBlock : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>exprBlock : any (error)

                sw.addSuccessor(exprBlock);
>sw.addSuccessor(exprBlock) : any (error)
>sw.addSuccessor : any (error)
>sw : any (error)
>addSuccessor : any (error)
>exprBlock : any (error)

                context.addContent(this.expr);
>context.addContent(this.expr) : any (error)
>context.addContent : any (error)
>context : any (error)
>addContent : any (error)
>this.expr : AST
>this : this
>expr : AST

                exprBlock.addSuccessor(execBlock);
>exprBlock.addSuccessor(execBlock) : any (error)
>exprBlock.addSuccessor : any (error)
>exprBlock : any (error)
>addSuccessor : any (error)
>execBlock : any (error)
            }
            else {
                sw.addSuccessor(execBlock);
>sw.addSuccessor(execBlock) : any (error)
>sw.addSuccessor : any (error)
>sw : any (error)
>addSuccessor : any (error)
>execBlock : any (error)
            }
            context.current = execBlock;
>context.current = execBlock : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>execBlock : any (error)

            if (this.body) {
>this.body : ASTList
>this : this
>body : ASTList

                context.walk(this.body, this);
>context.walk(this.body, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.body : ASTList
>this : this
>body : ASTList
>this : this
            }
            context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false

            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false
        }
    }

    export class TypeReference extends AST {
>TypeReference : TypeReference
>AST : AST

        constructor (public term: AST, public arrayCount: number) {
>term : AST
>arrayCount : number

            super(NodeType.TypeRef);
>super(NodeType.TypeRef) : void
>super : typeof AST
>NodeType.TypeRef : any (error)
>NodeType : any (error)
>TypeRef : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            throw new Error("should not emit a type ref");
>new Error("should not emit a type ref") : Error
>Error : ErrorConstructor
>"should not emit a type ref" : "should not emit a type ref"
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            var prevInTCTR = typeFlow.inTypeRefTypeCheck;
>prevInTCTR : any (error)
>typeFlow.inTypeRefTypeCheck : any (error)
>typeFlow : any (error)
>inTypeRefTypeCheck : any (error)

            typeFlow.inTypeRefTypeCheck = true;
>typeFlow.inTypeRefTypeCheck = true : true
>typeFlow.inTypeRefTypeCheck : any (error)
>typeFlow : any (error)
>inTypeRefTypeCheck : any (error)
>true : true

            var typeLink = getTypeLink(this, typeFlow.checker, true);
>typeLink : any (error)
>getTypeLink(this, typeFlow.checker, true) : any (error)
>getTypeLink : any (error)
>this : this
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>true : true

            typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false);
>typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false) : any (error)
>typeFlow.checker.resolveTypeLink : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>resolveTypeLink : any (error)
>typeFlow.scope : any (error)
>typeFlow : any (error)
>scope : any (error)
>typeLink : any (error)
>false : false

            if (this.term) {
>this.term : AST
>this : this
>term : AST

                typeFlow.typeCheck(this.term);
>typeFlow.typeCheck(this.term) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.term : AST
>this : this
>term : AST
            }

            typeFlow.checkForVoidConstructor(typeLink.type, this);
>typeFlow.checkForVoidConstructor(typeLink.type, this) : any (error)
>typeFlow.checkForVoidConstructor : any (error)
>typeFlow : any (error)
>checkForVoidConstructor : any (error)
>typeLink.type : any (error)
>typeLink : any (error)
>type : any (error)
>this : this

            this.type = typeLink.type;
>this.type = typeLink.type : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeLink.type : any (error)
>typeLink : any (error)
>type : any (error)

            // in error recovery cases, there may not be a term
            if (this.term) {
>this.term : AST
>this : this
>term : AST

                this.term.type = this.type;
>this.term.type = this.type : any (error)
>this.term.type : any (error)
>this.term : AST
>this : this
>term : AST
>type : any (error)
>this.type : any (error)
>this : this
>type : any (error)
            }

            typeFlow.inTypeRefTypeCheck = prevInTCTR;
>typeFlow.inTypeRefTypeCheck = prevInTCTR : any (error)
>typeFlow.inTypeRefTypeCheck : any (error)
>typeFlow : any (error)
>inTypeRefTypeCheck : any (error)
>prevInTCTR : any (error)

            return this;
>this : this
        }
    }

    export class TryFinally extends Statement {
>TryFinally : TryFinally
>Statement : Statement

        constructor (public tryNode: AST, public finallyNode: Finally) {
>tryNode : AST
>finallyNode : Finally

            super(NodeType.TryFinally);
>super(NodeType.TryFinally) : void
>super : typeof Statement
>NodeType.TryFinally : any (error)
>NodeType : any (error)
>TryFinally : any (error)
        }

        public isCompoundStatement() { return true; }
>isCompoundStatement : () => boolean
>true : true

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.emitJavascript(this.tryNode, TokenID.Try, false);
>emitter.emitJavascript(this.tryNode, TokenID.Try, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.tryNode : AST
>this : this
>tryNode : AST
>TokenID.Try : any (error)
>TokenID : any (error)
>Try : any (error)
>false : false

            emitter.emitJavascript(this.finallyNode, TokenID.Finally, false);
>emitter.emitJavascript(this.finallyNode, TokenID.Finally, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.finallyNode : Finally
>this : this
>finallyNode : Finally
>TokenID.Finally : any (error)
>TokenID : any (error)
>Finally : any (error)
>false : false

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            this.tryNode = typeFlow.typeCheck(this.tryNode);
>this.tryNode = typeFlow.typeCheck(this.tryNode) : any (error)
>this.tryNode : AST
>this : this
>tryNode : AST
>typeFlow.typeCheck(this.tryNode) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.tryNode : AST
>this : this
>tryNode : AST

            this.finallyNode = <Finally>typeFlow.typeCheck(this.finallyNode);
>this.finallyNode = <Finally>typeFlow.typeCheck(this.finallyNode) : Finally
>this.finallyNode : Finally
>this : this
>finallyNode : Finally
><Finally>typeFlow.typeCheck(this.finallyNode) : Finally
>typeFlow.typeCheck(this.finallyNode) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.finallyNode : Finally
>this : this
>finallyNode : Finally

            this.type = typeFlow.voidType;
>this.type = typeFlow.voidType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.voidType : any (error)
>typeFlow : any (error)
>voidType : any (error)

            return this;
>this : this
        }

        public addToControlFlow(context: ControlFlowContext) {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            var afterFinally = new BasicBlock();
>afterFinally : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            context.walk(this.tryNode, this);
>context.walk(this.tryNode, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.tryNode : AST
>this : this
>tryNode : AST
>this : this

            var finBlock = new BasicBlock();
>finBlock : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            if (context.current) {
>context.current : any (error)
>context : any (error)
>current : any (error)

                context.current.addSuccessor(finBlock);
>context.current.addSuccessor(finBlock) : any (error)
>context.current.addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>addSuccessor : any (error)
>finBlock : any (error)
            }
            context.current = finBlock;
>context.current = finBlock : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>finBlock : any (error)

            context.pushStatement(this, null, afterFinally);
>context.pushStatement(this, null, afterFinally) : any (error)
>context.pushStatement : any (error)
>context : any (error)
>pushStatement : any (error)
>this : this
>null : null
>afterFinally : any (error)

            context.walk(this.finallyNode, this);
>context.walk(this.finallyNode, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.finallyNode : Finally
>this : this
>finallyNode : Finally
>this : this

            if (!context.noContinuation && context.current) {
>!context.noContinuation && context.current : any
>!context.noContinuation : boolean
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

                context.current.addSuccessor(afterFinally);
>context.current.addSuccessor(afterFinally) : any (error)
>context.current.addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>addSuccessor : any (error)
>afterFinally : any (error)
            }
            if (afterFinally.predecessors.length > 0) {
>afterFinally.predecessors.length > 0 : boolean
>afterFinally.predecessors.length : any (error)
>afterFinally.predecessors : any (error)
>afterFinally : any (error)
>predecessors : any (error)
>length : any (error)
>0 : 0

                context.current = afterFinally;
>context.current = afterFinally : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>afterFinally : any (error)
            }
            else {
                context.noContinuation = true;
>context.noContinuation = true : true
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>true : true
            }
            context.popStatement();
>context.popStatement() : any (error)
>context.popStatement : any (error)
>context : any (error)
>popStatement : any (error)

            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false
        }
    }

    export class TryCatch extends Statement {
>TryCatch : TryCatch
>Statement : Statement

        constructor (public tryNode: Try, public catchNode: Catch) {
>tryNode : Try
>catchNode : Catch

            super(NodeType.TryCatch);
>super(NodeType.TryCatch) : void
>super : typeof Statement
>NodeType.TryCatch : any (error)
>NodeType : any (error)
>TryCatch : any (error)
        }

        public isCompoundStatement() { return true; }
>isCompoundStatement : () => boolean
>true : true

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.emitJavascript(this.tryNode, TokenID.Try, false);
>emitter.emitJavascript(this.tryNode, TokenID.Try, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.tryNode : Try
>this : this
>tryNode : Try
>TokenID.Try : any (error)
>TokenID : any (error)
>Try : any (error)
>false : false

            emitter.emitJavascript(this.catchNode, TokenID.Catch, false);
>emitter.emitJavascript(this.catchNode, TokenID.Catch, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.catchNode : Catch
>this : this
>catchNode : Catch
>TokenID.Catch : any (error)
>TokenID : any (error)
>Catch : any (error)
>false : false

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public addToControlFlow(context: ControlFlowContext) {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            var beforeTry = context.current;
>beforeTry : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

            var tryBlock = new BasicBlock();
>tryBlock : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            beforeTry.addSuccessor(tryBlock);
>beforeTry.addSuccessor(tryBlock) : any (error)
>beforeTry.addSuccessor : any (error)
>beforeTry : any (error)
>addSuccessor : any (error)
>tryBlock : any (error)

            context.current = tryBlock;
>context.current = tryBlock : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>tryBlock : any (error)

            var afterTryCatch = new BasicBlock();
>afterTryCatch : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            context.pushStatement(this, null, afterTryCatch);
>context.pushStatement(this, null, afterTryCatch) : any (error)
>context.pushStatement : any (error)
>context : any (error)
>pushStatement : any (error)
>this : this
>null : null
>afterTryCatch : any (error)

            context.walk(this.tryNode, this);
>context.walk(this.tryNode, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.tryNode : Try
>this : this
>tryNode : Try
>this : this

            if (!context.noContinuation) {
>!context.noContinuation : boolean
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)

                if (context.current) {
>context.current : any (error)
>context : any (error)
>current : any (error)

                    context.current.addSuccessor(afterTryCatch);
>context.current.addSuccessor(afterTryCatch) : any (error)
>context.current.addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>addSuccessor : any (error)
>afterTryCatch : any (error)
                }
            }
            context.current = new BasicBlock();
>context.current = new BasicBlock() : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

            beforeTry.addSuccessor(context.current);
>beforeTry.addSuccessor(context.current) : any (error)
>beforeTry.addSuccessor : any (error)
>beforeTry : any (error)
>addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)

            context.walk(this.catchNode, this);
>context.walk(this.catchNode, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.catchNode : Catch
>this : this
>catchNode : Catch
>this : this

            context.popStatement();
>context.popStatement() : any (error)
>context.popStatement : any (error)
>context : any (error)
>popStatement : any (error)

            if (!context.noContinuation) {
>!context.noContinuation : boolean
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)

                if (context.current) {
>context.current : any (error)
>context : any (error)
>current : any (error)

                    context.current.addSuccessor(afterTryCatch);
>context.current.addSuccessor(afterTryCatch) : any (error)
>context.current.addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>addSuccessor : any (error)
>afterTryCatch : any (error)
                }
            }
            context.current = afterTryCatch;
>context.current = afterTryCatch : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>afterTryCatch : any (error)

            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            this.tryNode = <Try>typeFlow.typeCheck(this.tryNode);
>this.tryNode = <Try>typeFlow.typeCheck(this.tryNode) : Try
>this.tryNode : Try
>this : this
>tryNode : Try
><Try>typeFlow.typeCheck(this.tryNode) : Try
>typeFlow.typeCheck(this.tryNode) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.tryNode : Try
>this : this
>tryNode : Try

            this.catchNode = <Catch>typeFlow.typeCheck(this.catchNode);
>this.catchNode = <Catch>typeFlow.typeCheck(this.catchNode) : Catch
>this.catchNode : Catch
>this : this
>catchNode : Catch
><Catch>typeFlow.typeCheck(this.catchNode) : Catch
>typeFlow.typeCheck(this.catchNode) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.catchNode : Catch
>this : this
>catchNode : Catch

            this.type = typeFlow.voidType;
>this.type = typeFlow.voidType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.voidType : any (error)
>typeFlow : any (error)
>voidType : any (error)

            return this;
>this : this
        }
    }

    export class Try extends Statement {
>Try : Try
>Statement : Statement

        constructor (public body: AST) {
>body : AST

            super(NodeType.Try);
>super(NodeType.Try) : void
>super : typeof Statement
>NodeType.Try : any (error)
>NodeType : any (error)
>Try : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.writeToOutput("try ");
>emitter.writeToOutput("try ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"try " : "try "

            emitter.emitJavascript(this.body, TokenID.Try, false);
>emitter.emitJavascript(this.body, TokenID.Try, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.body : AST
>this : this
>body : AST
>TokenID.Try : any (error)
>TokenID : any (error)
>Try : any (error)
>false : false

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            this.body = typeFlow.typeCheck(this.body);
>this.body = typeFlow.typeCheck(this.body) : any (error)
>this.body : AST
>this : this
>body : AST
>typeFlow.typeCheck(this.body) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.body : AST
>this : this
>body : AST

            return this;
>this : this
        }

        public addToControlFlow(context: ControlFlowContext) {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            if (this.body) {
>this.body : AST
>this : this
>body : AST

                context.walk(this.body, this);
>context.walk(this.body, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.body : AST
>this : this
>body : AST
>this : this
            }
            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false

            context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false
        }
    }

    export class Catch extends Statement {
>Catch : Catch
>Statement : Statement

        constructor (public param: VarDecl, public body: AST) {
>param : VarDecl
>body : AST

            super(NodeType.Catch);
>super(NodeType.Catch) : void
>super : typeof Statement
>NodeType.Catch : any (error)
>NodeType : any (error)
>Catch : any (error)

            if (this.param) {
>this.param : VarDecl
>this : this
>param : VarDecl

                this.param.varFlags |= VarFlags.AutoInit;
>this.param.varFlags |= VarFlags.AutoInit : number
>this.param.varFlags : any (error)
>this.param : VarDecl
>this : this
>param : VarDecl
>varFlags : any (error)
>VarFlags.AutoInit : any (error)
>VarFlags : any (error)
>AutoInit : any (error)
            }
        }
        public statement: ASTSpan = new ASTSpan();
>statement : ASTSpan
>new ASTSpan() : ASTSpan
>ASTSpan : typeof ASTSpan

        public containedScope: SymbolScope = null;
>containedScope : any (error)
>null : null

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.writeToOutput(" ");
>emitter.writeToOutput(" ") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>" " : " "

            emitter.recordSourceMappingStart(this.statement);
>emitter.recordSourceMappingStart(this.statement) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this.statement : ASTSpan
>this : this
>statement : ASTSpan

            emitter.writeToOutput("catch (");
>emitter.writeToOutput("catch (") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"catch (" : "catch ("

            emitter.emitJavascript(this.param, TokenID.OpenParen, false);
>emitter.emitJavascript(this.param, TokenID.OpenParen, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.param : VarDecl
>this : this
>param : VarDecl
>TokenID.OpenParen : any (error)
>TokenID : any (error)
>OpenParen : any (error)
>false : false

            emitter.writeToOutput(")");
>emitter.writeToOutput(")") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>")" : ")"

            emitter.recordSourceMappingEnd(this.statement);
>emitter.recordSourceMappingEnd(this.statement) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this.statement : ASTSpan
>this : this
>statement : ASTSpan

            emitter.emitJavascript(this.body, TokenID.Catch, false);
>emitter.emitJavascript(this.body, TokenID.Catch, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.body : AST
>this : this
>body : AST
>TokenID.Catch : any (error)
>TokenID : any (error)
>Catch : any (error)
>false : false

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public addToControlFlow(context: ControlFlowContext) {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            if (this.param) {
>this.param : VarDecl
>this : this
>param : VarDecl

                context.addContent(this.param);
>context.addContent(this.param) : any (error)
>context.addContent : any (error)
>context : any (error)
>addContent : any (error)
>this.param : VarDecl
>this : this
>param : VarDecl

                var bodBlock = new BasicBlock();
>bodBlock : any (error)
>new BasicBlock() : any (error)
>BasicBlock : any (error)

                context.current.addSuccessor(bodBlock);
>context.current.addSuccessor(bodBlock) : any (error)
>context.current.addSuccessor : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>addSuccessor : any (error)
>bodBlock : any (error)

                context.current = bodBlock;
>context.current = bodBlock : any (error)
>context.current : any (error)
>context : any (error)
>current : any (error)
>bodBlock : any (error)
            }
            if (this.body) {
>this.body : AST
>this : this
>body : AST

                context.walk(this.body, this);
>context.walk(this.body, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.body : AST
>this : this
>body : AST
>this : this
            }
            context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false

            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            var prevScope = typeFlow.scope;
>prevScope : any (error)
>typeFlow.scope : any (error)
>typeFlow : any (error)
>scope : any (error)

            typeFlow.scope = this.containedScope;
>typeFlow.scope = this.containedScope : any (error)
>typeFlow.scope : any (error)
>typeFlow : any (error)
>scope : any (error)
>this.containedScope : any (error)
>this : this
>containedScope : any (error)

            this.param = <VarDecl>typeFlow.typeCheck(this.param);
>this.param = <VarDecl>typeFlow.typeCheck(this.param) : VarDecl
>this.param : VarDecl
>this : this
>param : VarDecl
><VarDecl>typeFlow.typeCheck(this.param) : VarDecl
>typeFlow.typeCheck(this.param) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.param : VarDecl
>this : this
>param : VarDecl

            var exceptVar = new ValueLocation();
>exceptVar : any (error)
>new ValueLocation() : any (error)
>ValueLocation : any (error)

            var varSym = new VariableSymbol((<VarDecl>this.param).id.text,
>varSym : any (error)
>new VariableSymbol((<VarDecl>this.param).id.text,                                          this.param.minChar,                                          typeFlow.checker.locationInfo.unitIndex,                                          exceptVar) : any (error)
>VariableSymbol : any (error)
>(<VarDecl>this.param).id.text : string
>(<VarDecl>this.param).id : Identifier
>(<VarDecl>this.param) : VarDecl
><VarDecl>this.param : VarDecl
>this.param : VarDecl
>this : this
>param : VarDecl
>id : Identifier
>text : string

                                          this.param.minChar,
>this.param.minChar : number
>this.param : VarDecl
>this : this
>param : VarDecl
>minChar : number

                                          typeFlow.checker.locationInfo.unitIndex,
>typeFlow.checker.locationInfo.unitIndex : any (error)
>typeFlow.checker.locationInfo : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>locationInfo : any (error)
>unitIndex : any (error)

                                          exceptVar);
>exceptVar : any (error)

            exceptVar.symbol = varSym;
>exceptVar.symbol = varSym : any (error)
>exceptVar.symbol : any (error)
>exceptVar : any (error)
>symbol : any (error)
>varSym : any (error)

            exceptVar.typeLink = new TypeLink();
>exceptVar.typeLink = new TypeLink() : any (error)
>exceptVar.typeLink : any (error)
>exceptVar : any (error)
>typeLink : any (error)
>new TypeLink() : any (error)
>TypeLink : any (error)

            // var type for now (add syntax for type annotation)
            exceptVar.typeLink.type = typeFlow.anyType;
>exceptVar.typeLink.type = typeFlow.anyType : any (error)
>exceptVar.typeLink.type : any (error)
>exceptVar.typeLink : any (error)
>exceptVar : any (error)
>typeLink : any (error)
>type : any (error)
>typeFlow.anyType : any (error)
>typeFlow : any (error)
>anyType : any (error)

            var thisFnc = typeFlow.thisFnc;
>thisFnc : any (error)
>typeFlow.thisFnc : any (error)
>typeFlow : any (error)
>thisFnc : any (error)

            if (thisFnc && thisFnc.type) {
>thisFnc && thisFnc.type : any
>thisFnc : any (error)
>thisFnc.type : any (error)
>thisFnc : any (error)
>type : any (error)

                exceptVar.symbol.container = thisFnc.type.symbol;
>exceptVar.symbol.container = thisFnc.type.symbol : any (error)
>exceptVar.symbol.container : any (error)
>exceptVar.symbol : any (error)
>exceptVar : any (error)
>symbol : any (error)
>container : any (error)
>thisFnc.type.symbol : any (error)
>thisFnc.type : any (error)
>thisFnc : any (error)
>type : any (error)
>symbol : any (error)
            }
            else {
                exceptVar.symbol.container = null;
>exceptVar.symbol.container = null : null
>exceptVar.symbol.container : any (error)
>exceptVar.symbol : any (error)
>exceptVar : any (error)
>symbol : any (error)
>container : any (error)
>null : null
            }
            this.param.sym = exceptVar.symbol;
>this.param.sym = exceptVar.symbol : any (error)
>this.param.sym : Symbol
>this.param : VarDecl
>this : this
>param : VarDecl
>sym : Symbol
>exceptVar.symbol : any (error)
>exceptVar : any (error)
>symbol : any (error)

            typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol,
>typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol,                                 typeFlow.checker.errorReporter, false, false, false) : any (error)
>typeFlow.scope.enter : any (error)
>typeFlow.scope : any (error)
>typeFlow : any (error)
>scope : any (error)
>enter : any (error)
>exceptVar.symbol.container : any (error)
>exceptVar.symbol : any (error)
>exceptVar : any (error)
>symbol : any (error)
>container : any (error)
>this.param : VarDecl
>this : this
>param : VarDecl
>exceptVar.symbol : any (error)
>exceptVar : any (error)
>symbol : any (error)

                                 typeFlow.checker.errorReporter, false, false, false);
>typeFlow.checker.errorReporter : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>errorReporter : any (error)
>false : false
>false : false
>false : false

            this.body = typeFlow.typeCheck(this.body);
>this.body = typeFlow.typeCheck(this.body) : any (error)
>this.body : AST
>this : this
>body : AST
>typeFlow.typeCheck(this.body) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.body : AST
>this : this
>body : AST

            // if we're in provisional typecheck mode, clean up the symbol entry
            // REVIEW: This is obviously bad form, since we're counting on the internal
            // layout of the symbol table, but this is also the only place where we insert
            // symbols during typecheck
            if (typeFlow.checker.inProvisionalTypecheckMode()) {
>typeFlow.checker.inProvisionalTypecheckMode() : any (error)
>typeFlow.checker.inProvisionalTypecheckMode : any (error)
>typeFlow.checker : any (error)
>typeFlow : any (error)
>checker : any (error)
>inProvisionalTypecheckMode : any (error)

                var table = typeFlow.scope.getTable();
>table : any (error)
>typeFlow.scope.getTable() : any (error)
>typeFlow.scope.getTable : any (error)
>typeFlow.scope : any (error)
>typeFlow : any (error)
>scope : any (error)
>getTable : any (error)

                (<any>table).secondaryTable.table[exceptVar.symbol.name] = undefined;
>(<any>table).secondaryTable.table[exceptVar.symbol.name] = undefined : undefined
>(<any>table).secondaryTable.table[exceptVar.symbol.name] : any
>(<any>table).secondaryTable.table : any
>(<any>table).secondaryTable : any
>(<any>table) : any
><any>table : any
>table : any (error)
>secondaryTable : any
>table : any
>exceptVar.symbol.name : any (error)
>exceptVar.symbol : any (error)
>exceptVar : any (error)
>symbol : any (error)
>name : any (error)
>undefined : undefined
            }
            this.type = typeFlow.voidType;
>this.type = typeFlow.voidType : any (error)
>this.type : any (error)
>this : this
>type : any (error)
>typeFlow.voidType : any (error)
>typeFlow : any (error)
>voidType : any (error)

            typeFlow.scope = prevScope;
>typeFlow.scope = prevScope : any (error)
>typeFlow.scope : any (error)
>typeFlow : any (error)
>scope : any (error)
>prevScope : any (error)

            return this;
>this : this
        }
    }

    export class Finally extends Statement {
>Finally : Finally
>Statement : Statement

        constructor (public body: AST) {
>body : AST

            super(NodeType.Finally);
>super(NodeType.Finally) : void
>super : typeof Statement
>NodeType.Finally : any (error)
>NodeType : any (error)
>Finally : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.writeToOutput("finally");
>emitter.writeToOutput("finally") : any (error)
>emitter.writeToOutput : any (error)
>emitter : any (error)
>writeToOutput : any (error)
>"finally" : "finally"

            emitter.emitJavascript(this.body, TokenID.Finally, false);
>emitter.emitJavascript(this.body, TokenID.Finally, false) : any (error)
>emitter.emitJavascript : any (error)
>emitter : any (error)
>emitJavascript : any (error)
>this.body : AST
>this : this
>body : AST
>TokenID.Finally : any (error)
>TokenID : any (error)
>Finally : any (error)
>false : false

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }

        public addToControlFlow(context: ControlFlowContext) {
>addToControlFlow : (context: any (error)) => void
>context : any (error)

            if (this.body) {
>this.body : AST
>this : this
>body : AST

                context.walk(this.body, this);
>context.walk(this.body, this) : any (error)
>context.walk : any (error)
>context : any (error)
>walk : any (error)
>this.body : AST
>this : this
>body : AST
>this : this
            }
            context.walker.options.goChildren = false;
>context.walker.options.goChildren = false : false
>context.walker.options.goChildren : any (error)
>context.walker.options : any (error)
>context.walker : any (error)
>context : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false

            context.noContinuation = false;
>context.noContinuation = false : false
>context.noContinuation : any (error)
>context : any (error)
>noContinuation : any (error)
>false : false
        }

        public typeCheck(typeFlow: TypeFlow) {
>typeCheck : (typeFlow: any (error)) => this
>typeFlow : any (error)

            this.body = typeFlow.typeCheck(this.body);
>this.body = typeFlow.typeCheck(this.body) : any (error)
>this.body : AST
>this : this
>body : AST
>typeFlow.typeCheck(this.body) : any (error)
>typeFlow.typeCheck : any (error)
>typeFlow : any (error)
>typeCheck : any (error)
>this.body : AST
>this : this
>body : AST

            return this;
>this : this
        }
    }

    export class Comment extends AST {
>Comment : Comment
>AST : AST

        public text: string[] = null;
>text : string[]
>null : null

        constructor (public content: string, public isBlockComment: boolean, public endsLine) {
>content : string
>isBlockComment : boolean
>endsLine : any

            super(NodeType.Comment);
>super(NodeType.Comment) : void
>super : typeof AST
>NodeType.Comment : any (error)
>NodeType : any (error)
>Comment : any (error)
        }

        public getText(): string[] {
>getText : () => string[]

            if (this.text == null) {
>this.text == null : boolean
>this.text : string[]
>this : this
>text : string[]
>null : null

                if (this.isBlockComment) {
>this.isBlockComment : boolean
>this : this
>isBlockComment : boolean

                    this.text = this.content.split("\n");
>this.text = this.content.split("\n") : string[]
>this.text : string[]
>this : this
>text : string[]
>this.content.split("\n") : string[]
>this.content.split : (separator: string | RegExp, limit?: number) => string[]
>this.content : string
>this : this
>content : string
>split : (separator: string | RegExp, limit?: number) => string[]
>"\n" : "\n"

                    for (var i = 0; i < this.text.length; i++) {
>i : number
>0 : 0
>i < this.text.length : boolean
>i : number
>this.text.length : number
>this.text : string[]
>this : this
>text : string[]
>length : number
>i++ : number
>i : number

                        this.text[i] = this.text[i].replace(/^\s+|\s+$/g, '');
>this.text[i] = this.text[i].replace(/^\s+|\s+$/g, '') : string
>this.text[i] : string
>this.text : string[]
>this : this
>text : string[]
>i : number
>this.text[i].replace(/^\s+|\s+$/g, '') : string
>this.text[i].replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>this.text[i] : string
>this.text : string[]
>this : this
>text : string[]
>i : number
>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>/^\s+|\s+$/g : RegExp
>'' : ""
                    }
                }
                else {
                    this.text = [(this.content.replace(/^\s+|\s+$/g, ''))];
>this.text = [(this.content.replace(/^\s+|\s+$/g, ''))] : string[]
>this.text : string[]
>this : this
>text : string[]
>[(this.content.replace(/^\s+|\s+$/g, ''))] : string[]
>(this.content.replace(/^\s+|\s+$/g, '')) : string
>this.content.replace(/^\s+|\s+$/g, '') : string
>this.content.replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>this.content : string
>this : this
>content : string
>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>/^\s+|\s+$/g : RegExp
>'' : ""
                }
            }

            return this.text;
>this.text : string[]
>this : this
>text : string[]
        }
    }

    export class DebuggerStatement extends Statement {
>DebuggerStatement : DebuggerStatement
>Statement : Statement

        constructor () {
            super(NodeType.Debugger);
>super(NodeType.Debugger) : void
>super : typeof Statement
>NodeType.Debugger : any (error)
>NodeType : any (error)
>Debugger : any (error)
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: boolean) {
>emit : (emitter: any (error), tokenId: any (error), startLine: boolean) => void
>emitter : any (error)
>tokenId : any (error)
>startLine : boolean

            emitter.emitParensAndCommentsInPlace(this, true);
>emitter.emitParensAndCommentsInPlace(this, true) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>true : true

            emitter.recordSourceMappingStart(this);
>emitter.recordSourceMappingStart(this) : any (error)
>emitter.recordSourceMappingStart : any (error)
>emitter : any (error)
>recordSourceMappingStart : any (error)
>this : this

            emitter.writeLineToOutput("debugger;");
>emitter.writeLineToOutput("debugger;") : any (error)
>emitter.writeLineToOutput : any (error)
>emitter : any (error)
>writeLineToOutput : any (error)
>"debugger;" : "debugger;"

            emitter.recordSourceMappingEnd(this);
>emitter.recordSourceMappingEnd(this) : any (error)
>emitter.recordSourceMappingEnd : any (error)
>emitter : any (error)
>recordSourceMappingEnd : any (error)
>this : this

            emitter.emitParensAndCommentsInPlace(this, false);
>emitter.emitParensAndCommentsInPlace(this, false) : any (error)
>emitter.emitParensAndCommentsInPlace : any (error)
>emitter : any (error)
>emitParensAndCommentsInPlace : any (error)
>this : this
>false : false
        }
    }
}
