=== tests/cases/compiler/doExpressionMissingPathAnalysis.ts ===
const c = do {
>c : void | 1
>do {    try { 1; } catch {} // catch clause missing val} : void | 1

    try { 1; } catch {} // catch clause missing val
>1 : 1
}

const d = do {
>d : void | 1
>do {    try { } catch { 1; } // try clause missing val} : void | 1

    try { } catch { 1; } // try clause missing val
>1 : 1
}

const e = do {
>e : 1 | 2
>do {    try {1} catch {2} finally {} // this is fine} : 1 | 2

    try {1} catch {2} finally {} // this is fine
>1 : 1
>2 : 2
}

enum F {
>F : F

    A, B
>A : F.A
>B : F.B
}

function f(x: F) {
>f : (x: F) => void
>x : F

    const a = do {
>a : void
>do {        switch (x) { } // empty switch    } : void

        switch (x) { } // empty switch
>x : F
    }
    const b = do {
>b : void
>do {        switch (x) { case F.A: {} } // empty case    } : void

        switch (x) { case F.A: {} } // empty case
>x : F
>F.A : F.A
>F : typeof F
>A : F.A
    }
    const c = do {
>c : 1
>do {        // TODO: it should report, not all cases (F.B) handled / missing a default block        switch (x) { case F.A: 1; }    } : 1

        // TODO: it should report, not all cases (F.B) handled / missing a default block
        switch (x) { case F.A: 1; }
>x : F
>F.A : F.A
>F : typeof F
>A : F.A
>1 : 1
    }
}

const g = do {
>g : void
>do {    console.log('') // void returning functions} : void

    console.log('') // void returning functions
>console.log('') : void
>console.log : (...data: any[]) => void
>console : Console
>log : (...data: any[]) => void
>'' : ""
}
// No problem
const h = do { 1;;;;; }
>h : 1
>do { 1;;;;; } : 1
>1 : 1

// No problem
const i = do { "val"; debugger; }
>i : "val"
>do { "val"; debugger; } : "val"
>"val" : "val"

const j = do { throw new Error(""); }
>j : never
>do { throw new Error(""); } : never
>new Error("") : Error
>Error : ErrorConstructor
>"" : ""

