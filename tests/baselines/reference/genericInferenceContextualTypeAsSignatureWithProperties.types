=== tests/cases/compiler/genericInferenceContextualTypeAsSignatureWithProperties.ts ===
// repro from #52262

const inner = <T extends 'a' | 'b' | 'c'>(cb: (arg: T) => void) => {};
>inner : <T extends "a" | "b" | "c">(cb: (arg: T) => void) => void
><T extends 'a' | 'b' | 'c'>(cb: (arg: T) => void) => {} : <T extends "a" | "b" | "c">(cb: (arg: T) => void) => void
>cb : (arg: T) => void
>arg : T

interface FuncB<T> {
  (arg: T): void;
>arg : T

  x?: string;
>x : string | undefined

};
const outerB = <T,>(func: FuncB<T>, arg: T) => {};
>outerB : <T>(func: FuncB<T>, arg: T) => void
><T,>(func: FuncB<T>, arg: T) => {} : <T>(func: FuncB<T>, arg: T) => void
>func : FuncB<T>
>arg : T

outerB(inner, (arg: 'a' | 'b') => {});
>outerB(inner, (arg: 'a' | 'b') => {}) : void
>outerB : <T>(func: FuncB<T>, arg: T) => void
>inner : <T extends "a" | "b" | "c">(cb: (arg: T) => void) => void
>(arg: 'a' | 'b') => {} : (arg: 'a' | 'b') => void
>arg : "a" | "b"

interface FuncC<T> {
  (arg: T): void;
>arg : T

  x?: T;
>x : T | undefined

};
const outerC = <T,>(func: FuncC<T>, arg: T) => {};
>outerC : <T>(func: FuncC<T>, arg: T) => void
><T,>(func: FuncC<T>, arg: T) => {} : <T>(func: FuncC<T>, arg: T) => void
>func : FuncC<T>
>arg : T

outerC(inner, (arg: 'a' | 'b') => {}); // error
>outerC(inner, (arg: 'a' | 'b') => {}) : void
>outerC : <T>(func: FuncC<T>, arg: T) => void
>inner : <T extends "a" | "b" | "c">(cb: (arg: T) => void) => void
>(arg: 'a' | 'b') => {} : (arg: 'a' | 'b') => void
>arg : "a" | "b"

