=== tests/cases/conformance/parser/ecmascript5/parserRealSource6.ts ===
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='typescript.ts' />

module TypeScript {
>TypeScript : typeof TypeScript

    export class TypeCollectionContext {
>TypeCollectionContext : TypeCollectionContext

        public script: Script = null;
>script : any (error)
>null : null

        constructor (public scopeChain: ScopeChain, public checker: TypeChecker) {
>scopeChain : any (error)
>checker : any (error)
        }
    }

    export class MemberScopeContext {
>MemberScopeContext : MemberScopeContext

        public type: Type = null;
>type : any (error)
>null : null

        public ast: AST = null;
>ast : any (error)
>null : null

        public scope: SymbolScope;
>scope : any (error)

        public options = new AstWalkOptions();
>options : any (error)
>new AstWalkOptions() : any (error)
>AstWalkOptions : any (error)

        constructor (public flow: TypeFlow, public pos: number, public matchFlag: ASTFlags) {
>flow : any (error)
>pos : number
>matchFlag : any (error)
        }
    }

    export class EnclosingScopeContext {
>EnclosingScopeContext : EnclosingScopeContext

        public scopeGetter: () => SymbolScope = null;
>scopeGetter : () => any (error)
>null : null

        public objectLiteralScopeGetter: () => SymbolScope = null;
>objectLiteralScopeGetter : () => any (error)
>null : null

        public scopeStartAST: AST = null;
>scopeStartAST : any (error)
>null : null

        public skipNextFuncDeclForClass = false;
>skipNextFuncDeclForClass : boolean
>false : false

        public deepestModuleDecl: ModuleDeclaration = null;
>deepestModuleDecl : any (error)
>null : null

        public enclosingClassDecl: TypeDeclaration = null;
>enclosingClassDecl : any (error)
>null : null

        public enclosingObjectLit: UnaryExpression = null;
>enclosingObjectLit : any (error)
>null : null

        public publicsOnly = true;
>publicsOnly : boolean
>true : true

        public useFullAst = false;
>useFullAst : boolean
>false : false

        private scriptFragment: Script;
>scriptFragment : any (error)

        constructor (public logger: ILogger,
>logger : any (error)

                    public script: Script,
>script : any (error)

                    public text: ISourceText,
>text : any (error)

                    public pos: number,
>pos : number

                    public isMemberCompletion: boolean) {
>isMemberCompletion : boolean
        }

        public getScope(): SymbolScope {
>getScope : () => any (error)

            return this.scopeGetter();
>this.scopeGetter() : any (error)
>this.scopeGetter : () => any (error)
>this : this
>scopeGetter : () => any (error)
        }

        public getObjectLiteralScope(): SymbolScope {
>getObjectLiteralScope : () => any (error)

            return this.objectLiteralScopeGetter();
>this.objectLiteralScopeGetter() : any (error)
>this.objectLiteralScopeGetter : () => any (error)
>this : this
>objectLiteralScopeGetter : () => any (error)
        }

        public getScopeAST() {
>getScopeAST : () => any (error)

            return this.scopeStartAST;
>this.scopeStartAST : any (error)
>this : this
>scopeStartAST : any (error)
        }

        public getScopePosition() {
>getScopePosition : () => any (error)

            return this.scopeStartAST.minChar;
>this.scopeStartAST.minChar : any (error)
>this.scopeStartAST : any (error)
>this : this
>scopeStartAST : any (error)
>minChar : any (error)
        }

        public getScriptFragmentStartAST(): AST {
>getScriptFragmentStartAST : () => any (error)

            return this.scopeStartAST;
>this.scopeStartAST : any (error)
>this : this
>scopeStartAST : any (error)
        }

        public getScriptFragmentPosition(): number {
>getScriptFragmentPosition : () => number

            return this.getScriptFragmentStartAST().minChar;
>this.getScriptFragmentStartAST().minChar : any (error)
>this.getScriptFragmentStartAST() : any (error)
>this.getScriptFragmentStartAST : () => any (error)
>this : this
>getScriptFragmentStartAST : () => any (error)
>minChar : any (error)
        }

        public getScriptFragment(): Script {
>getScriptFragment : () => any (error)

            if (this.scriptFragment == null) {
>this.scriptFragment == null : boolean
>this.scriptFragment : any (error)
>this : this
>scriptFragment : any (error)
>null : null

                var ast = this.getScriptFragmentStartAST();
>ast : any (error)
>this.getScriptFragmentStartAST() : any (error)
>this.getScriptFragmentStartAST : () => any (error)
>this : this
>getScriptFragmentStartAST : () => any (error)

                var minChar = ast.minChar;
>minChar : any (error)
>ast.minChar : any (error)
>ast : any (error)
>minChar : any (error)

                var limChar = (this.isMemberCompletion ? this.pos : this.pos + 1);
>limChar : number
>(this.isMemberCompletion ? this.pos : this.pos + 1) : number
>this.isMemberCompletion ? this.pos : this.pos + 1 : number
>this.isMemberCompletion : boolean
>this : this
>isMemberCompletion : boolean
>this.pos : number
>this : this
>pos : number
>this.pos + 1 : number
>this.pos : number
>this : this
>pos : number
>1 : 1

                this.scriptFragment = TypeScript.quickParse(this.logger, ast, this.text, minChar, limChar, null/*errorCapture*/).Script;
>this.scriptFragment = TypeScript.quickParse(this.logger, ast, this.text, minChar, limChar, null/*errorCapture*/).Script : any (error)
>this.scriptFragment : any (error)
>this : this
>scriptFragment : any (error)
>TypeScript.quickParse(this.logger, ast, this.text, minChar, limChar, null/*errorCapture*/).Script : any (error)
>TypeScript.quickParse(this.logger, ast, this.text, minChar, limChar, null/*errorCapture*/) : any (error)
>TypeScript.quickParse : any (error)
>TypeScript : typeof TypeScript
>quickParse : any (error)
>this.logger : any (error)
>this : this
>logger : any (error)
>ast : any (error)
>this.text : any (error)
>this : this
>text : any (error)
>minChar : any (error)
>limChar : number
>null : null
>Script : any (error)
            }
            return this.scriptFragment;
>this.scriptFragment : any (error)
>this : this
>scriptFragment : any (error)
        }
    }

    export function preFindMemberScope(ast: AST, parent: AST, walker: IAstWalker) {
>preFindMemberScope : (ast: any (error), parent: any (error), walker: any (error)) => any (error)
>ast : any (error)
>parent : any (error)
>walker : any (error)

        var memScope: MemberScopeContext = walker.state;
>memScope : MemberScopeContext
>walker.state : any (error)
>walker : any (error)
>state : any (error)

        if (hasFlag(ast.flags, memScope.matchFlag) && ((memScope.pos < 0) || (memScope.pos == ast.limChar))) {
>hasFlag(ast.flags, memScope.matchFlag) && ((memScope.pos < 0) || (memScope.pos == ast.limChar)) : boolean
>hasFlag(ast.flags, memScope.matchFlag) : any (error)
>hasFlag : any (error)
>ast.flags : any (error)
>ast : any (error)
>flags : any (error)
>memScope.matchFlag : any (error)
>memScope : MemberScopeContext
>matchFlag : any (error)
>((memScope.pos < 0) || (memScope.pos == ast.limChar)) : boolean
>(memScope.pos < 0) || (memScope.pos == ast.limChar) : boolean
>(memScope.pos < 0) : boolean
>memScope.pos < 0 : boolean
>memScope.pos : number
>memScope : MemberScopeContext
>pos : number
>0 : 0
>(memScope.pos == ast.limChar) : boolean
>memScope.pos == ast.limChar : boolean
>memScope.pos : number
>memScope : MemberScopeContext
>pos : number
>ast.limChar : any (error)
>ast : any (error)
>limChar : any (error)

            memScope.ast = ast;
>memScope.ast = ast : any (error)
>memScope.ast : any (error)
>memScope : MemberScopeContext
>ast : any (error)
>ast : any (error)

            if ((ast.type == null) && (memScope.pos >= 0)) {
>(ast.type == null) && (memScope.pos >= 0) : boolean
>(ast.type == null) : boolean
>ast.type == null : boolean
>ast.type : any (error)
>ast : any (error)
>type : any (error)
>null : null
>(memScope.pos >= 0) : boolean
>memScope.pos >= 0 : boolean
>memScope.pos : number
>memScope : MemberScopeContext
>pos : number
>0 : 0

                memScope.flow.inScopeTypeCheck(ast, memScope.scope);
>memScope.flow.inScopeTypeCheck(ast, memScope.scope) : any (error)
>memScope.flow.inScopeTypeCheck : any (error)
>memScope.flow : any (error)
>memScope : MemberScopeContext
>flow : any (error)
>inScopeTypeCheck : any (error)
>ast : any (error)
>memScope.scope : any (error)
>memScope : MemberScopeContext
>scope : any (error)
            }
            memScope.type = ast.type;
>memScope.type = ast.type : any (error)
>memScope.type : any (error)
>memScope : MemberScopeContext
>type : any (error)
>ast.type : any (error)
>ast : any (error)
>type : any (error)

            memScope.options.stopWalk();
>memScope.options.stopWalk() : any (error)
>memScope.options.stopWalk : any (error)
>memScope.options : any (error)
>memScope : MemberScopeContext
>options : any (error)
>stopWalk : any (error)
        }
        return ast;
>ast : any (error)
    }

    export function pushTypeCollectionScope(container: Symbol,
>pushTypeCollectionScope : (container: Symbol, valueMembers: any (error), ambientValueMembers: any (error), enclosedTypes: any (error), ambientEnclosedTypes: any (error), context: TypeCollectionContext, thisType: any (error), classType: any (error), moduleDecl: any (error)) => void
>container : Symbol

        valueMembers: ScopedMembers,
>valueMembers : any (error)

        ambientValueMembers: ScopedMembers,
>ambientValueMembers : any (error)

        enclosedTypes: ScopedMembers,
>enclosedTypes : any (error)

        ambientEnclosedTypes: ScopedMembers,
>ambientEnclosedTypes : any (error)

        context: TypeCollectionContext,
>context : TypeCollectionContext

        thisType: Type,
>thisType : any (error)

        classType: Type,
>classType : any (error)

        moduleDecl: ModuleDeclaration) {
>moduleDecl : any (error)

        var builder = new SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container);
>builder : any (error)
>new SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container) : any (error)
>SymbolScopeBuilder : any (error)
>valueMembers : any (error)
>ambientValueMembers : any (error)
>enclosedTypes : any (error)
>ambientEnclosedTypes : any (error)
>null : null
>container : Symbol

        var chain: ScopeChain = new ScopeChain(container, context.scopeChain, builder);
>chain : any (error)
>new ScopeChain(container, context.scopeChain, builder) : any (error)
>ScopeChain : any (error)
>container : Symbol
>context.scopeChain : any (error)
>context : TypeCollectionContext
>scopeChain : any (error)
>builder : any (error)

        chain.thisType = thisType;
>chain.thisType = thisType : any (error)
>chain.thisType : any (error)
>chain : any (error)
>thisType : any (error)
>thisType : any (error)

        chain.classType = classType;
>chain.classType = classType : any (error)
>chain.classType : any (error)
>chain : any (error)
>classType : any (error)
>classType : any (error)

        chain.moduleDecl = moduleDecl;
>chain.moduleDecl = moduleDecl : any (error)
>chain.moduleDecl : any (error)
>chain : any (error)
>moduleDecl : any (error)
>moduleDecl : any (error)

        context.scopeChain = chain;
>context.scopeChain = chain : any (error)
>context.scopeChain : any (error)
>context : TypeCollectionContext
>scopeChain : any (error)
>chain : any (error)
    }

    export function popTypeCollectionScope(context: TypeCollectionContext) {
>popTypeCollectionScope : (context: TypeCollectionContext) => void
>context : TypeCollectionContext

        context.scopeChain = context.scopeChain.previous;
>context.scopeChain = context.scopeChain.previous : any (error)
>context.scopeChain : any (error)
>context : TypeCollectionContext
>scopeChain : any (error)
>context.scopeChain.previous : any (error)
>context.scopeChain : any (error)
>context : TypeCollectionContext
>scopeChain : any (error)
>previous : any (error)
    }

    export function preFindEnclosingScope(ast: AST, parent: AST, walker: IAstWalker) {
>preFindEnclosingScope : (ast: any (error), parent: any (error), walker: any (error)) => any (error)
>ast : any (error)
>parent : any (error)
>walker : any (error)

        var context: EnclosingScopeContext = walker.state;
>context : EnclosingScopeContext
>walker.state : any (error)
>walker : any (error)
>state : any (error)

        var minChar = ast.minChar;
>minChar : any (error)
>ast.minChar : any (error)
>ast : any (error)
>minChar : any (error)

        var limChar = ast.limChar;
>limChar : any (error)
>ast.limChar : any (error)
>ast : any (error)
>limChar : any (error)

        // Account for the fact completion list may be called at the end of a file which
        // is has not been fully re-parsed yet.
        if (ast.nodeType == NodeType.Script && context.pos > limChar)
>ast.nodeType == NodeType.Script && context.pos > limChar : boolean
>ast.nodeType == NodeType.Script : boolean
>ast.nodeType : any (error)
>ast : any (error)
>nodeType : any (error)
>NodeType.Script : any (error)
>NodeType : any (error)
>Script : any (error)
>context.pos > limChar : boolean
>context.pos : number
>context : EnclosingScopeContext
>pos : number
>limChar : any (error)

            limChar = context.pos;
>limChar = context.pos : number
>limChar : any (error)
>context.pos : number
>context : EnclosingScopeContext
>pos : number

        if ((minChar <= context.pos) &&
>(minChar <= context.pos) &&            (limChar >= context.pos) : boolean
>(minChar <= context.pos) : boolean
>minChar <= context.pos : boolean
>minChar : any (error)
>context.pos : number
>context : EnclosingScopeContext
>pos : number

            (limChar >= context.pos)) {
>(limChar >= context.pos) : boolean
>limChar >= context.pos : boolean
>limChar : any (error)
>context.pos : number
>context : EnclosingScopeContext
>pos : number

            switch (ast.nodeType) {
>ast.nodeType : any (error)
>ast : any (error)
>nodeType : any (error)

                case NodeType.Script:
>NodeType.Script : any (error)
>NodeType : any (error)
>Script : any (error)

                    var script = <Script>ast;
>script : any (error)
><Script>ast : any (error)
>ast : any (error)

                    context.scopeGetter = function () {
>context.scopeGetter = function () {                        return script.bod === null ? null : script.bod.enclosingScope;                    } : () => any
>context.scopeGetter : () => any (error)
>context : EnclosingScopeContext
>scopeGetter : () => any (error)
>function () {                        return script.bod === null ? null : script.bod.enclosingScope;                    } : () => any

                        return script.bod === null ? null : script.bod.enclosingScope;
>script.bod === null ? null : script.bod.enclosingScope : any
>script.bod === null : boolean
>script.bod : any (error)
>script : any (error)
>bod : any (error)
>null : null
>null : null
>script.bod.enclosingScope : any (error)
>script.bod : any (error)
>script : any (error)
>bod : any (error)
>enclosingScope : any (error)

                    };
                    context.scopeStartAST = script;
>context.scopeStartAST = script : any (error)
>context.scopeStartAST : any (error)
>context : EnclosingScopeContext
>scopeStartAST : any (error)
>script : any (error)

                    break;

                case NodeType.ClassDeclaration:
>NodeType.ClassDeclaration : any (error)
>NodeType : any (error)
>ClassDeclaration : any (error)

                    context.scopeGetter = function () {
>context.scopeGetter = function () {                        return (ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope;                    } : () => any
>context.scopeGetter : () => any (error)
>context : EnclosingScopeContext
>scopeGetter : () => any (error)
>function () {                        return (ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope;                    } : () => any

                        return (ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope;
>(ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope : any
>(ast.type === null || ast.type.instanceType.containedScope === null) : boolean
>ast.type === null || ast.type.instanceType.containedScope === null : boolean
>ast.type === null : boolean
>ast.type : any (error)
>ast : any (error)
>type : any (error)
>null : null
>ast.type.instanceType.containedScope === null : boolean
>ast.type.instanceType.containedScope : any (error)
>ast.type.instanceType : any (error)
>ast.type : any (error)
>ast : any (error)
>type : any (error)
>instanceType : any (error)
>containedScope : any (error)
>null : null
>null : null
>ast.type.instanceType.containedScope : any (error)
>ast.type.instanceType : any (error)
>ast.type : any (error)
>ast : any (error)
>type : any (error)
>instanceType : any (error)
>containedScope : any (error)

                    };
                    context.scopeStartAST = ast;
>context.scopeStartAST = ast : any (error)
>context.scopeStartAST : any (error)
>context : EnclosingScopeContext
>scopeStartAST : any (error)
>ast : any (error)

                    context.enclosingClassDecl = <TypeDeclaration>ast;
>context.enclosingClassDecl = <TypeDeclaration>ast : any (error)
>context.enclosingClassDecl : any (error)
>context : EnclosingScopeContext
>enclosingClassDecl : any (error)
><TypeDeclaration>ast : any (error)
>ast : any (error)

                    break;

                case NodeType.ObjectLit:
>NodeType.ObjectLit : any (error)
>NodeType : any (error)
>ObjectLit : any (error)

                    var objectLit = <UnaryExpression>ast;
>objectLit : any (error)
><UnaryExpression>ast : any (error)
>ast : any (error)

                    // Only consider target-typed object literals
                    if (objectLit.targetType) {
>objectLit.targetType : any (error)
>objectLit : any (error)
>targetType : any (error)

                        context.scopeGetter = function () {
>context.scopeGetter = function () {                            return objectLit.targetType.containedScope;                        } : () => any (error)
>context.scopeGetter : () => any (error)
>context : EnclosingScopeContext
>scopeGetter : () => any (error)
>function () {                            return objectLit.targetType.containedScope;                        } : () => any (error)

                            return objectLit.targetType.containedScope;
>objectLit.targetType.containedScope : any (error)
>objectLit.targetType : any (error)
>objectLit : any (error)
>targetType : any (error)
>containedScope : any (error)

                        };
                        context.objectLiteralScopeGetter = function () {
>context.objectLiteralScopeGetter = function () {                            return objectLit.targetType.memberScope;                        } : () => any (error)
>context.objectLiteralScopeGetter : () => any (error)
>context : EnclosingScopeContext
>objectLiteralScopeGetter : () => any (error)
>function () {                            return objectLit.targetType.memberScope;                        } : () => any (error)

                            return objectLit.targetType.memberScope;
>objectLit.targetType.memberScope : any (error)
>objectLit.targetType : any (error)
>objectLit : any (error)
>targetType : any (error)
>memberScope : any (error)
                        }
                        context.enclosingObjectLit = objectLit;
>context.enclosingObjectLit = objectLit : any (error)
>context.enclosingObjectLit : any (error)
>context : EnclosingScopeContext
>enclosingObjectLit : any (error)
>objectLit : any (error)
                    }
                    break;

                case NodeType.ModuleDeclaration:
>NodeType.ModuleDeclaration : any (error)
>NodeType : any (error)
>ModuleDeclaration : any (error)

                    context.deepestModuleDecl = <ModuleDeclaration>ast;
>context.deepestModuleDecl = <ModuleDeclaration>ast : any (error)
>context.deepestModuleDecl : any (error)
>context : EnclosingScopeContext
>deepestModuleDecl : any (error)
><ModuleDeclaration>ast : any (error)
>ast : any (error)

                    context.scopeGetter = function () {
>context.scopeGetter = function () {                        return ast.type === null ? null : ast.type.containedScope;                    } : () => any
>context.scopeGetter : () => any (error)
>context : EnclosingScopeContext
>scopeGetter : () => any (error)
>function () {                        return ast.type === null ? null : ast.type.containedScope;                    } : () => any

                        return ast.type === null ? null : ast.type.containedScope;
>ast.type === null ? null : ast.type.containedScope : any
>ast.type === null : boolean
>ast.type : any (error)
>ast : any (error)
>type : any (error)
>null : null
>null : null
>ast.type.containedScope : any (error)
>ast.type : any (error)
>ast : any (error)
>type : any (error)
>containedScope : any (error)

                    };
                    context.scopeStartAST = ast;
>context.scopeStartAST = ast : any (error)
>context.scopeStartAST : any (error)
>context : EnclosingScopeContext
>scopeStartAST : any (error)
>ast : any (error)

                    break;

                case NodeType.InterfaceDeclaration:
>NodeType.InterfaceDeclaration : any (error)
>NodeType : any (error)
>InterfaceDeclaration : any (error)

                    context.scopeGetter = function () {
>context.scopeGetter = function () {                        return (ast.type === null) ? null : ast.type.containedScope;                    } : () => any
>context.scopeGetter : () => any (error)
>context : EnclosingScopeContext
>scopeGetter : () => any (error)
>function () {                        return (ast.type === null) ? null : ast.type.containedScope;                    } : () => any

                        return (ast.type === null) ? null : ast.type.containedScope;
>(ast.type === null) ? null : ast.type.containedScope : any
>(ast.type === null) : boolean
>ast.type === null : boolean
>ast.type : any (error)
>ast : any (error)
>type : any (error)
>null : null
>null : null
>ast.type.containedScope : any (error)
>ast.type : any (error)
>ast : any (error)
>type : any (error)
>containedScope : any (error)

                    };
                    context.scopeStartAST = ast;
>context.scopeStartAST = ast : any (error)
>context.scopeStartAST : any (error)
>context : EnclosingScopeContext
>scopeStartAST : any (error)
>ast : any (error)

                    break;

                case NodeType.FuncDecl: {
>NodeType.FuncDecl : any (error)
>NodeType : any (error)
>FuncDecl : any (error)

                    var funcDecl = <FuncDecl>ast;
>funcDecl : any (error)
><FuncDecl>ast : any (error)
>ast : any (error)

                    if (context.skipNextFuncDeclForClass) {
>context.skipNextFuncDeclForClass : boolean
>context : EnclosingScopeContext
>skipNextFuncDeclForClass : boolean

                        context.skipNextFuncDeclForClass = false;
>context.skipNextFuncDeclForClass = false : false
>context.skipNextFuncDeclForClass : boolean
>context : EnclosingScopeContext
>skipNextFuncDeclForClass : boolean
>false : false
                    }
                    else {
                        context.scopeGetter = function () {
>context.scopeGetter = function () {                            // The scope of a class constructor is hidden somewhere we don't expect :-S                            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {                                if (ast.type && ast.type.enclosingType) {                                    return ast.type.enclosingType.constructorScope;                                }                            }                            if (funcDecl.scopeType) {                                return funcDecl.scopeType.containedScope;                            }                            if (funcDecl.type) {                                return funcDecl.type.containedScope;                            }                            return null;                        } : () => any
>context.scopeGetter : () => any (error)
>context : EnclosingScopeContext
>scopeGetter : () => any (error)
>function () {                            // The scope of a class constructor is hidden somewhere we don't expect :-S                            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {                                if (ast.type && ast.type.enclosingType) {                                    return ast.type.enclosingType.constructorScope;                                }                            }                            if (funcDecl.scopeType) {                                return funcDecl.scopeType.containedScope;                            }                            if (funcDecl.type) {                                return funcDecl.type.containedScope;                            }                            return null;                        } : () => any

                            // The scope of a class constructor is hidden somewhere we don't expect :-S
                            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {
>funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod) : any
>funcDecl.isConstructor : any (error)
>funcDecl : any (error)
>isConstructor : any (error)
>hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod) : any (error)
>hasFlag : any (error)
>funcDecl.fncFlags : any (error)
>funcDecl : any (error)
>fncFlags : any (error)
>FncFlags.ClassMethod : any (error)
>FncFlags : any (error)
>ClassMethod : any (error)

                                if (ast.type && ast.type.enclosingType) {
>ast.type && ast.type.enclosingType : any
>ast.type : any (error)
>ast : any (error)
>type : any (error)
>ast.type.enclosingType : any (error)
>ast.type : any (error)
>ast : any (error)
>type : any (error)
>enclosingType : any (error)

                                    return ast.type.enclosingType.constructorScope;
>ast.type.enclosingType.constructorScope : any (error)
>ast.type.enclosingType : any (error)
>ast.type : any (error)
>ast : any (error)
>type : any (error)
>enclosingType : any (error)
>constructorScope : any (error)
                                }
                            }

                            if (funcDecl.scopeType) {
>funcDecl.scopeType : any (error)
>funcDecl : any (error)
>scopeType : any (error)

                                return funcDecl.scopeType.containedScope;
>funcDecl.scopeType.containedScope : any (error)
>funcDecl.scopeType : any (error)
>funcDecl : any (error)
>scopeType : any (error)
>containedScope : any (error)
                            }

                            if (funcDecl.type) {
>funcDecl.type : any (error)
>funcDecl : any (error)
>type : any (error)

                                return funcDecl.type.containedScope;
>funcDecl.type.containedScope : any (error)
>funcDecl.type : any (error)
>funcDecl : any (error)
>type : any (error)
>containedScope : any (error)
                            }
                            return null;
>null : null

                        };
                        context.scopeStartAST = ast;
>context.scopeStartAST = ast : any (error)
>context.scopeStartAST : any (error)
>context : EnclosingScopeContext
>scopeStartAST : any (error)
>ast : any (error)
                    }
                }
                    break;
            }
            walker.options.goChildren = true;
>walker.options.goChildren = true : true
>walker.options.goChildren : any (error)
>walker.options : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>true : true
        }
        else {
            walker.options.goChildren = false;
>walker.options.goChildren = false : false
>walker.options.goChildren : any (error)
>walker.options : any (error)
>walker : any (error)
>options : any (error)
>goChildren : any (error)
>false : false
        }
        return ast;
>ast : any (error)
    }

    //
    // Find the enclosing scope context from a position inside a script AST.
    // The "scopeStartAST" of the returned scope is always valid.
    // Return "null" if the enclosing scope can't be found.
    //
    export function findEnclosingScopeAt(logger: ILogger, script: Script, text: ISourceText, pos: number, isMemberCompletion: boolean): EnclosingScopeContext {
>findEnclosingScopeAt : (logger: any (error), script: any (error), text: any (error), pos: number, isMemberCompletion: boolean) => EnclosingScopeContext
>logger : any (error)
>script : any (error)
>text : any (error)
>pos : number
>isMemberCompletion : boolean

        var context = new EnclosingScopeContext(logger, script, text, pos, isMemberCompletion);
>context : EnclosingScopeContext
>new EnclosingScopeContext(logger, script, text, pos, isMemberCompletion) : EnclosingScopeContext
>EnclosingScopeContext : typeof EnclosingScopeContext
>logger : any (error)
>script : any (error)
>text : any (error)
>pos : number
>isMemberCompletion : boolean

        TypeScript.getAstWalkerFactory().walk(script, preFindEnclosingScope, null, null, context);
>TypeScript.getAstWalkerFactory().walk(script, preFindEnclosingScope, null, null, context) : any (error)
>TypeScript.getAstWalkerFactory().walk : any (error)
>TypeScript.getAstWalkerFactory() : any (error)
>TypeScript.getAstWalkerFactory : any (error)
>TypeScript : typeof TypeScript
>getAstWalkerFactory : any (error)
>walk : any (error)
>script : any (error)
>preFindEnclosingScope : (ast: any (error), parent: any (error), walker: any (error)) => any (error)
>null : null
>null : null
>context : EnclosingScopeContext

        if (context.scopeStartAST === null)
>context.scopeStartAST === null : boolean
>context.scopeStartAST : any (error)
>context : EnclosingScopeContext
>scopeStartAST : any (error)
>null : null

            return null;
>null : null

        return context;
>context : EnclosingScopeContext
    }
}
