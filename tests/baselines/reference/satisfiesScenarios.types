=== tests/cases/compiler/satisfiesScenarios.ts ===
const x = [1, 2] satisfies [number, number];
>x : [number, number]
>[1, 2] satisfies [number, number] : [number, number]
>[1, 2] : [number, number]
>1 : 1
>2 : 2

interface A {
    a: string
>a : string
}
let d = { a: 'test' } satisfies A;
>d : { a: string; }
>{ a: 'test' } satisfies A : { a: string; }
>{ a: 'test' } : { a: string; }
>a : string
>'test' : "test"

let e = { a: 'test', b: 'test' } satisfies A;
>e : { a: string; b: string; }
>{ a: 'test', b: 'test' } satisfies A : { a: string; b: string; }
>{ a: 'test', b: 'test' } : { a: string; b: string; }
>a : string
>'test' : "test"
>b : string
>'test' : "test"

// Most examples from #47920
namespace PropNameConstraining {
>PropNameConstraining : typeof PropNameConstraining

    type Keys = 'a' | 'b' | 'c' | 'd';
>Keys : Keys

    const p = {
>p : { a: number; b: string; x: number; }
>{        a: 0,        b: "hello",        x: 8 // Should error, 'x' isn't in 'Keys'    } satisfies Partial<Record<Keys, unknown>> : { a: number; b: string; x: number; }
>{        a: 0,        b: "hello",        x: 8 // Should error, 'x' isn't in 'Keys'    } : { a: number; b: string; x: number; }

        a: 0,
>a : number
>0 : 0

        b: "hello",
>b : string
>"hello" : "hello"

        x: 8 // Should error, 'x' isn't in 'Keys'
>x : number
>8 : 8

    } satisfies Partial<Record<Keys, unknown>>;

    // Should be OK -- retain info that a is number and b is string
    let a = p.a.toFixed();
>a : string
>p.a.toFixed() : string
>p.a.toFixed : (fractionDigits?: number) => string
>p.a : number
>p : { a: number; b: string; x: number; }
>a : number
>toFixed : (fractionDigits?: number) => string

    let b = p.b.substring(1);
>b : string
>p.b.substring(1) : string
>p.b.substring : (start: number, end?: number) => string
>p.b : string
>p : { a: number; b: string; x: number; }
>b : string
>substring : (start: number, end?: number) => string
>1 : 1

    // Should error even though 'd' is in 'Keys'
    let d = p.d;
>d : any
>p.d : any
>p : { a: number; b: string; x: number; }
>d : any
}

namespace PropertyNameFulfillment {
>PropertyNameFulfillment : typeof PropertyNameFulfillment

    type Keys = 'a' | 'b' | 'c' | 'd';
>Keys : Keys

    const p = {
>p : { a: number; b: string; x: number; }
>{        a: 0,        b: "hello",        x: 8 // Should error, 'x' isn't in 'Keys'    } satisfies Record<Keys, unknown> : { a: number; b: string; x: number; }
>{        a: 0,        b: "hello",        x: 8 // Should error, 'x' isn't in 'Keys'    } : { a: number; b: string; x: number; }

        a: 0,
>a : number
>0 : 0

        b: "hello",
>b : string
>"hello" : "hello"

        x: 8 // Should error, 'x' isn't in 'Keys'
>x : number
>8 : 8

    } satisfies Record<Keys, unknown>;

    // Should be OK -- retain info that a is number and b is string
    let a = p.a.toFixed();
>a : string
>p.a.toFixed() : string
>p.a.toFixed : (fractionDigits?: number) => string
>p.a : number
>p : { a: number; b: string; x: number; }
>a : number
>toFixed : (fractionDigits?: number) => string

    let b = p.b.substr(1);
>b : string
>p.b.substr(1) : string
>p.b.substr : (from: number, length?: number) => string
>p.b : string
>p : { a: number; b: string; x: number; }
>b : string
>substr : (from: number, length?: number) => string
>1 : 1

    // Should error even though 'd' is in 'Keys'
    let d = p.d;
>d : any
>p.d : any
>p : { a: number; b: string; x: number; }
>d : any
}

namespace PropertyValueConformance {
>PropertyValueConformance : typeof PropertyValueConformance

    type Facts = { [key: string]: boolean };
>Facts : Facts
>key : string

    declare function checkTruths(x: Facts): void;
>checkTruths : (x: Facts) => void
>x : Facts

    declare function checkM(x: { m: boolean }): void;
>checkM : (x: {    m: boolean;}) => void
>x : { m: boolean; }
>m : boolean

    const x = {
>x : { m: boolean; }
>{        m: true    } : { m: boolean; }

        m: true
>m : boolean
>true : true

    };

    // Should be OK
    checkTruths(x);
>checkTruths(x) : void
>checkTruths : (x: Facts) => void
>x : { m: boolean; }

    // Should be OK
    checkM(x);
>checkM(x) : void
>checkM : (x: { m: boolean; }) => void
>x : { m: boolean; }

    // Should fail under --noIndexSignaturePropertyAccess
    console.log(x.z);
>console.log(x.z) : void
>console.log : (...data: any[]) => void
>console : Console
>log : (...data: any[]) => void
>x.z : any
>x : { m: boolean; }
>z : any

    // Should be OK under --noUncheckedIndexedAccess
    const m: boolean = x.m;
>m : boolean
>x.m : boolean
>x : { m: boolean; }
>m : boolean

    // Should be 'm'
    type M = keyof typeof x;
>M : "m"
>x : { m: boolean; }

    // Should be able to detect a failure here
    const x2 = {
>x2 : { m: true; s: string; }
>{        m: true,        s: "false"    } satisfies Facts : { m: true; s: string; }
>{        m: true,        s: "false"    } : { m: true; s: string; }

        m: true,
>m : true
>true : true

        s: "false"
>s : string
>"false" : "false"

    } satisfies Facts;
}

namespace PropertyValueConformance2 {
>PropertyValueConformance2 : typeof PropertyValueConformance2

    export type Color = { r: number, g: number, b: number };
>Color : Color
>r : number
>g : number
>b : number

    // All of these should be Colors, but I only use some of them here.
    export const Palette = {
>Palette : { white: { r: number; g: number; b: number; }; black: { r: number; g: number; d: number; }; blue: { r: number; g: number; b: number; }; }
>{        white: { r: 255, g: 255, b: 255 },        black: { r: 0, g: 0, d: 0 }, // <- oops! 'd' in place of 'b'        blue: { r: 0, g: 0, b: 255 },    } satisfies Record<string, Color> : { white: { r: number; g: number; b: number; }; black: { r: number; g: number; d: number; }; blue: { r: number; g: number; b: number; }; }
>{        white: { r: 255, g: 255, b: 255 },        black: { r: 0, g: 0, d: 0 }, // <- oops! 'd' in place of 'b'        blue: { r: 0, g: 0, b: 255 },    } : { white: { r: number; g: number; b: number; }; black: { r: number; g: number; d: number; }; blue: { r: number; g: number; b: number; }; }

        white: { r: 255, g: 255, b: 255 },
>white : { r: number; g: number; b: number; }
>{ r: 255, g: 255, b: 255 } : { r: number; g: number; b: number; }
>r : number
>255 : 255
>g : number
>255 : 255
>b : number
>255 : 255

        black: { r: 0, g: 0, d: 0 }, // <- oops! 'd' in place of 'b'
>black : { r: number; g: number; d: number; }
>{ r: 0, g: 0, d: 0 } : { r: number; g: number; d: number; }
>r : number
>0 : 0
>g : number
>0 : 0
>d : number
>0 : 0

        blue: { r: 0, g: 0, b: 255 },
>blue : { r: number; g: number; b: number; }
>{ r: 0, g: 0, b: 255 } : { r: number; g: number; b: number; }
>r : number
>0 : 0
>g : number
>0 : 0
>b : number
>255 : 255

    } satisfies Record<string, Color>;
}

namespace EnsureInterfaceImpl {
>EnsureInterfaceImpl : typeof EnsureInterfaceImpl

    type Movable = {
>Movable : Movable

        move(distance: number): void;
>move : (distance: number) => void
>distance : number

    };

    const car = {
>car : { start(): void; move(d: number): void; stop(): void; }
>{        start() { },        move(d) {            // d should be number        },        stop() { }    } satisfies Movable & Record<string, unknown> : { start(): void; move(d: number): void; stop(): void; }
>{        start() { },        move(d) {            // d should be number        },        stop() { }    } : { start(): void; move(d: number): void; stop(): void; }

        start() { },
>start : () => void

        move(d) {
>move : (d: number) => void
>d : number

            // d should be number
        },
        stop() { }
>stop : () => void

    } satisfies Movable & Record<string, unknown>;
}

namespace OptionalMemberConformance {
>OptionalMemberConformance : typeof OptionalMemberConformance

    type Point2d = { x: number, y: number };
>Point2d : Point2d
>x : number
>y : number

    // Undesirable behavior today with type annotation
    const a = { x: 10 } satisfies Partial<Point2d>;
>a : { x: number; }
>{ x: 10 } satisfies Partial<Point2d> : { x: number; }
>{ x: 10 } : { x: number; }
>x : number
>10 : 10

    // Should OK
    console.log(a.x.toFixed());
>console.log(a.x.toFixed()) : void
>console.log : (...data: any[]) => void
>console : Console
>log : (...data: any[]) => void
>a.x.toFixed() : string
>a.x.toFixed : (fractionDigits?: number) => string
>a.x : number
>a : { x: number; }
>x : number
>toFixed : (fractionDigits?: number) => string

    // Should error
    let p = a.y;    
>p : any
>a.y : any
>a : { x: number; }
>y : any
}

namespace ContextualTyping {
>ContextualTyping : typeof ContextualTyping

    type Predicates = { [s: string]: (n: number) => boolean };
>Predicates : Predicates
>s : string
>n : number

    const p: Predicates = {
>p : Predicates
>{        isEven: n => n % 2 === 0,        isOdd: n => n % 2 === 1    } : { isEven: (n: number) => boolean; isOdd: (n: number) => boolean; }

        isEven: n => n % 2 === 0,
>isEven : (n: number) => boolean
>n => n % 2 === 0 : (n: number) => boolean
>n : number
>n % 2 === 0 : boolean
>n % 2 : number
>n : number
>2 : 2
>0 : 0

        isOdd: n => n % 2 === 1
>isOdd : (n: number) => boolean
>n => n % 2 === 1 : (n: number) => boolean
>n : number
>n % 2 === 1 : boolean
>n % 2 : number
>n : number
>2 : 2
>1 : 1

    };
}
