//// [tests/cases/conformance/types/uniqueSymbol/uniqueSymbolsPropertyNames.ts] ////

=== uniqueSymbolsPropertyNames.ts ===
interface OpTypes {
  readonly equal: unique symbol;
>equal : unique symbol
}

namespace OpNamespace {
>OpNamespace : typeof OpNamespace

  export declare const equal: unique symbol;
>equal : unique symbol
}

const Op: OpTypes = {
>Op : OpTypes
>{  equal: Symbol.for("equal"),} as OpTypes : OpTypes
>{  equal: Symbol.for("equal"),} : { equal: any; }

  equal: Symbol.for("equal"),
>equal : any
>Symbol.for("equal") : any
>Symbol.for : any
>Symbol : any
>for : any
>"equal" : "equal"

} as OpTypes;

const t0 = {
>t0 : { equal: string; }
>{  equal: "first",  equal: "second",  ["equal"]: "last",} : { equal: string; }

  equal: "first",
>equal : string
>"first" : "first"

  equal: "second",
>equal : string
>"second" : "second"

  ["equal"]: "last",
>["equal"] : string
>"equal" : "equal"
>"last" : "last"

};

const t1 = {
>t1 : { [Op.equal]: string; }
>{  [Op.equal]: "first",  [Op.equal]: "last",} : { [Op.equal]: string; }

  [Op.equal]: "first",
>[Op.equal] : string
>Op.equal : unique symbol
>Op : OpTypes
>equal : unique symbol
>"first" : "first"

  [Op.equal]: "last",
>[Op.equal] : string
>Op.equal : unique symbol
>Op : OpTypes
>equal : unique symbol
>"last" : "last"

};

const t2 = {
>t2 : { [OpNamespace.equal]: string; }
>{  [OpNamespace.equal]: "first",  [OpNamespace.equal]: "last",} : { [OpNamespace.equal]: string; }

  [OpNamespace.equal]: "first",
>[OpNamespace.equal] : string
>OpNamespace.equal : unique symbol
>OpNamespace : typeof OpNamespace
>equal : unique symbol
>"first" : "first"

  [OpNamespace.equal]: "last",
>[OpNamespace.equal] : string
>OpNamespace.equal : unique symbol
>OpNamespace : typeof OpNamespace
>equal : unique symbol
>"last" : "last"

};

