//// [tests/cases/compiler/narrowByUndefinedEqualityGeneric1.ts] ////

=== narrowByUndefinedEqualityGeneric1.ts ===
type AnyObject = Record<string, any>;
>AnyObject : { [x: string]: any; }

type State = AnyObject;
>State : AnyObject

declare function hasOwnProperty<T extends AnyObject>(
>hasOwnProperty : <T extends AnyObject>(object: T, prop: PropertyKey) => prop is keyof T

  object: T,
>object : T

  prop: PropertyKey,
>prop : PropertyKey

): prop is keyof T;

interface Store<S = State> {
  setState<K extends keyof S>(key: K, value: S[K]): void;
>setState : <K extends keyof S>(key: K, value: S[K]) => void
>key : K
>value : S[K]
}

export function syncStoreProp<
>syncStoreProp : <S extends AnyObject, P extends Partial<S>, K extends keyof S>(store: Store<S>, props: P, key: K) => void

  S extends State,
  P extends Partial<S>,
  K extends keyof S,
>(store: Store<S>, props: P, key: K) {
>store : Store<S>
>props : P
>key : K

  const value = hasOwnProperty(props, key) ? props[key] : undefined;
>value : P[K] | undefined
>hasOwnProperty(props, key) ? props[key] : undefined : P[K] | undefined
>hasOwnProperty(props, key) : boolean
>hasOwnProperty : <T extends AnyObject>(object: T, prop: PropertyKey) => prop is keyof T
>props : P
>key : string | number | symbol
>props[key] : P[K]
>props : P
>key : K
>undefined : undefined

  if (value === undefined) return;
>value === undefined : boolean
>value : P[K] | undefined
>undefined : undefined

  store.setState(key, value);
>store.setState(key, value) : void
>store.setState : <K_1 extends keyof S>(key: K_1, value: S[K_1]) => void
>store : Store<S>
>setState : <K_1 extends keyof S>(key: K_1, value: S[K_1]) => void
>key : K
>value : P[K] & ({} | null)

  if (value === undefined) return;
>value === undefined : boolean
>value : P[K] & ({} | null)
>undefined : undefined

  store.setState(key, value);
>store.setState(key, value) : void
>store.setState : <K_1 extends keyof S>(key: K_1, value: S[K_1]) => void
>store : Store<S>
>setState : <K_1 extends keyof S>(key: K_1, value: S[K_1]) => void
>key : K
>value : P[K] & ({} | null)
}

