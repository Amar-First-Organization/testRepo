=== tests/cases/conformance/es2017/useObjectValuesAndEntries1.ts ===

var o = { a: 1, b: 2 };
>o : { a: number; b: number; }
>{ a: 1, b: 2 } : { a: number; b: number; }
>a : number
>1 : 1
>b : number
>2 : 2

for (var x of Object.values(o)) {
>x : number
>Object.values(o) : number[]
>Object.values : { <T>(o: { [s: string]: T; }): T[]; (o: any): any[]; }
>Object : ObjectConstructor
>values : { <T>(o: { [s: string]: T; }): T[]; (o: any): any[]; }
>o : { a: number; b: number; }

    let y = x;
>y : number
>x : number
}

var entries = Object.entries(o);  // <-- entries: [('a' & string) | ('b' & string), number][]
>entries : [("a" & string) | ("b" & string), number][]
>Object.entries(o) : [("a" & string) | ("b" & string), number][]
>Object.entries : { <T>(o: T[]): [string, T][]; <T extends { [key: string]: any; }, K extends keyof T>(o: T): [keyof T & string, T[K]][]; (o: any): [string, any][]; }
>Object : ObjectConstructor
>entries : { <T>(o: T[]): [string, T][]; <T extends { [key: string]: any; }, K extends keyof T>(o: T): [keyof T & string, T[K]][]; (o: any): [string, any][]; }
>o : { a: number; b: number; }

var entries1 = Object.entries(1); // <-- entries: [string, any][]
>entries1 : [string, any][]
>Object.entries(1) : [string, any][]
>Object.entries : { <T>(o: T[]): [string, T][]; <T extends { [key: string]: any; }, K extends keyof T>(o: T): [keyof T & string, T[K]][]; (o: any): [string, any][]; }
>Object : ObjectConstructor
>entries : { <T>(o: T[]): [string, T][]; <T extends { [key: string]: any; }, K extends keyof T>(o: T): [keyof T & string, T[K]][]; (o: any): [string, any][]; }
>1 : 1

var entries2 = Object.entries({a: true, b: 2}) // [('a' & string) | ('b' & string), number | boolean][]
>entries2 : [("a" & string) | ("b" & string), number | boolean][]
>Object.entries({a: true, b: 2}) : [("a" & string) | ("b" & string), number | boolean][]
>Object.entries : { <T>(o: T[]): [string, T][]; <T extends { [key: string]: any; }, K extends keyof T>(o: T): [keyof T & string, T[K]][]; (o: any): [string, any][]; }
>Object : ObjectConstructor
>entries : { <T>(o: T[]): [string, T][]; <T extends { [key: string]: any; }, K extends keyof T>(o: T): [keyof T & string, T[K]][]; (o: any): [string, any][]; }
>{a: true, b: 2} : { a: true; b: number; }
>a : boolean
>true : true
>b : number
>2 : 2

var entries3 = Object.entries({}) // [string, any][]
>entries3 : [string, any][]
>Object.entries({}) : [string, any][]
>Object.entries : { <T>(o: T[]): [string, T][]; <T extends { [key: string]: any; }, K extends keyof T>(o: T): [keyof T & string, T[K]][]; (o: any): [string, any][]; }
>Object : ObjectConstructor
>entries : { <T>(o: T[]): [string, T][]; <T extends { [key: string]: any; }, K extends keyof T>(o: T): [keyof T & string, T[K]][]; (o: any): [string, any][]; }
>{} : {}

var entries4 = Object.entries([1, 2, 3, 4]); // [string, number][]
>entries4 : [string, number][]
>Object.entries([1, 2, 3, 4]) : [string, number][]
>Object.entries : { <T>(o: T[]): [string, T][]; <T extends { [key: string]: any; }, K extends keyof T>(o: T): [keyof T & string, T[K]][]; (o: any): [string, any][]; }
>Object : ObjectConstructor
>entries : { <T>(o: T[]): [string, T][]; <T extends { [key: string]: any; }, K extends keyof T>(o: T): [keyof T & string, T[K]][]; (o: any): [string, any][]; }
>[1, 2, 3, 4] : number[]
>1 : 1
>2 : 2
>3 : 3
>4 : 4

// type below should be [string | (string & number), any] NOT [string | number, any]
var x2: { [index: string]: any } = {1: 2};
>x2 : { [index: string]: any; }
>index : string
>{1: 2} : { 1: number; }
>2 : 2

var entries5 = Object.entries(x2);
>entries5 : [string | (number & string), any][]
>Object.entries(x2) : [string | (number & string), any][]
>Object.entries : { <T>(o: T[]): [string, T][]; <T extends { [key: string]: any; }, K extends keyof T>(o: T): [keyof T & string, T[K]][]; (o: any): [string, any][]; }
>Object : ObjectConstructor
>entries : { <T>(o: T[]): [string, T][]; <T extends { [key: string]: any; }, K extends keyof T>(o: T): [keyof T & string, T[K]][]; (o: any): [string, any][]; }
>x2 : { [index: string]: any; }

