=== tests/cases/compiler/library_ArraySlice.ts ===
// Array.prototype.slice can have zero, one, or two arguments
Array.prototype.slice();
>Array.prototype.slice : Symbol(Array.slice, Decl(lib.d.ts, 1048, 15), Decl(lib.d.ts, 1053, 18))
>Array.prototype : Symbol(ArrayConstructor.prototype, Decl(lib.d.ts, 1173, 41))
>Array : Symbol(Array, Decl(lib.d.ts, 1000, 23), Decl(lib.d.ts, 1177, 11))
>prototype : Symbol(ArrayConstructor.prototype, Decl(lib.d.ts, 1173, 41))
>slice : Symbol(Array.slice, Decl(lib.d.ts, 1048, 15), Decl(lib.d.ts, 1053, 18))

Array.prototype.slice(0);
>Array.prototype.slice : Symbol(Array.slice, Decl(lib.d.ts, 1048, 15), Decl(lib.d.ts, 1053, 18))
>Array.prototype : Symbol(ArrayConstructor.prototype, Decl(lib.d.ts, 1173, 41))
>Array : Symbol(Array, Decl(lib.d.ts, 1000, 23), Decl(lib.d.ts, 1177, 11))
>prototype : Symbol(ArrayConstructor.prototype, Decl(lib.d.ts, 1173, 41))
>slice : Symbol(Array.slice, Decl(lib.d.ts, 1048, 15), Decl(lib.d.ts, 1053, 18))

Array.prototype.slice(0, 1);
>Array.prototype.slice : Symbol(Array.slice, Decl(lib.d.ts, 1048, 15), Decl(lib.d.ts, 1053, 18))
>Array.prototype : Symbol(ArrayConstructor.prototype, Decl(lib.d.ts, 1173, 41))
>Array : Symbol(Array, Decl(lib.d.ts, 1000, 23), Decl(lib.d.ts, 1177, 11))
>prototype : Symbol(ArrayConstructor.prototype, Decl(lib.d.ts, 1173, 41))
>slice : Symbol(Array.slice, Decl(lib.d.ts, 1048, 15), Decl(lib.d.ts, 1053, 18))

// Array.prototype.slice returns this with zero arguments, allowing tuple slicing
let t1: [number, number] = [1, 2];
>t1 : Symbol(t1, Decl(library_ArraySlice.ts, 6, 3))

let t2: [number, number] = t1.slice();
>t2 : Symbol(t2, Decl(library_ArraySlice.ts, 7, 3))
>t1.slice : Symbol(Array.slice, Decl(lib.d.ts, 1048, 15), Decl(lib.d.ts, 1053, 18))
>t1 : Symbol(t1, Decl(library_ArraySlice.ts, 6, 3))
>slice : Symbol(Array.slice, Decl(lib.d.ts, 1048, 15), Decl(lib.d.ts, 1053, 18))

