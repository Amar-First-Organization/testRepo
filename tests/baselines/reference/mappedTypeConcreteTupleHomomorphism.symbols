=== tests/cases/compiler/mappedTypeConcreteTupleHomomorphism.ts ===
type TupleOfNumbers = [1, 2]
>TupleOfNumbers : Symbol(TupleOfNumbers, Decl(mappedTypeConcreteTupleHomomorphism.ts, 0, 0))

type HomomorphicType = {
>HomomorphicType : Symbol(HomomorphicType, Decl(mappedTypeConcreteTupleHomomorphism.ts, 0, 28))

    [K in keyof TupleOfNumbers]: `${TupleOfNumbers[K]}`
>K : Symbol(K, Decl(mappedTypeConcreteTupleHomomorphism.ts, 3, 5))
>TupleOfNumbers : Symbol(TupleOfNumbers, Decl(mappedTypeConcreteTupleHomomorphism.ts, 0, 0))
>TupleOfNumbers : Symbol(TupleOfNumbers, Decl(mappedTypeConcreteTupleHomomorphism.ts, 0, 0))
>K : Symbol(K, Decl(mappedTypeConcreteTupleHomomorphism.ts, 3, 5))
}

const homomorphic: HomomorphicType = ['1', '2']
>homomorphic : Symbol(homomorphic, Decl(mappedTypeConcreteTupleHomomorphism.ts, 6, 5))
>HomomorphicType : Symbol(HomomorphicType, Decl(mappedTypeConcreteTupleHomomorphism.ts, 0, 28))

type GenericType<T> = {
>GenericType : Symbol(GenericType, Decl(mappedTypeConcreteTupleHomomorphism.ts, 6, 47))
>T : Symbol(T, Decl(mappedTypeConcreteTupleHomomorphism.ts, 8, 17))

    [K in keyof T]: [K, T[K]]
>K : Symbol(K, Decl(mappedTypeConcreteTupleHomomorphism.ts, 9, 5))
>T : Symbol(T, Decl(mappedTypeConcreteTupleHomomorphism.ts, 8, 17))
>K : Symbol(K, Decl(mappedTypeConcreteTupleHomomorphism.ts, 9, 5))
>T : Symbol(T, Decl(mappedTypeConcreteTupleHomomorphism.ts, 8, 17))
>K : Symbol(K, Decl(mappedTypeConcreteTupleHomomorphism.ts, 9, 5))
}

type HomomorphicInstantiation = {
>HomomorphicInstantiation : Symbol(HomomorphicInstantiation, Decl(mappedTypeConcreteTupleHomomorphism.ts, 10, 1))

    [K in keyof GenericType<['c', 'd', 'e']>]: 1
>K : Symbol(K, Decl(mappedTypeConcreteTupleHomomorphism.ts, 13, 5))
>GenericType : Symbol(GenericType, Decl(mappedTypeConcreteTupleHomomorphism.ts, 6, 47))
}

const d: HomomorphicInstantiation = [1, 1, 1]
>d : Symbol(d, Decl(mappedTypeConcreteTupleHomomorphism.ts, 16, 5))
>HomomorphicInstantiation : Symbol(HomomorphicInstantiation, Decl(mappedTypeConcreteTupleHomomorphism.ts, 10, 1))

type TupleOfNumbersAndObjects = [1, 2, {}]
>TupleOfNumbersAndObjects : Symbol(TupleOfNumbersAndObjects, Decl(mappedTypeConcreteTupleHomomorphism.ts, 16, 45))

type ShoulsErrorInAssignement = {
>ShoulsErrorInAssignement : Symbol(ShoulsErrorInAssignement, Decl(mappedTypeConcreteTupleHomomorphism.ts, 18, 42))

    [K in keyof TupleOfNumbersAndObjects]: `${TupleOfNumbersAndObjects[K]}`
>K : Symbol(K, Decl(mappedTypeConcreteTupleHomomorphism.ts, 21, 5))
>TupleOfNumbersAndObjects : Symbol(TupleOfNumbersAndObjects, Decl(mappedTypeConcreteTupleHomomorphism.ts, 16, 45))
>TupleOfNumbersAndObjects : Symbol(TupleOfNumbersAndObjects, Decl(mappedTypeConcreteTupleHomomorphism.ts, 16, 45))
>K : Symbol(K, Decl(mappedTypeConcreteTupleHomomorphism.ts, 21, 5))
}

// repro from #27995
type Foo = ['a', 'b'];
>Foo : Symbol(Foo, Decl(mappedTypeConcreteTupleHomomorphism.ts, 22, 1))

interface Bar {
>Bar : Symbol(Bar, Decl(mappedTypeConcreteTupleHomomorphism.ts, 25, 22))

    a: string;
>a : Symbol(Bar.a, Decl(mappedTypeConcreteTupleHomomorphism.ts, 27, 15))

    b: number;
>b : Symbol(Bar.b, Decl(mappedTypeConcreteTupleHomomorphism.ts, 28, 14))
}

type Baz = { [K in keyof Foo]: Bar[Foo[K]]; };
>Baz : Symbol(Baz, Decl(mappedTypeConcreteTupleHomomorphism.ts, 30, 1))
>K : Symbol(K, Decl(mappedTypeConcreteTupleHomomorphism.ts, 32, 14))
>Foo : Symbol(Foo, Decl(mappedTypeConcreteTupleHomomorphism.ts, 22, 1))
>Bar : Symbol(Bar, Decl(mappedTypeConcreteTupleHomomorphism.ts, 25, 22))
>Foo : Symbol(Foo, Decl(mappedTypeConcreteTupleHomomorphism.ts, 22, 1))
>K : Symbol(K, Decl(mappedTypeConcreteTupleHomomorphism.ts, 32, 14))

