=== tests/cases/conformance/additionalChecks/noUnnecessaryTypeAssertions1.ts ===
const a = {};
>a : Symbol(a, Decl(noUnnecessaryTypeAssertions1.ts, 0, 5))

let b: {};
>b : Symbol(b, Decl(noUnnecessaryTypeAssertions1.ts, 1, 3))

b = a as {};
>b : Symbol(b, Decl(noUnnecessaryTypeAssertions1.ts, 1, 3))
>a : Symbol(a, Decl(noUnnecessaryTypeAssertions1.ts, 0, 5))

interface Foo {
>Foo : Symbol(Foo, Decl(noUnnecessaryTypeAssertions1.ts, 2, 12))

    x?: string;
>x : Symbol(Foo.x, Decl(noUnnecessaryTypeAssertions1.ts, 3, 15))
}
const foo1: Foo = { x: "ok" } as Foo; // cast technically erases type information, not a no-op
>foo1 : Symbol(foo1, Decl(noUnnecessaryTypeAssertions1.ts, 6, 5))
>Foo : Symbol(Foo, Decl(noUnnecessaryTypeAssertions1.ts, 2, 12))
>x : Symbol(x, Decl(noUnnecessaryTypeAssertions1.ts, 6, 19))
>Foo : Symbol(Foo, Decl(noUnnecessaryTypeAssertions1.ts, 2, 12))

const foo2: Foo = foo1 as Foo;
>foo2 : Symbol(foo2, Decl(noUnnecessaryTypeAssertions1.ts, 7, 5))
>Foo : Symbol(Foo, Decl(noUnnecessaryTypeAssertions1.ts, 2, 12))
>foo1 : Symbol(foo1, Decl(noUnnecessaryTypeAssertions1.ts, 6, 5))
>Foo : Symbol(Foo, Decl(noUnnecessaryTypeAssertions1.ts, 2, 12))

class A {
>A : Symbol(A, Decl(noUnnecessaryTypeAssertions1.ts, 7, 30))

    item: any;
>item : Symbol(A.item, Decl(noUnnecessaryTypeAssertions1.ts, 8, 9))
}
class B {
>B : Symbol(B, Decl(noUnnecessaryTypeAssertions1.ts, 10, 1))

    item: any;
>item : Symbol(B.item, Decl(noUnnecessaryTypeAssertions1.ts, 11, 9))
}
const aCls = new A();
>aCls : Symbol(aCls, Decl(noUnnecessaryTypeAssertions1.ts, 14, 5))
>A : Symbol(A, Decl(noUnnecessaryTypeAssertions1.ts, 7, 30))

const bCls = new B();
>bCls : Symbol(bCls, Decl(noUnnecessaryTypeAssertions1.ts, 15, 5))
>B : Symbol(B, Decl(noUnnecessaryTypeAssertions1.ts, 10, 1))

const aCls2: A = bCls as A;
>aCls2 : Symbol(aCls2, Decl(noUnnecessaryTypeAssertions1.ts, 16, 5))
>A : Symbol(A, Decl(noUnnecessaryTypeAssertions1.ts, 7, 30))
>bCls : Symbol(bCls, Decl(noUnnecessaryTypeAssertions1.ts, 15, 5))
>A : Symbol(A, Decl(noUnnecessaryTypeAssertions1.ts, 7, 30))

const bCls2: B = aCls as A;
>bCls2 : Symbol(bCls2, Decl(noUnnecessaryTypeAssertions1.ts, 17, 5))
>B : Symbol(B, Decl(noUnnecessaryTypeAssertions1.ts, 10, 1))
>aCls : Symbol(aCls, Decl(noUnnecessaryTypeAssertions1.ts, 14, 5))
>A : Symbol(A, Decl(noUnnecessaryTypeAssertions1.ts, 7, 30))

function foo(x: number): number {
>foo : Symbol(foo, Decl(noUnnecessaryTypeAssertions1.ts, 17, 27))
>x : Symbol(x, Decl(noUnnecessaryTypeAssertions1.ts, 18, 13))

    return x!;
>x : Symbol(x, Decl(noUnnecessaryTypeAssertions1.ts, 18, 13))
}
const a1 = 2;
>a1 : Symbol(a1, Decl(noUnnecessaryTypeAssertions1.ts, 21, 5))

a1?.toString!.call(2);
>a1?.toString!.call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))
>a1?.toString : Symbol(Number.toString, Decl(lib.es5.d.ts, --, --))
>a1 : Symbol(a1, Decl(noUnnecessaryTypeAssertions1.ts, 21, 5))
>toString : Symbol(Number.toString, Decl(lib.es5.d.ts, --, --))
>call : Symbol(CallableFunction.call, Decl(lib.es5.d.ts, --, --))

function testRequired() {
>testRequired : Symbol(testRequired, Decl(noUnnecessaryTypeAssertions1.ts, 22, 22))

    let resolve: (value: unknown) => void
>resolve : Symbol(resolve, Decl(noUnnecessaryTypeAssertions1.ts, 24, 7))
>value : Symbol(value, Decl(noUnnecessaryTypeAssertions1.ts, 24, 18))

    new Promise(resolve0 => {
>Promise : Symbol(Promise, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --), Decl(lib.es2015.promise.d.ts, --, --), Decl(lib.es2015.symbol.wellknown.d.ts, --, --))
>resolve0 : Symbol(resolve0, Decl(noUnnecessaryTypeAssertions1.ts, 25, 16))

        resolve = resolve0
>resolve : Symbol(resolve, Decl(noUnnecessaryTypeAssertions1.ts, 24, 7))
>resolve0 : Symbol(resolve0, Decl(noUnnecessaryTypeAssertions1.ts, 25, 16))

    })
    return resolve! // this non-null assertion is required, removing it causes compiler to hard fail
>resolve : Symbol(resolve, Decl(noUnnecessaryTypeAssertions1.ts, 24, 7))
}
let x: unknown;
>x : Symbol(x, Decl(noUnnecessaryTypeAssertions1.ts, 30, 3))

x! = 2;
>x : Symbol(x, Decl(noUnnecessaryTypeAssertions1.ts, 30, 3))

x! = undefined;
>x : Symbol(x, Decl(noUnnecessaryTypeAssertions1.ts, 30, 3))
>undefined : Symbol(undefined)

let y: number;
>y : Symbol(y, Decl(noUnnecessaryTypeAssertions1.ts, 33, 3))

y! = 2;
>y : Symbol(y, Decl(noUnnecessaryTypeAssertions1.ts, 33, 3))

function generic<T extends object | null, U extends object>(x: T, y: U) {
>generic : Symbol(generic, Decl(noUnnecessaryTypeAssertions1.ts, 34, 7))
>T : Symbol(T, Decl(noUnnecessaryTypeAssertions1.ts, 36, 17))
>U : Symbol(U, Decl(noUnnecessaryTypeAssertions1.ts, 36, 41))
>x : Symbol(x, Decl(noUnnecessaryTypeAssertions1.ts, 36, 60))
>T : Symbol(T, Decl(noUnnecessaryTypeAssertions1.ts, 36, 17))
>y : Symbol(y, Decl(noUnnecessaryTypeAssertions1.ts, 36, 65))
>U : Symbol(U, Decl(noUnnecessaryTypeAssertions1.ts, 36, 41))

    const a: object = x!;
>a : Symbol(a, Decl(noUnnecessaryTypeAssertions1.ts, 37, 9))
>x : Symbol(x, Decl(noUnnecessaryTypeAssertions1.ts, 36, 60))

    const b: object = y!;
>b : Symbol(b, Decl(noUnnecessaryTypeAssertions1.ts, 38, 9))
>y : Symbol(y, Decl(noUnnecessaryTypeAssertions1.ts, 36, 65))
}

