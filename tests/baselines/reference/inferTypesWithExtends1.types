=== tests/cases/conformance/types/conditional/inferTypesWithExtends1.ts ===
// infer to tuple element
type X1<T extends any[]> =
>X1 : X1<T>

    T extends [infer U extends string] ? ["string", U] :
    T extends [infer U extends number] ? ["number", U] :
    never;

type X1_T1 = X1<["a"]>; // ["string", "a"]
>X1_T1 : ["string", "a"]

type X1_T2 = X1<[1]>; // ["number", 1]
>X1_T2 : ["number", 1]

type X1_T3 = X1<[object]>; // never
>X1_T3 : never

// infer to argument
type X2<T extends (...args: any[]) => void> =
>X2 : X2<T>
>args : any[]

    T extends (a: infer U extends string) => void ? ["string", U] :
>a : U

    T extends (a: infer U extends number) => void ? ["number", U] :
>a : U

    never;

type X2_T1 = X2<(a: "a") => void>; // ["string", "a"]
>X2_T1 : ["string", "a"]
>a : "a"

type X2_T2 = X2<(a: 1) => void>; // ["number", 1]
>X2_T2 : ["number", 1]
>a : 1

type X2_T3 = X2<(a: object) => void>; // never
>X2_T3 : never
>a : object

// infer to return type
type X3<T extends (...args: any[]) => any> =
>X3 : X3<T>
>args : any[]

    T extends (...args: any[]) => infer U extends string ? ["string", U] :
>args : any[]

    T extends (...args: any[]) => infer U extends number ? ["number", U] :
>args : any[]

    never;

type X3_T1 = X3<() => "a">; // ["string", "a"]
>X3_T1 : ["string", "a"]

type X3_T2 = X3<() => 1>; // ["number", 1]
>X3_T2 : ["number", 1]

type X3_T3 = X3<() => object>; // never
>X3_T3 : never

// infer to instance type
type X4<T extends new (...args: any[]) => any> =
>X4 : X4<T>
>args : any[]

    T extends new (...args: any[]) => infer U extends { a: string } ? ["string", U] :
>args : any[]
>a : string

    T extends new (...args: any[]) => infer U extends { a: number } ? ["number", U] :
>args : any[]
>a : number

    never;

type X4_T1 = X4<new () => { a: "a" }>; // ["string", { a: "a" }]
>X4_T1 : ["string", { a: "a"; }]
>a : "a"

type X4_T2 = X4<new () => { a: 1 }>; // ["number", { a: 1 }]
>X4_T2 : ["number", { a: 1; }]
>a : 1

type X4_T3 = X4<new () => { a: object }>; // never
>X4_T3 : never
>a : object

// infer to type argument
type X5<T> =
>X5 : X5<T>

    T extends Promise<infer U extends string> ? ["string", U] :
    T extends Promise<infer U extends number> ? ["number", U] :
    never;

type X5_T1 = X5<Promise<"a" | "b">>; // ["string", "a" | "b"]
>X5_T1 : ["string", "a" | "b"]

type X5_T2 = X5<Promise<1 | 2>>; // ["number", 1 | 2]
>X5_T2 : ["number", 1 | 2]

type X5_T3 = X5<Promise<1n | 2n>>; // never
>X5_T3 : never

// infer to property type
type X6<T> =
>X6 : X6<T>

    T extends { a: infer U extends string } ? ["string", U] :
>a : U

    T extends { a: infer U extends number } ? ["number", U] :
>a : U

    never;

type X6_T1 = X6<{ a: "a" }>; // ["string", "a"]
>X6_T1 : ["string", "a"]
>a : "a"

type X6_T2 = X6<{ a: 1 }>; // ["number", 1]
>X6_T2 : ["number", 1]
>a : 1

type X6_T3 = X6<{ a: object }>; // never
>X6_T3 : never
>a : object

// infer twice with same constraint
type X7<T> =
>X7 : X7<T>

    T extends { a: infer U extends string, b: infer U extends string } ? ["string", U] :
>a : U
>b : U

    T extends { a: infer U extends number, b: infer U extends number } ? ["number", U] :
>a : U
>b : U

    never;

type X7_T1 = X7<{ a: "a", b: "b" }>; // ["string", "a" | "b"]
>X7_T1 : ["string", "a" | "b"]
>a : "a"
>b : "b"

type X7_T2 = X7<{ a: 1, b: 2 }>; // ["number", 1 | 2]
>X7_T2 : ["number", 1 | 2]
>a : 1
>b : 2

type X7_T3 = X7<{ a: object, b: object }>; // never
>X7_T3 : never
>a : object
>b : object

type X7_T4 = X7<{ a: "a", b: 1 }>; // never
>X7_T4 : never
>a : "a"
>b : 1

// infer twice with missing second constraint (same behavior as class/interface)
type X8<T> =
>X8 : X8<T>

    T extends { a: infer U extends string, b: infer U } ? ["string", U] :
>a : U
>b : U

    T extends { a: infer U extends number, b: infer U } ? ["number", U] :
>a : U
>b : U

    never;

type X8_T1 = X8<{ a: "a", b: "b" }>; // ["string", "a" | "b"]
>X8_T1 : ["string", "a" | "b"]
>a : "a"
>b : "b"

type X8_T2 = X8<{ a: 1, b: 2 }>; // ["number", 1 | 2]
>X8_T2 : ["number", 1 | 2]
>a : 1
>b : 2

type X8_T3 = X8<{ a: object, b: object }>; // never
>X8_T3 : never
>a : object
>b : object

type X8_T4 = X8<{ a: "a", b: 1 }>; // never
>X8_T4 : never
>a : "a"
>b : 1

// infer twice with missing first constraint (same behavior as class/interface)
type X9<T> =
>X9 : X9<T>

    T extends { a: infer U, b: infer U extends string } ? ["string", U] :
>a : U
>b : U

    T extends { a: infer U, b: infer U extends number } ? ["number", U] :
>a : U
>b : U

    never;

type X9_T1 = X9<{ a: "a", b: "b" }>; // ["string", "a" | "b"]
>X9_T1 : ["string", "a" | "b"]
>a : "a"
>b : "b"

type X9_T2 = X9<{ a: 1, b: 2 }>; // ["number", 1 | 2]
>X9_T2 : ["number", 1 | 2]
>a : 1
>b : 2

type X9_T3 = X9<{ a: object, b: object }>; // never
>X9_T3 : never
>a : object
>b : object

type X9_T4 = X9<{ a: "a", b: 1 }>; // never
>X9_T4 : never
>a : "a"
>b : 1

