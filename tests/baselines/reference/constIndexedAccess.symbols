=== tests/cases/compiler/constIndexedAccess.ts ===

const enum numbers {
>numbers : Symbol(numbers, Decl(constIndexedAccess.ts, 0, 0))

	zero,
>zero : Symbol(numbers.zero, Decl(constIndexedAccess.ts, 1, 20))

	one
>one : Symbol(numbers.one, Decl(constIndexedAccess.ts, 2, 6))
}

interface access {
>access : Symbol(access, Decl(constIndexedAccess.ts, 4, 1))

	0: string;
	1: number;
}

let test: access;
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>access : Symbol(access, Decl(constIndexedAccess.ts, 4, 1))

let s = test[0];
>s : Symbol(s, Decl(constIndexedAccess.ts, 13, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>0 : Symbol(access.0, Decl(constIndexedAccess.ts, 6, 18))

let n = test[1];
>n : Symbol(n, Decl(constIndexedAccess.ts, 14, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>1 : Symbol(access.1, Decl(constIndexedAccess.ts, 7, 11))

let s1 = test[numbers.zero];
>s1 : Symbol(s1, Decl(constIndexedAccess.ts, 16, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>numbers.zero : Symbol(numbers.zero, Decl(constIndexedAccess.ts, 1, 20))
>numbers : Symbol(numbers, Decl(constIndexedAccess.ts, 0, 0))
>zero : Symbol(numbers.zero, Decl(constIndexedAccess.ts, 1, 20))

let n1 = test[numbers.one];
>n1 : Symbol(n1, Decl(constIndexedAccess.ts, 17, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>numbers.one : Symbol(numbers.one, Decl(constIndexedAccess.ts, 2, 6))
>numbers : Symbol(numbers, Decl(constIndexedAccess.ts, 0, 0))
>one : Symbol(numbers.one, Decl(constIndexedAccess.ts, 2, 6))

// TODO: Not working
const zero = 0;
>zero : Symbol(zero, Decl(constIndexedAccess.ts, 20, 5))

const one = 1;
>one : Symbol(one, Decl(constIndexedAccess.ts, 21, 5))

let s2 = test[zero];
>s2 : Symbol(s2, Decl(constIndexedAccess.ts, 23, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>zero : Symbol(zero, Decl(constIndexedAccess.ts, 20, 5))

let n2 = test[one];
>n2 : Symbol(n2, Decl(constIndexedAccess.ts, 24, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>one : Symbol(one, Decl(constIndexedAccess.ts, 21, 5))

const zeroRef = zero;
>zeroRef : Symbol(zeroRef, Decl(constIndexedAccess.ts, 26, 5))
>zero : Symbol(zero, Decl(constIndexedAccess.ts, 20, 5))

const oneRef = one;
>oneRef : Symbol(oneRef, Decl(constIndexedAccess.ts, 27, 5))
>one : Symbol(one, Decl(constIndexedAccess.ts, 21, 5))

let s3 = test[zeroRef];
>s3 : Symbol(s3, Decl(constIndexedAccess.ts, 29, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>zeroRef : Symbol(zeroRef, Decl(constIndexedAccess.ts, 26, 5))

let n3 = test[oneRef];
>n3 : Symbol(n3, Decl(constIndexedAccess.ts, 30, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>oneRef : Symbol(oneRef, Decl(constIndexedAccess.ts, 27, 5))

const zeroRefEnum = numbers.zero;
>zeroRefEnum : Symbol(zeroRefEnum, Decl(constIndexedAccess.ts, 32, 5))
>numbers.zero : Symbol(numbers.zero, Decl(constIndexedAccess.ts, 1, 20))
>numbers : Symbol(numbers, Decl(constIndexedAccess.ts, 0, 0))
>zero : Symbol(numbers.zero, Decl(constIndexedAccess.ts, 1, 20))

const oneRefEnum = numbers.one;
>oneRefEnum : Symbol(oneRefEnum, Decl(constIndexedAccess.ts, 33, 5))
>numbers.one : Symbol(numbers.one, Decl(constIndexedAccess.ts, 2, 6))
>numbers : Symbol(numbers, Decl(constIndexedAccess.ts, 0, 0))
>one : Symbol(numbers.one, Decl(constIndexedAccess.ts, 2, 6))

let s4 = test[zeroRefEnum];
>s4 : Symbol(s4, Decl(constIndexedAccess.ts, 35, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>zeroRefEnum : Symbol(zeroRefEnum, Decl(constIndexedAccess.ts, 32, 5))

let n4 = test[oneRefEnum];
>n4 : Symbol(n4, Decl(constIndexedAccess.ts, 36, 3))
>test : Symbol(test, Decl(constIndexedAccess.ts, 11, 3))
>oneRefEnum : Symbol(oneRefEnum, Decl(constIndexedAccess.ts, 33, 5))

