//// [tests/cases/conformance/asEnum/asEnumBasics.ts] ////

=== asEnumBasics.ts ===
// Enum without initializers have first member = 0 and successive members = N + 1

// Enum literal syntax does not implement auto-incrementing behaviour.
let ExistingShorthand = "exists";
>ExistingShorthand : string
>                  : ^^^^^^
>"exists" : "exists"
>         : ^^^^^^^^

const E1: enum = {
>E1 : E1
>   : ^^
>E1 : E1
>   : ^^

    NonexistingShorthand, // error -- EnumLiteralExpressions require explicit property definitions.
>NonexistingShorthand : E1.NonexistingShorthand
>                     : ^^^^^^^^^^^^^^^^^^^^^^^

    ExistingShorthand, // error -- EnumLiteralExpressions require explicit property definitions.
>ExistingShorthand : E1.ExistingShorthand
>                  : ^^^^^^^^^^^^^^^^^^^^

    Int: 1, // ok
>Int : E1.Int
>    : ^^^^^^
>1 : 1
>  : ^

    String: "string", // ok
>String : E1.String
>       : ^^^^^^^^^
>"string" : "string"
>         : ^^^^^^^^

    Flag: 8, // ok
>Flag : E1.Flag
>     : ^^^^^^^
>8 : 8
>  : ^

};

// Valid assignments
const nonexist: E1 = E1.NonexistingShorthand; // ok
>nonexist : E1
>         : ^^
>E1.NonexistingShorthand : E1.NonexistingShorthand
>                        : ^^^^^^^^^^^^^^^^^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>NonexistingShorthand : E1.NonexistingShorthand
>                     : ^^^^^^^^^^^^^^^^^^^^^^^

const exist: E1 = E1.ExistingShorthand; // ok
>exist : E1
>      : ^^
>E1.ExistingShorthand : E1.ExistingShorthand
>                     : ^^^^^^^^^^^^^^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>ExistingShorthand : E1.ExistingShorthand
>                  : ^^^^^^^^^^^^^^^^^^^^

const ival: E1 = E1.Int; // ok
>ival : E1
>     : ^^
>E1.Int : E1.Int
>       : ^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>Int : E1.Int
>    : ^^^^^^

const sval: E1 = E1.String; // ok
>sval : E1
>     : ^^
>E1.String : E1.String
>          : ^^^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>String : E1.String
>       : ^^^^^^^^^

// Assigning values which are not part of the enum despite being present in the enum
const nonexist_bad: E1 = undefined; // error
>nonexist_bad : E1
>             : ^^
>undefined : undefined
>          : ^^^^^^^^^

const exist_bad: E1 = "exists"; // error
>exist_bad : E1
>          : ^^
>"exists" : "exists"
>         : ^^^^^^^^

const ival_good: E1 = 1; // ok -- TypeScript is permissive of this in enums, to permit things like bitwise combinations of enum values.
>ival_good : E1
>          : ^^
>1 : 1
>  : ^

const sval_bad: E1 = "string"; // error
>sval_bad : E1
>         : ^^
>"string" : "string"
>         : ^^^^^^^^

const ival_notpresent: E1 = 4; // ok -- TypeScript is permissive of this in enums, to permit things like bitwise combinations of enum values.
>ival_notpresent : E1
>                : ^^
>4 : 4
>  : ^

function functest(value: E1) {
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>value : E1
>      : ^^

    console.log(value);
>console.log(value) : void
>                   : ^^^^
>console.log : (...data: any[]) => void
>            : ^^^^    ^^     ^^^^^    
>console : Console
>        : ^^^^^^^
>log : (...data: any[]) => void
>    : ^^^^    ^^     ^^^^^    
>value : E1
>      : ^^

    return value;
>value : E1
>      : ^^
}

const nonexist_bad2: E1 = functest(undefined); // error
>nonexist_bad2 : E1
>              : ^^
>functest(undefined) : E1
>                    : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>undefined : undefined
>          : ^^^^^^^^^

const exist_bad2: E1 = functest("exists"); // error
>exist_bad2 : E1
>           : ^^
>functest("exists") : E1
>                   : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>"exists" : "exists"
>         : ^^^^^^^^

const ival_good2: E1 = functest(1); // ok
>ival_good2 : E1
>           : ^^
>functest(1) : E1
>            : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>1 : 1
>  : ^

const ival_good3: E1 = functest(4); // ok
>ival_good3 : E1
>           : ^^
>functest(4) : E1
>            : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>4 : 4
>  : ^

const ival_good4: E1 = functest(E1.Int | E1.Flag); // ok
>ival_good4 : E1
>           : ^^
>functest(E1.Int | E1.Flag) : E1
>                           : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>E1.Int | E1.Flag : number
>                 : ^^^^^^
>E1.Int : E1.Int
>       : ^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>Int : E1.Int
>    : ^^^^^^
>E1.Flag : E1.Flag
>        : ^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>Flag : E1.Flag
>     : ^^^^^^^

const sval_good2: E1 = functest(E1.String);
>sval_good2 : E1
>           : ^^
>functest(E1.String) : E1
>                    : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>E1.String : E1.String
>          : ^^^^^^^^^
>E1 : typeof E1
>   : ^^^^^^^^^
>String : E1.String
>       : ^^^^^^^^^

const sval_bad2: E1 = functest("string"); // error
>sval_bad2 : E1
>          : ^^
>functest("string") : E1
>                   : ^^
>functest : (value: E1) => E1
>         : ^     ^^^^^^^^^^^
>"string" : "string"
>         : ^^^^^^^^

