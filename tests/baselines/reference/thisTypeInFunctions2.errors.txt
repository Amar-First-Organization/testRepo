tests/cases/conformance/types/thisType/thisTypeInFunctions2.ts(14,5): error TS7010: 'foo', which lacks return-type annotation, implicitly has an 'any' return type.
tests/cases/conformance/types/thisType/thisTypeInFunctions2.ts(36,14): error TS7041: Property 'mine' implicitly has type 'any' because the base class is of type 'any'.
tests/cases/conformance/types/thisType/thisTypeInFunctions2.ts(41,14): error TS7041: Property 'mine' implicitly has type 'any' because the base class is of type 'any'.


==== tests/cases/conformance/types/thisType/thisTypeInFunctions2.ts (3 errors) ====
    interface IndexedWithThis {
        // this is a workaround for React
        init?: (this: this) => void;
        willDestroy?: (this: any) => void;
        [propName: string]: number | string | boolean | symbol | undefined | null | {} | ((this: any, ...args:any[]) => any);
    }
    interface IndexedWithoutThis {
        // this is what React would like to write (and what they write today)
        init?: () => void;
        willDestroy?: () => void;
        [propName: string]: any;
    }
    interface SimpleInterface {
        foo(n: string);
        ~~~~~~~~~~~~~~~
!!! error TS7010: 'foo', which lacks return-type annotation, implicitly has an 'any' return type.
        bar(): number;
    }
    declare function extend1(args: IndexedWithThis): void;
    declare function extend2(args: IndexedWithoutThis): void;
    declare function simple(arg: SimpleInterface): void;
    
    extend1({
        init() {
            this // this: IndexedWithThis because of contextual typing.
            // this.mine
            this.willDestroy
        },
        mine: 12,
        foo() {
            this.url; // this: any because 'foo' matches the string indexer
            this.willDestroy;
        }
    });
    extend2({
        init() {
            this // this: IndexedWithoutThis because of contextual typing
            this.mine
                 ~~~~
!!! error TS7041: Property 'mine' implicitly has type 'any' because the base class is of type 'any'.
        },
        mine: 13,
        foo() {
            this // this: IndexedWithoutThis because of contextual typing
            this.mine
                 ~~~~
!!! error TS7041: Property 'mine' implicitly has type 'any' because the base class is of type 'any'.
        }
    });
    
    simple({
        foo(n) {
            return n.length + this.bar();
        },
        bar() {
            return 14;
        }
    })
    