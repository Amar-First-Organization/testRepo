//// [tests/cases/compiler/inferenceGenericNestedCallReturningConstructor.ts] ////

=== inferenceGenericNestedCallReturningConstructor.ts ===
interface AssignObject<TContext> {
  new (ctx: TContext): void;
>ctx : TContext
}

declare function assign<TContext>(
>assign : <TContext>(assigner: (ctx: TContext) => void) => AssignObject<TContext>

  assigner: (ctx: TContext) => void
>assigner : (ctx: TContext) => void
>ctx : TContext

): AssignObject<TContext>;

declare function createMachine<TContext>(config: {
>createMachine : <TContext>(config: {    context: TContext;    entry: AssignObject<TContext>;}) => void
>config : { context: TContext; entry: AssignObject<TContext>; }

  context: TContext;
>context : TContext

  entry: AssignObject<TContext>;
>entry : AssignObject<TContext>

}): void;

createMachine({
>createMachine({  context: { count: 0 },  entry: assign((ctx) => {    ctx // { count: number }  }),}) : void
>createMachine : <TContext>(config: { context: TContext; entry: AssignObject<TContext>; }) => void
>{  context: { count: 0 },  entry: assign((ctx) => {    ctx // { count: number }  }),} : { context: { count: number; }; entry: AssignObject<{ count: number; }>; }

  context: { count: 0 },
>context : { count: number; }
>{ count: 0 } : { count: number; }
>count : number
>0 : 0

  entry: assign((ctx) => {
>entry : AssignObject<{ count: number; }>
>assign((ctx) => {    ctx // { count: number }  }) : AssignObject<{ count: number; }>
>assign : <TContext>(assigner: (ctx: TContext) => void) => AssignObject<TContext>
>(ctx) => {    ctx // { count: number }  } : (ctx: { count: number; }) => void
>ctx : { count: number; }

    ctx // { count: number }
>ctx : { count: number; }

  }),
});

