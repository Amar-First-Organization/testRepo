=== tests/cases/conformance/types/primitives/numericLiteral/InfinityLiteralTypes.ts ===
interface PositiveInfinityMember {
>PositiveInfinityMember : PositiveInfinityMember

    member: Infinity
>member : Infinity
>Infinity : Infinity
}

interface NegativeInfinityMember {
>NegativeInfinityMember : NegativeInfinityMember

    member: -Infinity
>member : -Infinity
}

function invertInfinity(x: -Infinity): Infinity;
>invertInfinity : { (x: -Infinity): Infinity; (x: Infinity): -Infinity; }
>x : -Infinity
>Infinity : Infinity

function invertInfinity(x: Infinity): -Infinity;
>invertInfinity : { (x: -Infinity): Infinity; (x: Infinity): -Infinity; }
>x : Infinity
>Infinity : Infinity

function invertInfinity(x: number): number {
>invertInfinity : { (x: -Infinity): Infinity; (x: Infinity): -Infinity; }
>x : number

    return -x;
>-x : number
>x : number
}

let a: PositiveInfinityMember;
>a : PositiveInfinityMember
>PositiveInfinityMember : PositiveInfinityMember

let b: NegativeInfinityMember;
>b : NegativeInfinityMember
>NegativeInfinityMember : NegativeInfinityMember

a = {member: Infinity as Infinity};
>a = {member: Infinity as Infinity} : { member: Infinity; }
>a : PositiveInfinityMember
>{member: Infinity as Infinity} : { member: Infinity; }
>member : Infinity
>Infinity as Infinity : Infinity
>Infinity : number
>Infinity : Infinity

b = {member: -(<Infinity>Infinity)}
>b = {member: -(<Infinity>Infinity)} : { member: -Infinity; }
>b : NegativeInfinityMember
>{member: -(<Infinity>Infinity)} : { member: -Infinity; }
>member : -Infinity
>-(<Infinity>Infinity) : -Infinity
>(<Infinity>Infinity) : Infinity
><Infinity>Infinity : Infinity
>Infinity : Infinity
>Infinity : number

let c: -Infinity = invertInfinity(a.member);
>c : -Infinity
>invertInfinity(a.member) : -Infinity
>invertInfinity : { (x: -Infinity): Infinity; (x: Infinity): -Infinity; }
>a.member : Infinity
>a : PositiveInfinityMember
>member : Infinity

let d: Infinity = invertInfinity(b.member);
>d : Infinity
>Infinity : Infinity
>invertInfinity(b.member) : Infinity
>invertInfinity : { (x: -Infinity): Infinity; (x: Infinity): -Infinity; }
>b.member : -Infinity
>b : NegativeInfinityMember
>member : -Infinity

let x = c + d;
>x : NaN
>c + d : NaN
>c : -Infinity
>d : Infinity

declare function stillNumber(x: number): boolean;
>stillNumber : (x: number) => boolean
>x : number

stillNumber(c);
>stillNumber(c) : boolean
>stillNumber : (x: number) => boolean
>c : -Infinity

stillNumber(d);
>stillNumber(d) : boolean
>stillNumber : (x: number) => boolean
>d : Infinity

//Check that Infinity's declaration is still of type "number", while being "Infinity" when used as a type, so its usage is opt-in
let y = Infinity;
>y : number
>Infinity : number

y = 42;
>y = 42 : number
>y : number
>42 : number

let z = -Infinity;
>z : number
>-Infinity : number
>Infinity : number

z = 42;
>z = 42 : number
>z : number
>42 : number

/*declare function isInfinity(x: number): x is (Infinity | -Infinity) {
    return x !== x;
}

let y: number;
if (isInfinity(y)) {
    let a: (Infinity | -Infinity) = y;
}
else {
    let b: number = y;
}*/
