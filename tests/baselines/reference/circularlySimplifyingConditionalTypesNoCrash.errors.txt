tests/cases/compiler/circularlySimplifyingConditionalTypesNoCrash.ts(3,6): error TS2456: Type alias 'Shared' circularly references itself.
tests/cases/compiler/circularlySimplifyingConditionalTypesNoCrash.ts(5,35): error TS2313: Type parameter 'DecorationTargetProps' has a circular constraint.
tests/cases/compiler/circularlySimplifyingConditionalTypesNoCrash.ts(5,35): error TS2315: Type 'Shared' is not generic.
tests/cases/compiler/circularlySimplifyingConditionalTypesNoCrash.ts(7,15): error TS2313: Type parameter 'P' has a circular constraint.
tests/cases/compiler/circularlySimplifyingConditionalTypesNoCrash.ts(7,75): error TS2536: Type 'P' cannot be used to index type 'InjectedProps'.
tests/cases/compiler/circularlySimplifyingConditionalTypesNoCrash.ts(7,100): error TS2536: Type 'P' cannot be used to index type 'DecorationTargetProps'.
tests/cases/compiler/circularlySimplifyingConditionalTypesNoCrash.ts(7,127): error TS2536: Type 'P' cannot be used to index type 'DecorationTargetProps'.
tests/cases/compiler/circularlySimplifyingConditionalTypesNoCrash.ts(15,16): error TS2315: Type 'Shared' is not generic.
tests/cases/compiler/circularlySimplifyingConditionalTypesNoCrash.ts(17,37): error TS2315: Type 'Shared' is not generic.


==== tests/cases/compiler/circularlySimplifyingConditionalTypesNoCrash.ts (9 errors) ====
    type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
    
    type Shared< // Circularly self constraining type, defered thanks to mapping
         ~~~~~~
!!! error TS2456: Type alias 'Shared' circularly references itself.
        InjectedProps,
        DecorationTargetProps extends Shared<InjectedProps, DecorationTargetProps>
                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2313: Type parameter 'DecorationTargetProps' has a circular constraint.
                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2315: Type 'Shared' is not generic.
        > = {
            [P in Extract<keyof InjectedProps, keyof DecorationTargetProps>]: InjectedProps[P] extends DecorationTargetProps[P] ? DecorationTargetProps[P] : never;
                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2313: Type parameter 'P' has a circular constraint.
!!! related TS2751 tests/cases/compiler/circularlySimplifyingConditionalTypesNoCrash.ts:5:35: Circularity originates in type at this location.
                                                                              ~~~~~~~~~~~~~~~~
!!! error TS2536: Type 'P' cannot be used to index type 'InjectedProps'.
                                                                                                       ~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2536: Type 'P' cannot be used to index type 'DecorationTargetProps'.
                                                                                                                                  ~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2536: Type 'P' cannot be used to index type 'DecorationTargetProps'.
        };
    
    interface ComponentClass<P> {
        defaultProps?: Partial<P>; // Inference target is also mapped _and_ optional
    }
    
    interface InferableComponentEnhancerWithProps<TInjectedProps, TNeedsProps> {
        <P extends Shared<TInjectedProps, P>>(
                   ~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2315: Type 'Shared' is not generic.
            component: ComponentClass<P>
        ): ComponentClass<Omit<P, keyof Shared<TInjectedProps, P>> & TNeedsProps> & { WrappedComponent: ComponentClass<P> }
                                        ~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2315: Type 'Shared' is not generic.
    } // Then intersected with and indexed via Omit and &
    
    interface Connect { // Then strictly compared with another signature in its context
        <TStateProps, TOwnProps>(
            mapStateToProps: unknown,
        ): InferableComponentEnhancerWithProps<TStateProps, TOwnProps>;
    
        <TDispatchProps, TOwnProps>(
            mapStateToProps: null | undefined,
            mapDispatchToProps: unknown,
            mergeProps: null | undefined,
            options: unknown
        ): InferableComponentEnhancerWithProps<TDispatchProps, TOwnProps>;
    }
    
    declare var connect: Connect;
    
    const myStoreConnect: Connect = function(
        mapStateToProps?: any,
        mapDispatchToProps?: any,
        mergeProps?: any,
        options: unknown = {},
    ) {
        return connect(
            mapStateToProps,
            mapDispatchToProps,
            mergeProps,
            options,
        );
    };