=== tests/cases/compiler/arrayForEachNarrowing.ts ===
const foo: (number | string)[] = ['aaa'];
>foo : (string | number)[]
>['aaa'] : string[]
>'aaa' : "aaa"

function assertString(x: unknown): asserts x is string {
>assertString : (x: unknown) => asserts x is string
>x : unknown

  if (typeof x !== 'string') throw new Error('Must be a string!');
>typeof x !== 'string' : boolean
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>x : unknown
>'string' : "string"
>new Error('Must be a string!') : Error
>Error : ErrorConstructor
>'Must be a string!' : "Must be a string!"
}

foo.forEach(assertString);
>foo.forEach(assertString) : void
>foo.forEach : { <S extends string | number>(callbackfn: (value: string | number, index: number, array: (string | number)[]) => asserts value is S, thisArg?: any): asserts this is S[]; (callbackfn: (value: string | number, index: number, array: (string | number)[]) => void, thisArg?: any): void; }
>foo : (string | number)[]
>forEach : { <S extends string | number>(callbackfn: (value: string | number, index: number, array: (string | number)[]) => asserts value is S, thisArg?: any): asserts this is S[]; (callbackfn: (value: string | number, index: number, array: (string | number)[]) => void, thisArg?: any): void; }
>assertString : (x: unknown) => asserts x is string

foo[0].slice(0);
>foo[0].slice(0) : string
>foo[0].slice : (start?: number, end?: number) => string
>foo[0] : string
>foo : string[]
>0 : 0
>slice : (start?: number, end?: number) => string
>0 : 0

