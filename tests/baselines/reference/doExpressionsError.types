=== tests/cases/compiler/doExpressionsError.ts ===
// No return
function a() {
>a : () => void

    const x = do {
>x : void
>do {        function ok() {            return 1;        }        return 2; // error on this node    } : void

        function ok() {
>ok : () => number

            return 1;
>1 : 1
        }
        return 2; // error on this node
>2 : 2

    };
}
// No break / continue across do expr
// Todo:

// No iteration / declaration at the end

;[
>[    do { var a = 1 },    do { function x() { } },    do { const a = 1 },    do { let a = 1 },    do { class T {} },    do { enum T {} },] : void[]

    do { var a = 1 },
>do { var a = 1 } : void
>a : number
>1 : 1

    do { function x() { } },
>do { function x() { } } : void
>x : { (): void; (): void; }

    do { const a = 1 },
>do { const a = 1 } : void
>a : 1
>1 : 1

    do { let a = 1 },
>do { let a = 1 } : void
>a : number
>1 : 1

    do { class T {} },
>do { class T {} } : void
>T : T

    do { enum T {} },
>do { enum T {} } : void
>T : T

]

;[
>[    do { for (const x of []) {} },    do { for (const x in {}) {} },    do { for (let i = 0; i < [].length; i++) {} },    do { while(true) {} },    do { do {} while(true) }] : void[]

    do { for (const x of []) {} },
>do { for (const x of []) {} } : void
>x : any
>[] : undefined[]

    do { for (const x in {}) {} },
>do { for (const x in {}) {} } : void
>x : string
>{} : {}

    do { for (let i = 0; i < [].length; i++) {} },
>do { for (let i = 0; i < [].length; i++) {} } : void
>i : number
>0 : 0
>i < [].length : boolean
>i : number
>[].length : number
>[] : undefined[]
>length : number
>i++ : number
>i : number

    do { while(true) {} },
>do { while(true) {} } : void
>true : true

    do { do {} while(true) }
>do { do {} while(true) } : void
>true : true

]
;

// But in non-end position

;[
>[    do { var a = 1; a },    do { function x() { }; x },    do { const a = 1; a },    do { let a = 1; a },    do { class T {}; T },    do { enum T {}; T },] : (number | (() => void) | typeof T | typeof T)[]

    do { var a = 1; a },
>do { var a = 1; a } : () => void
>a : number
>1 : 1
>a : () => void

    do { function x() { }; x },
>do { function x() { }; x } : { (): void; (): void; }
>x : { (): void; (): void; }
>x : { (): void; (): void; }

    do { const a = 1; a },
>do { const a = 1; a } : 1
>a : 1
>1 : 1
>a : 1

    do { let a = 1; a },
>do { let a = 1; a } : number
>a : number
>1 : 1
>a : number

    do { class T {}; T },
>do { class T {}; T } : typeof T
>T : T
>T : typeof T

    do { enum T {}; T },
>do { enum T {}; T } : typeof T
>T : T
>T : typeof T

]

;[
>[    do { for (const x of []) {}; 1 },    do { for (const x in {}) {}; 1 },    do { for (let i = 0; i < [].length; i++) {}; 1 },    do { while(true) {}; 1 },    do { do {} while(true); 1 }] : number[]

    do { for (const x of []) {}; 1 },
>do { for (const x of []) {}; 1 } : 1
>x : any
>[] : undefined[]
>1 : 1

    do { for (const x in {}) {}; 1 },
>do { for (const x in {}) {}; 1 } : 1
>x : string
>{} : {}
>1 : 1

    do { for (let i = 0; i < [].length; i++) {}; 1 },
>do { for (let i = 0; i < [].length; i++) {}; 1 } : 1
>i : number
>0 : 0
>i < [].length : boolean
>i : number
>[].length : number
>[] : undefined[]
>length : number
>i++ : number
>i : number
>1 : 1

    do { while(true) {}; 1 },
>do { while(true) {}; 1 } : 1
>true : true
>1 : 1

    do { do {} while(true); 1 }
>do { do {} while(true); 1 } : 1
>true : true
>1 : 1

]
