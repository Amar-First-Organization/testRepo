=== tests/cases/conformance/types/spread/objectSpreadUnion.ts ===
// concrete types work
interface A1 { a: number }
>A1 : A1
>a : number

interface A2 { a: string }
>A2 : A2
>a : string

let a12: A1 | A2;
>a12 : A1 | A2
>A1 : A1
>A2 : A2

let result = { ...a12 };
>result : { a: number; } | { a: string; }
>{ ...a12 } : { a: number; } | { a: string; }
>a12 : A1 | A2

let sn: number | string = result.a;
>sn : string | number
>result.a : string | number
>result : { a: number; } | { a: string; }
>a : string | number

let assignable: spread(A1 | A2) = result;
>assignable : { a: number; } | { a: string; }
>A1 : A1
>A2 : A2
>result : { a: number; } | { a: string; }

function tripleUnion<T, U, V>(t: T, u: U, v: V): void {
>tripleUnion : <T, U, V>(t: T, u: U, v: V) => void
>T : T
>U : U
>V : V
>t : T
>T : T
>u : U
>U : U
>v : V
>V : V

    let tuv: T | U | V;
>tuv : T | U | V
>T : T
>U : U
>V : V

    let result = { ...tuv, id: 'foo' };
>result : spread(T, { id: string; }) | spread(U, { id: string; }) | spread(V, { id: string; })
>{ ...tuv, id: 'foo' } : spread(T, { id: string; }) | spread(U, { id: string; }) | spread(V, { id: string; })
>tuv : T | U | V
>id : string
>'foo' : "foo"

    let expected: spread(T, { id: string }) | spread(U, { id: string }) | spread(V, { id: string }) = result;
>expected : spread(T, { id: string; }) | spread(U, { id: string; }) | spread(V, { id: string; })
>T : T
>id : string
>U : U
>id : string
>V : V
>id : string
>result : spread(T, { id: string; }) | spread(U, { id: string; }) | spread(V, { id: string; })

    let assignable: spread(T | U | V, { id: string }) = result;
>assignable : spread(T, { id: string; }) | spread(U, { id: string; }) | spread(V, { id: string; })
>T : T
>U : U
>V : V
>id : string
>result : spread(T, { id: string; }) | spread(U, { id: string; }) | spread(V, { id: string; })
}
function iteratedDoubleUnion<T, U, V>(t: T, u: U, v: V): void {
>iteratedDoubleUnion : <T, U, V>(t: T, u: U, v: V) => void
>T : T
>U : U
>V : V
>t : T
>T : T
>u : U
>U : U
>v : V
>V : V

    let tu: T | U;
>tu : T | U
>T : T
>U : U

    let uv: U | V;
>uv : U | V
>U : U
>V : V

    let result = { ...tu, ...uv, id: 'bar' };
>result : spread(U, { id: string; }) | spread(spread(T, U), { id: string; }) | spread(spread(T, V), { id: string; }) | spread(spread(U, V), { id: string; })
>{ ...tu, ...uv, id: 'bar' } : spread(U, { id: string; }) | spread(spread(T, U), { id: string; }) | spread(spread(T, V), { id: string; }) | spread(spread(U, V), { id: string; })
>tu : T | U
>uv : U | V
>id : string
>'bar' : "bar"

    let expected: spread(spread(T, U), { id: string }) | spread(spread(T, V), { id: string }) | spread(U, { id: string }) | spread(spread(U, V), { id: string });
>expected : spread(spread(T, U), { id: string; }) | spread(spread(T, V), { id: string; }) | spread(U, { id: string; }) | spread(spread(U, V), { id: string; })
>T : T
>U : U
>id : string
>T : T
>V : V
>id : string
>U : U
>id : string
>U : U
>V : V
>id : string

    let assignable: spread(spread(T | U, U | V), { id: string }) = result;
>assignable : spread(U, { id: string; }) | spread(spread(T, U), { id: string; }) | spread(spread(T, V), { id: string; }) | spread(spread(U, V), { id: string; })
>T : T
>U : U
>U : U
>V : V
>id : string
>result : spread(U, { id: string; }) | spread(spread(T, U), { id: string; }) | spread(spread(T, V), { id: string; }) | spread(spread(U, V), { id: string; })
}

