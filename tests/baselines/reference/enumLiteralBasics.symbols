//// [tests/cases/conformance/enums/enumLiteralBasics.ts] ////

=== enumLiteralBasics.ts ===
// Enum without initializers have first member = 0 and successive members = N + 1

// Enum literal syntax does not implement auto-incrementing behaviour.
let ExistingShorthand = "exists";
>ExistingShorthand : Symbol(ExistingShorthand, Decl(enumLiteralBasics.ts, 3, 3))

const E1: enum = {
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))

    NonexistingShorthand, // error -- EnumLiteralExpressions require explicit property definitions.
>NonexistingShorthand : Symbol(E1.NonexistingShorthand, Decl(enumLiteralBasics.ts, 4, 18))

    ExistingShorthand, // error -- EnumLiteralExpressions require explicit property definitions.
>ExistingShorthand : Symbol(E1.ExistingShorthand, Decl(enumLiteralBasics.ts, 5, 25))

    Int: 1, // ok
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))

    String: "string", // ok
>String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))

    Flag: 8, // ok
>Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))

};

// Valid assignments
const nonexist: E1 = E1.NonexistingShorthand; // ok
>nonexist : Symbol(nonexist, Decl(enumLiteralBasics.ts, 13, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>E1.NonexistingShorthand : Symbol(E1.NonexistingShorthand, Decl(enumLiteralBasics.ts, 4, 18))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>NonexistingShorthand : Symbol(E1.NonexistingShorthand, Decl(enumLiteralBasics.ts, 4, 18))

const exist: E1 = E1.ExistingShorthand; // ok
>exist : Symbol(exist, Decl(enumLiteralBasics.ts, 14, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>E1.ExistingShorthand : Symbol(E1.ExistingShorthand, Decl(enumLiteralBasics.ts, 5, 25))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>ExistingShorthand : Symbol(E1.ExistingShorthand, Decl(enumLiteralBasics.ts, 5, 25))

const ival: E1 = E1.Int; // ok
>ival : Symbol(ival, Decl(enumLiteralBasics.ts, 15, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>E1.Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))

const sval: E1 = E1.String; // ok
>sval : Symbol(sval, Decl(enumLiteralBasics.ts, 16, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>E1.String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))

// Assigning values which are not part of the enum despite being present in the enum
const nonexist_bad: E1 = undefined; // error
>nonexist_bad : Symbol(nonexist_bad, Decl(enumLiteralBasics.ts, 19, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>undefined : Symbol(undefined)

const exist_bad: E1 = "exists"; // error
>exist_bad : Symbol(exist_bad, Decl(enumLiteralBasics.ts, 20, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))

const ival_good: E1 = 1; // ok -- TypeScript is permissive of this in enums, to permit things like bitwise combinations of enum values.
>ival_good : Symbol(ival_good, Decl(enumLiteralBasics.ts, 21, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))

const sval_bad: E1 = "string"; // error
>sval_bad : Symbol(sval_bad, Decl(enumLiteralBasics.ts, 22, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))

const ival_notpresent: E1 = 4; // ok -- TypeScript is permissive of this in enums, to permit things like bitwise combinations of enum values.
>ival_notpresent : Symbol(ival_notpresent, Decl(enumLiteralBasics.ts, 24, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))

function functest(value: E1) {
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 24, 30))
>value : Symbol(value, Decl(enumLiteralBasics.ts, 26, 18))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))

    console.log(value);
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>value : Symbol(value, Decl(enumLiteralBasics.ts, 26, 18))

    return value;
>value : Symbol(value, Decl(enumLiteralBasics.ts, 26, 18))
}

const nonexist_bad2: E1 = functest(undefined); // error
>nonexist_bad2 : Symbol(nonexist_bad2, Decl(enumLiteralBasics.ts, 31, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 24, 30))
>undefined : Symbol(undefined)

const exist_bad2: E1 = functest("exists"); // error
>exist_bad2 : Symbol(exist_bad2, Decl(enumLiteralBasics.ts, 32, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 24, 30))

const ival_good2: E1 = functest(1); // ok
>ival_good2 : Symbol(ival_good2, Decl(enumLiteralBasics.ts, 33, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 24, 30))

const ival_good3: E1 = functest(4); // ok
>ival_good3 : Symbol(ival_good3, Decl(enumLiteralBasics.ts, 34, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 24, 30))

const ival_good4: E1 = functest(E1.Int | E1.Flag); // ok
>ival_good4 : Symbol(ival_good4, Decl(enumLiteralBasics.ts, 35, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 24, 30))
>E1.Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>Int : Symbol(E1.Int, Decl(enumLiteralBasics.ts, 6, 22))
>E1.Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>Flag : Symbol(E1.Flag, Decl(enumLiteralBasics.ts, 8, 21))

const sval_good2: E1 = functest(E1.String);
>sval_good2 : Symbol(sval_good2, Decl(enumLiteralBasics.ts, 36, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 24, 30))
>E1.String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>String : Symbol(E1.String, Decl(enumLiteralBasics.ts, 7, 11))

const sval_bad2: E1 = functest("string"); // error
>sval_bad2 : Symbol(sval_bad2, Decl(enumLiteralBasics.ts, 37, 5))
>E1 : Symbol(E1, Decl(enumLiteralBasics.ts, 4, 5), Decl(enumLiteralBasics.ts, 4, 5))
>functest : Symbol(functest, Decl(enumLiteralBasics.ts, 24, 30))

