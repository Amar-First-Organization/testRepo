=== tests/cases/compiler/destructuringThisWithProperty.ts ===
class A {
>A : A

    constructor(public foo: string) {}
>foo : string

    get bar(): number {
>bar : number

        return 1;
>1 : 1
    }

    func() {
>func : () => void

        const {           ...rest1 } = this;
>rest1 : Omit<this, "bar" | "func">
>this : this

        const {           ...rest2 } = this as A;
>rest2 : { foo: string; }
>this as A : A
>this : this

        const { foo: _f1, ...rest3 } = this;
>foo : any
>_f1 : string
>rest3 : Omit<this, "foo" | "bar" | "func">
>this : this

        const { foo: _f2, ...rest4 } = this as A;
>foo : any
>_f2 : string
>rest4 : {}
>this as A : A
>this : this

        rest1.bar;
>rest1.bar : any
>rest1 : Omit<this, "bar" | "func">
>bar : any

        rest2.bar;
>rest2.bar : any
>rest2 : { foo: string; }
>bar : any

        rest3.bar;
>rest3.bar : any
>rest3 : Omit<this, "foo" | "bar" | "func">
>bar : any

        rest4.bar;
>rest4.bar : any
>rest4 : {}
>bar : any

        rest1.func;
>rest1.func : any
>rest1 : Omit<this, "bar" | "func">
>func : any

        rest2.func;
>rest2.func : any
>rest2 : { foo: string; }
>func : any

        rest3.func;
>rest3.func : any
>rest3 : Omit<this, "foo" | "bar" | "func">
>func : any

        rest4.func;
>rest4.func : any
>rest4 : {}
>func : any
    }
}

function destructure<T extends A>(x: T) {
>destructure : <T extends A>(x: T) => void
>x : T

    const {           ...rest1 } = x;
>rest1 : Omit<T, "bar" | "func">
>x : T

    const {           ...rest2 } = x as A;
>rest2 : { foo: string; }
>x as A : A
>x : T

    const { foo: _f1, ...rest3 } = x;
>foo : any
>_f1 : string
>rest3 : Omit<T, "foo" | "bar" | "func">
>x : T

    const { foo: _f2, ...rest4 } = x as A;
>foo : any
>_f2 : string
>rest4 : {}
>x as A : A
>x : T

    rest1.bar;
>rest1.bar : any
>rest1 : Omit<T, "bar" | "func">
>bar : any

    rest2.bar;
>rest2.bar : any
>rest2 : { foo: string; }
>bar : any

    rest3.bar;
>rest3.bar : any
>rest3 : Omit<T, "foo" | "bar" | "func">
>bar : any

    rest4.bar;
>rest4.bar : any
>rest4 : {}
>bar : any

    rest1.func;
>rest1.func : any
>rest1 : Omit<T, "bar" | "func">
>func : any

    rest2.func;
>rest2.func : any
>rest2 : { foo: string; }
>func : any

    rest3.func;
>rest3.func : any
>rest3 : Omit<T, "foo" | "bar" | "func">
>func : any

    rest4.func;
>rest4.func : any
>rest4 : {}
>func : any
}

