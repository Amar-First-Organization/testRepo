=== tests/cases/compiler/collectionPatternNoError.ts ===
interface MsgConstructor<T extends Message> {
>MsgConstructor : MsgConstructor<T>
>T : T
>Message : Message

    new(data: Array<{}>): T;
>data : {}[]
>Array : T[]
>T : T
  }
  class Message {
>Message : Message

    clone(): this {
>clone : () => this

      return this;
>this : this
    }
  }
  interface MessageList<T extends Message> extends Message {
>MessageList : MessageList<T>
>T : T
>Message : Message
>Message : Message

    methodOnMessageList(): T[];
>methodOnMessageList : () => T[]
>T : T
  }
  
  function fetchMsg<V extends Message>(protoCtor: MsgConstructor<V>): V {
>fetchMsg : <V extends Message>(protoCtor: MsgConstructor<V>) => V
>V : V
>Message : Message
>protoCtor : MsgConstructor<V>
>MsgConstructor : MsgConstructor<T>
>V : V
>V : V

    return null!;
>null! : null
>null : null
  }
  
  class DataProvider<T extends Message, U extends MessageList<T>> {
>DataProvider : DataProvider<T, U>
>T : T
>Message : Message
>U : U
>MessageList : MessageList<T>
>T : T

    constructor(
        private readonly message: MsgConstructor<T>,
>message : MsgConstructor<T>
>MsgConstructor : MsgConstructor<T>
>T : T

        private readonly messageList: MsgConstructor<U>,
>messageList : MsgConstructor<U>
>MsgConstructor : MsgConstructor<T>
>U : U

    ) {}
  
    fetch() {
>fetch : () => void

      const messageList = fetchMsg(this.messageList);
>messageList : U
>fetchMsg(this.messageList) : U
>fetchMsg : <V extends Message>(protoCtor: MsgConstructor<V>) => V
>this.messageList : MsgConstructor<U>
>this : this
>messageList : MsgConstructor<U>

      messageList.methodOnMessageList();
>messageList.methodOnMessageList() : T[]
>messageList.methodOnMessageList : () => T[]
>messageList : U
>methodOnMessageList : () => T[]
    }
  }
