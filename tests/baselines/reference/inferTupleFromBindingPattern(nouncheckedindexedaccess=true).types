//// [tests/cases/compiler/inferTupleFromBindingPattern.ts] ////

=== inferTupleFromBindingPattern.ts ===
declare function f<T>(cb: () => T): T;
>f : <T>(cb: () => T) => T
>cb : () => T

const [e1, e2, e3] = f(() => [1, "hi", true]);
>e1 : number
>e2 : string
>e3 : boolean
>f(() => [1, "hi", true]) : [number, string, boolean]
>f : <T>(cb: () => T) => T
>() => [1, "hi", true] : () => [number, string, boolean]
>[1, "hi", true] : [number, string, true]
>1 : 1
>"hi" : "hi"
>true : true

// repro from #42969
declare const f2: <T extends string[]>(t: T) => [T, string[]];
>f2 : <T extends string[]>(t: T) => [T, string[]]
>t : T

const [[f2e1]] = f2(['1']);
>f2e1 : string
>f2(['1']) : [[string], string[]]
>f2 : <T extends string[]>(t: T) => [T, string[]]
>['1'] : [string]
>'1' : "1"

f2e1.toLowerCase();
>f2e1.toLowerCase() : string
>f2e1.toLowerCase : () => string
>f2e1 : string
>toLowerCase : () => string

declare const f3: <T extends string[]>(t: T) => [[T, string[]]];
>f3 : <T extends string[]>(t: T) => [[T, string[]]]
>t : T

const [[[f3e1]]] = f3(['1']);
>f3e1 : string
>f3(['1']) : [[[string], string[]]]
>f3 : <T extends string[]>(t: T) => [[T, string[]]]
>['1'] : [string]
>'1' : "1"

f3e1.toLowerCase();
>f3e1.toLowerCase() : string
>f3e1.toLowerCase : () => string
>f3e1 : string
>toLowerCase : () => string

