=== tests/cases/compiler/stringLiteralFreshnessInGenericTypeGuard.ts ===
interface Guard<T> {
  (val: unknown): val is T;
>val : unknown
}

type ObjectGuard<T> = {
>ObjectGuard : ObjectGuard<T>

  [key in keyof T]: Guard<T[key]>;
};

function isObject(val: unknown): val is Record<string, unknown> {
>isObject : (val: unknown) => val is Record<string, unknown>
>val : unknown

  return val !== undefined && val !== null && typeof val === 'object' && !Array.isArray(val);
>val !== undefined && val !== null && typeof val === 'object' && !Array.isArray(val) : boolean
>val !== undefined && val !== null && typeof val === 'object' : boolean
>val !== undefined && val !== null : boolean
>val !== undefined : boolean
>val : unknown
>undefined : undefined
>val !== null : boolean
>val : unknown
>null : null
>typeof val === 'object' : boolean
>typeof val : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>val : unknown
>'object' : "object"
>!Array.isArray(val) : boolean
>Array.isArray(val) : boolean
>Array.isArray : (arg: any) => arg is any[]
>Array : ArrayConstructor
>isArray : (arg: any) => arg is any[]
>val : object
}

declare function createObjectGuard<T>(guard: ObjectGuard<T>): (val: unknown) => val is T;
>createObjectGuard : <T>(guard: ObjectGuard<T>) => (val: unknown) => val is T
>guard : ObjectGuard<T>
>val : unknown

declare function asLiteral<T extends (string | boolean | number)[]>(...literals: T): (val: unknown) => val is T[number]
>asLiteral : <T extends (string | number | boolean)[]>(...literals: T) => (val: unknown) => val is T[number]
>literals : T
>val : unknown

// See type of `isWorking` - should include the type key as a union of strings
const isWorking = createObjectGuard({
>isWorking : (val: unknown) => val is { type: "these" | "should" | "be" | "a" | "union"; }
>createObjectGuard({//    ^?  type: asLiteral('these', 'should', 'be', 'a', 'union'),}) : (val: unknown) => val is { type: "these" | "should" | "be" | "a" | "union"; }
>createObjectGuard : <T>(guard: ObjectGuard<T>) => (val: unknown) => val is T
>{//    ^?  type: asLiteral('these', 'should', 'be', 'a', 'union'),} : { type: (val: unknown) => val is "these" | "should" | "be" | "a" | "union"; }

//    ^?
  type: asLiteral('these', 'should', 'be', 'a', 'union'),
>type : (val: unknown) => val is "these" | "should" | "be" | "a" | "union"
>asLiteral('these', 'should', 'be', 'a', 'union') : (val: unknown) => val is "these" | "should" | "be" | "a" | "union"
>asLiteral : <T extends (string | number | boolean)[]>(...literals: T) => (val: unknown) => val is T[number]
>'these' : "these"
>'should' : "should"
>'be' : "be"
>'a' : "a"
>'union' : "union"

});


