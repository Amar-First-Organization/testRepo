//// [tests/cases/conformance/classes/classDeclarations/classAbstractKeyword/classAbstractConstructorAssignability.ts] ////

=== classAbstractConstructorAssignability.ts ===
class A {}
>A : Symbol(A, Decl(classAbstractConstructorAssignability.ts, 0, 0))

abstract class B extends A {}
>B : Symbol(B, Decl(classAbstractConstructorAssignability.ts, 0, 10))
>A : Symbol(A, Decl(classAbstractConstructorAssignability.ts, 0, 0))

class C extends B {}
>C : Symbol(C, Decl(classAbstractConstructorAssignability.ts, 2, 29))
>B : Symbol(B, Decl(classAbstractConstructorAssignability.ts, 0, 10))

var AA : typeof A = B;
>AA : Symbol(AA, Decl(classAbstractConstructorAssignability.ts, 6, 3))
>A : Symbol(A, Decl(classAbstractConstructorAssignability.ts, 0, 0))
>B : Symbol(B, Decl(classAbstractConstructorAssignability.ts, 0, 10))

var BB : typeof B = A;
>BB : Symbol(BB, Decl(classAbstractConstructorAssignability.ts, 7, 3))
>B : Symbol(B, Decl(classAbstractConstructorAssignability.ts, 0, 10))
>A : Symbol(A, Decl(classAbstractConstructorAssignability.ts, 0, 0))

var CC : typeof C = B;
>CC : Symbol(CC, Decl(classAbstractConstructorAssignability.ts, 8, 3))
>C : Symbol(C, Decl(classAbstractConstructorAssignability.ts, 2, 29))
>B : Symbol(B, Decl(classAbstractConstructorAssignability.ts, 0, 10))

new AA;
>AA : Symbol(AA, Decl(classAbstractConstructorAssignability.ts, 6, 3))

new BB;
>BB : Symbol(BB, Decl(classAbstractConstructorAssignability.ts, 7, 3))

new CC;
>CC : Symbol(CC, Decl(classAbstractConstructorAssignability.ts, 8, 3))

// https://github.com/microsoft/TypeScript/issues/57412

// private methods have parameters stripped away in the generated declaration files
abstract class GeneratedConstructable {
>GeneratedConstructable : Symbol(GeneratedConstructable, Decl(classAbstractConstructorAssignability.ts, 12, 7))

  private constructor() {}
}

class MyPrivateClass {
>MyPrivateClass : Symbol(MyPrivateClass, Decl(classAbstractConstructorAssignability.ts, 19, 1))

  private privateVal: boolean;
>privateVal : Symbol(MyPrivateClass.privateVal, Decl(classAbstractConstructorAssignability.ts, 21, 22))

  private constructor(
    public readonly foo: string,
>foo : Symbol(MyPrivateClass.foo, Decl(classAbstractConstructorAssignability.ts, 23, 22))

    public readonly bar: string,
>bar : Symbol(MyPrivateClass.bar, Decl(classAbstractConstructorAssignability.ts, 24, 32))

  ) {
    this.privateVal = true;
>this.privateVal : Symbol(MyPrivateClass.privateVal, Decl(classAbstractConstructorAssignability.ts, 21, 22))
>this : Symbol(MyPrivateClass, Decl(classAbstractConstructorAssignability.ts, 19, 1))
>privateVal : Symbol(MyPrivateClass.privateVal, Decl(classAbstractConstructorAssignability.ts, 21, 22))
  }
}

export const funcThatAcceptsAnyGeneratedClass = (
>funcThatAcceptsAnyGeneratedClass : Symbol(funcThatAcceptsAnyGeneratedClass, Decl(classAbstractConstructorAssignability.ts, 31, 12))

  clazz: typeof GeneratedConstructable,
>clazz : Symbol(clazz, Decl(classAbstractConstructorAssignability.ts, 31, 49))
>GeneratedConstructable : Symbol(GeneratedConstructable, Decl(classAbstractConstructorAssignability.ts, 12, 7))

) => {};

funcThatAcceptsAnyGeneratedClass(MyPrivateClass);
>funcThatAcceptsAnyGeneratedClass : Symbol(funcThatAcceptsAnyGeneratedClass, Decl(classAbstractConstructorAssignability.ts, 31, 12))
>MyPrivateClass : Symbol(MyPrivateClass, Decl(classAbstractConstructorAssignability.ts, 19, 1))

