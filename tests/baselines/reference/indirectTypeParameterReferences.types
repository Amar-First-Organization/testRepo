//// [tests/cases/compiler/indirectTypeParameterReferences.ts] ////

=== indirectTypeParameterReferences.ts ===
// Repro from #19043

type B = {b: string}
>B : B
>  : ^
>b : string
>  : ^^^^^^

const flowtypes = <A>(b: B) => {
>flowtypes : <A>(b: B) => { combined: (fn: (combined: B & A) => void) => any; literal: (fn: (aPlusB: A & B) => void) => any; }
>          : ^ ^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^                       ^^^^^^^^^^^
><A>(b: B) => {  type Combined = A & B  const combined = (fn: (combined: Combined) => void) => null  const literal = (fn: (aPlusB: A & B) => void) => null  return {combined, literal}} : <A>(b: B) => { combined: (fn: (combined: B & A) => void) => any; literal: (fn: (aPlusB: A & B) => void) => any; }
>                                                                                                                                                                                       : ^ ^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^                       ^^^^^^^^^^^
>b : B
>  : ^

  type Combined = A & B
>Combined : B & A
>         : ^^^^^

  const combined = (fn: (combined: Combined) => void) => null
>combined : (fn: (combined: B & A) => void) => any
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^
>(fn: (combined: Combined) => void) => null : (fn: (combined: B & A) => void) => any
>                                           : ^^^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^
>fn : (combined: B & A) => void
>   : ^^^^^^^^^^^^^^^^^^^^^    
>combined : B & A
>         : ^^^^^

  const literal = (fn: (aPlusB: A & B) => void) => null
>literal : (fn: (aPlusB: A & B) => void) => any
>        : ^^^^^                       ^^^^^^^^
>(fn: (aPlusB: A & B) => void) => null : (fn: (aPlusB: A & B) => void) => any
>                                      : ^^^^^                       ^^^^^^^^
>fn : (aPlusB: A & B) => void
>   : ^^^^^^^^^     ^^^^^    
>aPlusB : B & A
>       : ^^^^^

  return {combined, literal}
>{combined, literal} : { combined: (fn: (combined: B & A) => void) => any; literal: (fn: (aPlusB: B & A) => void) => any; }
>                    : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>combined : (fn: (combined: B & A) => void) => any
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>literal : (fn: (aPlusB: B & A) => void) => any
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
}

const {combined, literal} = flowtypes<{a: string}>({b: 'b-value'})
>combined : (fn: (combined: B & { a: string; }) => void) => any
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>literal : (fn: (aPlusB: B & { a: string; }) => void) => any
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>flowtypes<{a: string}>({b: 'b-value'}) : { combined: (fn: (combined: B & { a: string; }) => void) => any; literal: (fn: (aPlusB: B & { a: string; }) => void) => any; }
>                                       : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^^^^^^^^^^^
>flowtypes : <A>(b: B) => { combined: (fn: (combined: B & A) => void) => any; literal: (fn: (aPlusB: B & A) => void) => any; }
>          : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>a : string
>  : ^^^^^^
>{b: 'b-value'} : { b: string; }
>               : ^^^^^^^^^^^^^^
>b : string
>  : ^^^^^^
>'b-value' : "b-value"
>          : ^^^^^^^^^

literal(aPlusB => {
>literal(aPlusB => {  aPlusB.b  aPlusB.a}) : any
>literal : (fn: (aPlusB: B & { a: string; }) => void) => any
>        : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>aPlusB => {  aPlusB.b  aPlusB.a} : (aPlusB: B & { a: string; }) => void
>                                 : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>aPlusB : B & { a: string; }
>       : ^^^^^^^^^^^^^^^^^^

  aPlusB.b
>aPlusB.b : string
>         : ^^^^^^
>aPlusB : B & { a: string; }
>       : ^^^^^^^^^^^^^^^^^^
>b : string
>  : ^^^^^^

  aPlusB.a
>aPlusB.a : string
>         : ^^^^^^
>aPlusB : B & { a: string; }
>       : ^^^^^^^^^^^^^^^^^^
>a : string
>  : ^^^^^^

})

combined(comb => {
>combined(comb => {  comb.b  comb.a}) : any
>combined : (fn: (combined: B & { a: string; }) => void) => any
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>comb => {  comb.b  comb.a} : (comb: B & { a: string; }) => void
>                           : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>comb : B & { a: string; }
>     : ^^^^^^^^^^^^^^^^^^

  comb.b
>comb.b : string
>       : ^^^^^^
>comb : B & { a: string; }
>     : ^^^^^^^^^^^^^^^^^^
>b : string
>  : ^^^^^^

  comb.a
>comb.a : string
>       : ^^^^^^
>comb : B & { a: string; }
>     : ^^^^^^^^^^^^^^^^^^
>a : string
>  : ^^^^^^

})

// Repro from #19091

declare function f<T>(a: T): { a: typeof a };
>f : <T>(a: T) => { a: typeof a; }
>  : ^ ^^^^^ ^^^^^                
>a : T
>  : ^
>a : T
>  : ^
>a : T
>  : ^

let n: number = f(2).a;
>n : number
>  : ^^^^^^
>f(2).a : number
>       : ^^^^^^
>f(2) : { a: number; }
>     : ^^^^^^^^^^^^^^
>f : <T>(a: T) => { a: T; }
>  : ^^^^^^^^^^^^^^^^^^^^^^
>2 : 2
>  : ^
>a : number
>  : ^^^^^^

