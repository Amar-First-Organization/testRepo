=== tests/cases/conformance/types/typeRelationships/typeInference/noInfer.ts ===
export declare function foo<T extends string>(a: T, b: NoInfer<T>): void
>foo : Symbol(foo, Decl(noInfer.ts, 0, 0))
>T : Symbol(T, Decl(noInfer.ts, 0, 28))
>a : Symbol(a, Decl(noInfer.ts, 0, 46))
>T : Symbol(T, Decl(noInfer.ts, 0, 28))
>b : Symbol(b, Decl(noInfer.ts, 0, 51))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 0, 28))

foo('foo', 'foo') // ok
>foo : Symbol(foo, Decl(noInfer.ts, 0, 0))

foo('foo', 'bar') // error
>foo : Symbol(foo, Decl(noInfer.ts, 0, 0))

export declare class Animal { move(): void }
>Animal : Symbol(Animal, Decl(noInfer.ts, 3, 17))
>move : Symbol(Animal.move, Decl(noInfer.ts, 5, 29))

export declare class Dog extends Animal { woof(): void }
>Dog : Symbol(Dog, Decl(noInfer.ts, 5, 44))
>Animal : Symbol(Animal, Decl(noInfer.ts, 3, 17))
>woof : Symbol(Dog.woof, Decl(noInfer.ts, 6, 41))

export declare function doSomething<T>(value: T, getDefault: () => NoInfer<T>): void;
>doSomething : Symbol(doSomething, Decl(noInfer.ts, 6, 56))
>T : Symbol(T, Decl(noInfer.ts, 7, 36))
>value : Symbol(value, Decl(noInfer.ts, 7, 39))
>T : Symbol(T, Decl(noInfer.ts, 7, 36))
>getDefault : Symbol(getDefault, Decl(noInfer.ts, 7, 48))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 7, 36))

doSomething(new Animal(), () => new Animal()); // ok
>doSomething : Symbol(doSomething, Decl(noInfer.ts, 6, 56))
>Animal : Symbol(Animal, Decl(noInfer.ts, 3, 17))
>Animal : Symbol(Animal, Decl(noInfer.ts, 3, 17))

doSomething(new Animal(), () => new Dog()); // ok
>doSomething : Symbol(doSomething, Decl(noInfer.ts, 6, 56))
>Animal : Symbol(Animal, Decl(noInfer.ts, 3, 17))
>Dog : Symbol(Dog, Decl(noInfer.ts, 5, 44))

doSomething(new Dog(), () => new Animal()); // error
>doSomething : Symbol(doSomething, Decl(noInfer.ts, 6, 56))
>Dog : Symbol(Dog, Decl(noInfer.ts, 5, 44))
>Animal : Symbol(Animal, Decl(noInfer.ts, 3, 17))

export declare function assertEqual<T>(actual: T, expected: NoInfer<T>): boolean;
>assertEqual : Symbol(assertEqual, Decl(noInfer.ts, 11, 43))
>T : Symbol(T, Decl(noInfer.ts, 13, 36))
>actual : Symbol(actual, Decl(noInfer.ts, 13, 39))
>T : Symbol(T, Decl(noInfer.ts, 13, 36))
>expected : Symbol(expected, Decl(noInfer.ts, 13, 49))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 13, 36))

assertEqual({ x: 1 }, { x: 3 }); // ok
>assertEqual : Symbol(assertEqual, Decl(noInfer.ts, 11, 43))
>x : Symbol(x, Decl(noInfer.ts, 15, 13))
>x : Symbol(x, Decl(noInfer.ts, 15, 23))

const g = { x: 3, y: 2 };
>g : Symbol(g, Decl(noInfer.ts, 16, 5))
>x : Symbol(x, Decl(noInfer.ts, 16, 11))
>y : Symbol(y, Decl(noInfer.ts, 16, 17))

assertEqual(g, { x: 3 }); // error
>assertEqual : Symbol(assertEqual, Decl(noInfer.ts, 11, 43))
>g : Symbol(g, Decl(noInfer.ts, 16, 5))
>x : Symbol(x, Decl(noInfer.ts, 17, 16))

export declare function invoke<T, R>(func: (value: T) => R, value: NoInfer<T>): R;
>invoke : Symbol(invoke, Decl(noInfer.ts, 17, 25))
>T : Symbol(T, Decl(noInfer.ts, 19, 31))
>R : Symbol(R, Decl(noInfer.ts, 19, 33))
>func : Symbol(func, Decl(noInfer.ts, 19, 37))
>value : Symbol(value, Decl(noInfer.ts, 19, 44))
>T : Symbol(T, Decl(noInfer.ts, 19, 31))
>R : Symbol(R, Decl(noInfer.ts, 19, 33))
>value : Symbol(value, Decl(noInfer.ts, 19, 59))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 19, 31))
>R : Symbol(R, Decl(noInfer.ts, 19, 33))

export declare function test(value: { x: number; }): number;
>test : Symbol(test, Decl(noInfer.ts, 19, 82))
>value : Symbol(value, Decl(noInfer.ts, 20, 29))
>x : Symbol(x, Decl(noInfer.ts, 20, 37))

invoke(test, { x: 1, y: 2 }); // error
>invoke : Symbol(invoke, Decl(noInfer.ts, 17, 25))
>test : Symbol(test, Decl(noInfer.ts, 19, 82))
>x : Symbol(x, Decl(noInfer.ts, 22, 14))
>y : Symbol(y, Decl(noInfer.ts, 22, 20))

test({ x: 1, y: 2 }); // error
>test : Symbol(test, Decl(noInfer.ts, 19, 82))
>x : Symbol(x, Decl(noInfer.ts, 23, 6))
>y : Symbol(y, Decl(noInfer.ts, 23, 12))

export type Component<Props> = { props: Props; };
>Component : Symbol(Component, Decl(noInfer.ts, 23, 21))
>Props : Symbol(Props, Decl(noInfer.ts, 25, 22))
>props : Symbol(props, Decl(noInfer.ts, 25, 32))
>Props : Symbol(Props, Decl(noInfer.ts, 25, 22))

export declare function doWork<Props>(Component: Component<Props>, props: NoInfer<Props>): void;
>doWork : Symbol(doWork, Decl(noInfer.ts, 25, 49))
>Props : Symbol(Props, Decl(noInfer.ts, 26, 31))
>Component : Symbol(Component, Decl(noInfer.ts, 26, 38))
>Component : Symbol(Component, Decl(noInfer.ts, 23, 21))
>Props : Symbol(Props, Decl(noInfer.ts, 26, 31))
>props : Symbol(props, Decl(noInfer.ts, 26, 66))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>Props : Symbol(Props, Decl(noInfer.ts, 26, 31))

export declare const comp: Component<{ foo: number }>;
>comp : Symbol(comp, Decl(noInfer.ts, 27, 20))
>Component : Symbol(Component, Decl(noInfer.ts, 23, 21))
>foo : Symbol(foo, Decl(noInfer.ts, 27, 38))

doWork(comp, { foo: 42 }); // ok
>doWork : Symbol(doWork, Decl(noInfer.ts, 25, 49))
>comp : Symbol(comp, Decl(noInfer.ts, 27, 20))
>foo : Symbol(foo, Decl(noInfer.ts, 29, 14))

doWork(comp, {}); // error
>doWork : Symbol(doWork, Decl(noInfer.ts, 25, 49))
>comp : Symbol(comp, Decl(noInfer.ts, 27, 20))

export declare function mutate<T>(callback: (a: NoInfer<T>, b: number) => T): T;
>mutate : Symbol(mutate, Decl(noInfer.ts, 30, 17))
>T : Symbol(T, Decl(noInfer.ts, 32, 31))
>callback : Symbol(callback, Decl(noInfer.ts, 32, 34))
>a : Symbol(a, Decl(noInfer.ts, 32, 45))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 32, 31))
>b : Symbol(b, Decl(noInfer.ts, 32, 59))
>T : Symbol(T, Decl(noInfer.ts, 32, 31))
>T : Symbol(T, Decl(noInfer.ts, 32, 31))

export const mutate1 = mutate((a, b) => b);
>mutate1 : Symbol(mutate1, Decl(noInfer.ts, 33, 12))
>mutate : Symbol(mutate, Decl(noInfer.ts, 30, 17))
>a : Symbol(a, Decl(noInfer.ts, 33, 31))
>b : Symbol(b, Decl(noInfer.ts, 33, 33))
>b : Symbol(b, Decl(noInfer.ts, 33, 33))

export declare class ExampleClass<T> {}
>ExampleClass : Symbol(ExampleClass, Decl(noInfer.ts, 33, 43))
>T : Symbol(T, Decl(noInfer.ts, 35, 34))

export class OkClass<T> {
>OkClass : Symbol(OkClass, Decl(noInfer.ts, 35, 39))
>T : Symbol(T, Decl(noInfer.ts, 36, 21))

    constructor(private clazz: ExampleClass<T>, private _value: NoInfer<T>) {}
>clazz : Symbol(OkClass.clazz, Decl(noInfer.ts, 37, 16))
>ExampleClass : Symbol(ExampleClass, Decl(noInfer.ts, 33, 43))
>T : Symbol(T, Decl(noInfer.ts, 36, 21))
>_value : Symbol(OkClass._value, Decl(noInfer.ts, 37, 47))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 36, 21))

    get value(): T {
>value : Symbol(OkClass.value, Decl(noInfer.ts, 37, 78))
>T : Symbol(T, Decl(noInfer.ts, 36, 21))

        return this._value; // ok
>this._value : Symbol(OkClass._value, Decl(noInfer.ts, 37, 47))
>this : Symbol(OkClass, Decl(noInfer.ts, 35, 39))
>_value : Symbol(OkClass._value, Decl(noInfer.ts, 37, 47))
    }
}
export class OkClass2<T> {
>OkClass2 : Symbol(OkClass2, Decl(noInfer.ts, 42, 1))
>T : Symbol(T, Decl(noInfer.ts, 43, 22))

    constructor(private clazz: ExampleClass<T>, public _value: NoInfer<T>) {}
>clazz : Symbol(OkClass2.clazz, Decl(noInfer.ts, 44, 16))
>ExampleClass : Symbol(ExampleClass, Decl(noInfer.ts, 33, 43))
>T : Symbol(T, Decl(noInfer.ts, 43, 22))
>_value : Symbol(OkClass2._value, Decl(noInfer.ts, 44, 47))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(noInfer.ts, 43, 22))
}

