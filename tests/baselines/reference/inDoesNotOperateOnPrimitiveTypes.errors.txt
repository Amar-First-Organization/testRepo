tests/cases/compiler/inDoesNotOperateOnPrimitiveTypes.ts(19,17): error TS2361: The right-hand side of an 'in' expression must not be a primitive.
tests/cases/compiler/inDoesNotOperateOnPrimitiveTypes.ts(23,12): error TS2361: The right-hand side of an 'in' expression must not be a primitive.
tests/cases/compiler/inDoesNotOperateOnPrimitiveTypes.ts(27,12): error TS2361: The right-hand side of an 'in' expression must not be a primitive.
tests/cases/compiler/inDoesNotOperateOnPrimitiveTypes.ts(34,12): error TS2361: The right-hand side of an 'in' expression must not be a primitive.
tests/cases/compiler/inDoesNotOperateOnPrimitiveTypes.ts(41,12): error TS2361: The right-hand side of an 'in' expression must not be a primitive.
tests/cases/compiler/inDoesNotOperateOnPrimitiveTypes.ts(45,12): error TS2361: The right-hand side of an 'in' expression must not be a primitive.
tests/cases/compiler/inDoesNotOperateOnPrimitiveTypes.ts(49,12): error TS2361: The right-hand side of an 'in' expression must not be a primitive.
tests/cases/compiler/inDoesNotOperateOnPrimitiveTypes.ts(53,12): error TS2361: The right-hand side of an 'in' expression must not be a primitive.


==== tests/cases/compiler/inDoesNotOperateOnPrimitiveTypes.ts (8 errors) ====
    const validHasKey = <T extends object>(
      thing: T,
      key: string,
    ): boolean => {
      return key in thing;
    };
    
    const alsoValidHasKey = <T>(
      thing: T,
      key: string,
    ): boolean => {
      return key in thing;
    };
    
    function invalidHasKey<T extends string | number>(
      thing: T,
      key: string,
    ): boolean {
      return key in thing;
                    ~~~~~
!!! error TS2361: The right-hand side of an 'in' expression must not be a primitive.
    }
    
    function union1<T extends string | number, U extends boolean>(thing: T | U) {
      "key" in thing; // Error (because all possible instantiations are errors)
               ~~~~~
!!! error TS2361: The right-hand side of an 'in' expression must not be a primitive.
    }
    
    function union2<T extends object, U extends string | number>(thing: T | U) {
      "key" in thing; // Error (because narrowing is possible)
               ~~~~~
!!! error TS2361: The right-hand side of an 'in' expression must not be a primitive.
      if (typeof thing === "object") {
        "key" in thing; // Ok
      }
    }
    
    function union3<T>(thing: T | string | number) {
      "key" in thing; // Error (because narrowing is possible)
               ~~~~~
!!! error TS2361: The right-hand side of an 'in' expression must not be a primitive.
      if (typeof thing !== "string" && typeof thing !== "number") {
        "key" in thing; // Ok, because further narrowing is impossible
      }
    }
    
    function union4<T extends object | "hello">(thing: T) {
      "key" in thing; // Error (because union includes string literal)
               ~~~~~
!!! error TS2361: The right-hand side of an 'in' expression must not be a primitive.
    }
    
    function union5<T extends object | string>(thing: T) {
      "key" in thing; // Error (because union includes string)
               ~~~~~
!!! error TS2361: The right-hand side of an 'in' expression must not be a primitive.
    }
    
    function intersection1<T extends number, U extends 0 | 1 | 2>(thing: T & U) {
      "key" in thing; // Error (because all possible instantiations are errors)
               ~~~~~
!!! error TS2361: The right-hand side of an 'in' expression must not be a primitive.
    }
    
    function intersection2<T>(thing: T & (0 | 1 | 2)) {
      "key" in thing; // Error (because all possible instantations are errors)
               ~~~~~
!!! error TS2361: The right-hand side of an 'in' expression must not be a primitive.
    }
    