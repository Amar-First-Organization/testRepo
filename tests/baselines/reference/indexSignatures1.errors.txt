tests/cases/conformance/types/members/indexSignatures1.ts(7,5): error TS2322: Type '{ [sym]: number; }' is not assignable to type '{ [key: symbol]: string; }'.
  Property '[sym]' is incompatible with index signature.
    Type 'number' is not assignable to type 'string'.
tests/cases/conformance/types/members/indexSignatures1.ts(21,5): error TS2322: Type 'IY' is not assignable to type 'IX'.
  Index signature for type '`a${string}`' is missing in type 'IY'.
tests/cases/conformance/types/members/indexSignatures1.ts(42,12): error TS7053: Element implicitly has an 'any' type because expression of type '"axxxbbbyc"' can't be used to index type '{ [x: `${string}xxx${string}` & `${string}yyy${string}`]: string; }'.
  Property 'axxxbbbyc' does not exist on type '{ [x: `${string}xxx${string}` & `${string}yyy${string}`]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(53,9): error TS2322: Type '{ date123: string; }' is not assignable to type '{ [x: `data${string}`]: string; }'.
  Object literal may only specify known properties, and 'date123' does not exist in type '{ [x: `data${string}`]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(70,5): error TS2374: Duplicate index signature for type 'number'.
tests/cases/conformance/types/members/indexSignatures1.ts(71,5): error TS2374: Duplicate index signature for type 'number'.
tests/cases/conformance/types/members/indexSignatures1.ts(71,5): error TS2374: Duplicate index signature for type 'symbol'.
tests/cases/conformance/types/members/indexSignatures1.ts(72,5): error TS2374: Duplicate index signature for type '`foo${string}`'.
tests/cases/conformance/types/members/indexSignatures1.ts(72,5): error TS2374: Duplicate index signature for type 'symbol'.
tests/cases/conformance/types/members/indexSignatures1.ts(73,5): error TS2374: Duplicate index signature for type '`foo${string}`'.
tests/cases/conformance/types/members/indexSignatures1.ts(81,5): error TS2413: '`a${string}a`' index type '"c"' is not assignable to '`${string}a`' index type '"b"'.
tests/cases/conformance/types/members/indexSignatures1.ts(81,5): error TS2413: '`a${string}a`' index type '"c"' is not assignable to '`a${string}`' index type '"a"'.
tests/cases/conformance/types/members/indexSignatures1.ts(87,6): error TS1337: An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.
tests/cases/conformance/types/members/indexSignatures1.ts(88,6): error TS1337: An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.
tests/cases/conformance/types/members/indexSignatures1.ts(89,6): error TS1268: An index signature parameter type must be 'string', 'number', 'symbol', or a template literal type.
tests/cases/conformance/types/members/indexSignatures1.ts(90,6): error TS1337: An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.
tests/cases/conformance/types/members/indexSignatures1.ts(112,1): error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ [key: TaggedString1]: string; }'.
  No index signature with a parameter of type 'string' was found on type '{ [key: TaggedString1]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(114,1): error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString2' can't be used to index type '{ [key: TaggedString1]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(115,1): error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString1 | TaggedString2' can't be used to index type '{ [key: TaggedString1]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(118,1): error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ [key: TaggedString2]: string; }'.
  No index signature with a parameter of type 'string' was found on type '{ [key: TaggedString2]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(119,1): error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString1' can't be used to index type '{ [key: TaggedString2]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(121,1): error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString1 | TaggedString2' can't be used to index type '{ [key: TaggedString2]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(124,1): error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ [key: TaggedString1]: string; [key: TaggedString2]: string; }'.
  No index signature with a parameter of type 'string' was found on type '{ [key: TaggedString1]: string; [key: TaggedString2]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(130,1): error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ [key: string & Tag1 & Tag2]: string; }'.
  No index signature with a parameter of type 'string' was found on type '{ [key: string & Tag1 & Tag2]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(131,1): error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString1' can't be used to index type '{ [key: string & Tag1 & Tag2]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(132,1): error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString2' can't be used to index type '{ [key: string & Tag1 & Tag2]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(133,1): error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString1 | TaggedString2' can't be used to index type '{ [key: string & Tag1 & Tag2]: string; }'.
tests/cases/conformance/types/members/indexSignatures1.ts(185,7): error TS2322: Type '"&"' is not assignable to type '`&:${string}`'.
tests/cases/conformance/types/members/indexSignatures1.ts(189,35): error TS2322: Type '{ someKey: string; }' is not assignable to type 'PseudoDeclaration'.
  Object literal may only specify known properties, and ''someKey'' does not exist in type 'PseudoDeclaration'.
tests/cases/conformance/types/members/indexSignatures1.ts(194,7): error TS2322: Type '"two"' is not assignable to type '`/${string}`'.
tests/cases/conformance/types/members/indexSignatures1.ts(197,7): error TS2322: Type 'number' is not assignable to type 'PathsObject'.


==== tests/cases/conformance/types/members/indexSignatures1.ts (31 errors) ====
    // Symbol index signature checking
    
    const sym = Symbol();
    
    function gg3(x: { [key: string]: string }, y: { [key: symbol]: string }, z: { [sym]: number }) {
        x = z;
        y = z;  // Error
        ~
!!! error TS2322: Type '{ [sym]: number; }' is not assignable to type '{ [key: symbol]: string; }'.
!!! error TS2322:   Property '[sym]' is incompatible with index signature.
!!! error TS2322:     Type 'number' is not assignable to type 'string'.
    }
    
    // Overlapping index signatures
    
    function gg1(x: { [key: `a${string}`]: string, [key: `${string}a`]: string }, y: { [key: `a${string}a`]: string }) {
        x = y;
        y = x;
    }
    
    interface IX { [key: `a${string}`]: string, [key: `${string}a`]: string }
    interface IY { [key: `a${string}a`]: string }
    
    function gg2(x: IX, y: IY) {
        x = y;  // Error
        ~
!!! error TS2322: Type 'IY' is not assignable to type 'IX'.
!!! error TS2322:   Index signature for type '`a${string}`' is missing in type 'IY'.
        y = x;
    }
    
    // Intersection of multiple applicable index signatures
    
    declare let combo: { [x: `foo-${string}`]: 'a' | 'b' } & { [x: `${string}-bar`]: 'b' | 'c' };
    const x1 = combo['foo-test'];  // 'a' | 'b'
    const x2 = combo['test-bar'];  // 'b' | 'c'
    const x3 = combo['foo-test-bar'];  // 'b' (('a' | 'b') & ('b' | 'c'))
    
    declare var str: string;
    
    const x4 = combo[`foo-${str}`];
    const x5 = combo[`${str}-bar`];
    const x6 = combo[`foo-${str}-bar`];
    
    declare let combo2: { [x: `${string}xxx${string}` & `${string}yyy${string}`]: string };
    
    const x7 = combo2['axxxbyyyc'];
    const x8 = combo2['ayyyxxxbc'];
    const x9 = combo2['axxxbbbyc'];  // Error
               ~~~~~~~~~~~~~~~~~~~
!!! error TS7053: Element implicitly has an 'any' type because expression of type '"axxxbbbyc"' can't be used to index type '{ [x: `${string}xxx${string}` & `${string}yyy${string}`]: string; }'.
!!! error TS7053:   Property 'axxxbbbyc' does not exist on type '{ [x: `${string}xxx${string}` & `${string}yyy${string}`]: string; }'.
    
    // Property access on template pattern index signature
    
    declare let dom: { [x: `data${string}`]: string };
    const y1 = dom['data123'];
    const y2 = dom.data123;
    
    // Excess property checking for template pattern index signature
    
    dom = { data123: 'hello' };
    dom = { date123: 'hello' };  // Error
            ~~~~~~~~~~~~~~~~
!!! error TS2322: Type '{ date123: string; }' is not assignable to type '{ [x: `data${string}`]: string; }'.
!!! error TS2322:   Object literal may only specify known properties, and 'date123' does not exist in type '{ [x: `data${string}`]: string; }'.
    
    // Contextual typing by index signature with template literal pattern
    
    type Funcs = {
        [key: `s${string}`]: (x: string) => void,
        [key: `n${string}`]: (x: number) => void,
    }
    
    const funcs: Funcs = {
        sfoo: x => x.length,  // x: string
        nfoo: x => x * 2,     // n: number
    }
    
    // Duplicate index signature checking
    
    type Duplicates = {
        [key: string | number]: any;  // Error
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2374: Duplicate index signature for type 'number'.
        [key: number | symbol]: any;  // Error
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2374: Duplicate index signature for type 'number'.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2374: Duplicate index signature for type 'symbol'.
        [key: symbol | `foo${string}`]: any;  // Error
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2374: Duplicate index signature for type '`foo${string}`'.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2374: Duplicate index signature for type 'symbol'.
        [key: `foo${string}`]: any;  // Error
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2374: Duplicate index signature for type '`foo${string}`'.
    }
    
    // Conflicting index signature checking
    
    type Conflicting = {
        [key: `a${string}`]: 'a';
        [key: `${string}a`]: 'b';
        [key: `a${string}a`]: 'c';  // Error
        ~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2413: '`a${string}a`' index type '"c"' is not assignable to '`${string}a`' index type '"b"'.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2413: '`a${string}a`' index type '"c"' is not assignable to '`a${string}`' index type '"a"'.
    }
    
    // Invalid index signatures
    
    type Invalid<T extends string> = {
        [key: 'a' | 'b' | 'c']: string;  // Error
         ~~~
!!! error TS1337: An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.
        [key: T | number]: string;  // Error
         ~~~
!!! error TS1337: An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.
        [key: Error]: string;  // Error
         ~~~
!!! error TS1268: An index signature parameter type must be 'string', 'number', 'symbol', or a template literal type.
        [key: T & string]: string;  // Error
         ~~~
!!! error TS1337: An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.
    }
    
    // Intersections in index signatures
    
    type Tag1 = { __tag1__: void };
    type Tag2 = { __tag2__: void };
    
    type TaggedString1 = string & Tag1;
    type TaggedString2 = string & Tag2;
    
    declare let obj1: { [key: TaggedString1]: string };
    declare let obj2: { [key: TaggedString2]: string };
    declare let obj3: { [key: TaggedString1 | TaggedString2]: string };
    declare let obj4: { [key: TaggedString1 & TaggedString2]: string };
    
    declare let s0: string;
    declare let s1: TaggedString1;
    declare let s2: TaggedString2;
    declare let s3: TaggedString1 | TaggedString2;
    declare let s4: TaggedString1 & TaggedString2;
    
    obj1[s0];  // Error
    ~~~~~~~~
!!! error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ [key: TaggedString1]: string; }'.
!!! error TS7053:   No index signature with a parameter of type 'string' was found on type '{ [key: TaggedString1]: string; }'.
    obj1[s1];
    obj1[s2];  // Error
    ~~~~~~~~
!!! error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString2' can't be used to index type '{ [key: TaggedString1]: string; }'.
    obj1[s3];  // Error
    ~~~~~~~~
!!! error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString1 | TaggedString2' can't be used to index type '{ [key: TaggedString1]: string; }'.
    obj1[s4];
    
    obj2[s0];  // Error
    ~~~~~~~~
!!! error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ [key: TaggedString2]: string; }'.
!!! error TS7053:   No index signature with a parameter of type 'string' was found on type '{ [key: TaggedString2]: string; }'.
    obj2[s1];
    ~~~~~~~~
!!! error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString1' can't be used to index type '{ [key: TaggedString2]: string; }'.
    obj2[s2];
    obj2[s3];  // Error
    ~~~~~~~~
!!! error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString1 | TaggedString2' can't be used to index type '{ [key: TaggedString2]: string; }'.
    obj2[s4];
    
    obj3[s0];  // Error
    ~~~~~~~~
!!! error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ [key: TaggedString1]: string; [key: TaggedString2]: string; }'.
!!! error TS7053:   No index signature with a parameter of type 'string' was found on type '{ [key: TaggedString1]: string; [key: TaggedString2]: string; }'.
    obj3[s1];
    obj3[s2];
    obj3[s3];
    obj3[s4];
    
    obj4[s0];  // Error
    ~~~~~~~~
!!! error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ [key: string & Tag1 & Tag2]: string; }'.
!!! error TS7053:   No index signature with a parameter of type 'string' was found on type '{ [key: string & Tag1 & Tag2]: string; }'.
    obj4[s1];  // Error
    ~~~~~~~~
!!! error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString1' can't be used to index type '{ [key: string & Tag1 & Tag2]: string; }'.
    obj4[s2];  // Error
    ~~~~~~~~
!!! error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString2' can't be used to index type '{ [key: string & Tag1 & Tag2]: string; }'.
    obj4[s3];  // Error
    ~~~~~~~~
!!! error TS7053: Element implicitly has an 'any' type because expression of type 'TaggedString1 | TaggedString2' can't be used to index type '{ [key: string & Tag1 & Tag2]: string; }'.
    obj4[s4];
    
    // Repros from #1863
    
    const system = Symbol('system');
    const SomeSytePlugin = Symbol('SomeSytePlugin');
    
    interface Plugs {
        [key: symbol]: (...args: any) => unknown;
    }
    
    const plugins = {
        "user": {} as Plugs,
        [system]: {} as Plugs
    };
    
    plugins[system][SomeSytePlugin] = () => console.log('awsome');
    plugins[system][SomeSytePlugin]();
    
    var theAnswer: symbol = Symbol('secret');
    var obj = {} as Record<symbol, number>;
    obj[theAnswer] = 42;
    
    // Repro from #26470
    
    const directive = Symbol('directive');
    declare function foo<TArg, TRet, TDir>(options: { [x in string]: (arg: TArg) => TRet } & { [directive]?: TDir }): void;
    
    let case1 = foo({
        [directive]: (x: string) => 'str',
        addOne: (x: number) => x + 1,
        double: (x: number) => x + x,
    });
    
    let case2 = foo({
        addOne: (x: number) => x + 1,
        double: (x: number) => x + x,
        [directive]: (x: string) => 'str',
    });
    
    let case3 = foo({
        [directive]: 'str',
        addOne: (x: number) => x + 1,
        double: (x: number) => x + x,
    });
    
    // Repros from #42192
    
    type Pseudo = `&:${string}`;
    
    const AmIPseudo1: Pseudo = '&:test';
    const AmIPseudo: Pseudo = '&';  // Error
          ~~~~~~~~~
!!! error TS2322: Type '"&"' is not assignable to type '`&:${string}`'.
    
    type PseudoDeclaration = { [key in Pseudo]: string };
    
    const test: PseudoDeclaration = { 'someKey' : 'someValue' };  // Error
                                      ~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2322: Type '{ someKey: string; }' is not assignable to type 'PseudoDeclaration'.
!!! error TS2322:   Object literal may only specify known properties, and ''someKey'' does not exist in type 'PseudoDeclaration'.
    
    type FieldPattern = `/${string}`;
    
    const path1: FieldPattern = '/one';
    const path2: FieldPattern = 'two';  // Error
          ~~~~~
!!! error TS2322: Type '"two"' is not assignable to type '`/${string}`'.
    
    type PathsObject = { [P in FieldPattern]: object; };
    const pathObject: PathsObject = 123;  // Error
          ~~~~~~~~~~
!!! error TS2322: Type 'number' is not assignable to type 'PathsObject'.
    
    type IdType = `${number}-${number}-${number}-${number}`
    const id: IdType = '0000-0000-0000-0001';
    
    type A = Record<IdType, string>;
    
    const a: A = { [id]: 'test' }
    
    let aid = a[id];
    