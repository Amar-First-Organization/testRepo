=== tests/cases/compiler/inKeywordTypeguard.ts ===
class A { a: string; }
>A : A
>a : string

class B { b: string; }
>B : B
>b : string

function negativeClassesTest(x: A | B) {
>negativeClassesTest : (x: A | B) => void
>x : A | B

    if ("a" in x) {
>"a" in x : boolean
>"a" : "a"
>x : A | B

        x.b = "1";
>x.b = "1" : "1"
>x.b : any (error)
>x : A
>b : any (error)
>"1" : "1"

    } else {
        x.a = "1";
>x.a = "1" : "1"
>x.a : any (error)
>x : B
>a : any (error)
>"1" : "1"
    }
}

function positiveClassesTest(x: A | B) {
>positiveClassesTest : (x: A | B) => void
>x : A | B

    if ("a" in x) {
>"a" in x : boolean
>"a" : "a"
>x : A | B

        x.b = "1";
>x.b = "1" : "1"
>x.b : any (error)
>x : A
>b : any (error)
>"1" : "1"

    } else {
        x.a = "1";
>x.a = "1" : "1"
>x.a : any (error)
>x : B
>a : any (error)
>"1" : "1"
    }
}

class AWithOptionalProp { a?: string; }
>AWithOptionalProp : AWithOptionalProp
>a : string

class BWithOptionalProp { b?: string; }
>BWithOptionalProp : BWithOptionalProp
>b : string

function positiveTestClassesWithOptionalProperties(x: AWithOptionalProp | BWithOptionalProp) {
>positiveTestClassesWithOptionalProperties : (x: AWithOptionalProp | BWithOptionalProp) => void
>x : AWithOptionalProp | BWithOptionalProp

    if ("a" in x) {
>"a" in x : boolean
>"a" : "a"
>x : AWithOptionalProp | BWithOptionalProp

        x.a = "1";
>x.a = "1" : "1"
>x.a : string
>x : AWithOptionalProp
>a : string
>"1" : "1"

    } else {
        x.b = "1";
>x.b = "1" : "1"
>x.b : any (error)
>x : AWithOptionalProp | BWithOptionalProp
>b : any (error)
>"1" : "1"
    }
}

class AWithMethod {
>AWithMethod : AWithMethod

    a(): string { return ""; }
>a : () => string
>"" : ""
}

class BWithMethod {
>BWithMethod : BWithMethod

    b(): string { return ""; }
>b : () => string
>"" : ""
}

function negativeTestClassesWithMembers(x: AWithMethod | BWithMethod) {
>negativeTestClassesWithMembers : (x: AWithMethod | BWithMethod) => void
>x : AWithMethod | BWithMethod

    if ("a" in x) {
>"a" in x : boolean
>"a" : "a"
>x : AWithMethod | BWithMethod

        x.a();
>x.a() : string
>x.a : () => string
>x : AWithMethod
>a : () => string

        x.b();
>x.b() : any (error)
>x.b : any (error)
>x : AWithMethod
>b : any (error)

    } else {
    }
}

function negativeTestClassesWithMemberMissingInBothClasses(x: AWithMethod | BWithMethod) {
>negativeTestClassesWithMemberMissingInBothClasses : (x: AWithMethod | BWithMethod) => void
>x : AWithMethod | BWithMethod

    if ("c" in x) {
>"c" in x : boolean
>"c" : "c"
>x : AWithMethod | BWithMethod

        x.a();
>x.a() : any (error)
>x.a : any (error)
>x : never
>a : any (error)

        x.b();
>x.b() : any (error)
>x.b : any (error)
>x : never
>b : any (error)

    } else {
        x.a();
>x.a() : any (error)
>x.a : any (error)
>x : AWithMethod | BWithMethod
>a : any (error)

        x.b();
>x.b() : any (error)
>x.b : any (error)
>x : AWithMethod | BWithMethod
>b : any (error)
    }
}

class C { a: string; }
>C : C
>a : string

class D { a: string; }
>D : D
>a : string

function negativeMultipleClassesTest(x: A | B | C | D) {
>negativeMultipleClassesTest : (x: A | B | C | D) => void
>x : A | B | C | D

    if ("a" in x) {
>"a" in x : boolean
>"a" : "a"
>x : A | B | C | D

        x.b = "1";
>x.b = "1" : "1"
>x.b : any (error)
>x : A | C | D
>b : any (error)
>"1" : "1"

    } else {
        x.a = "1";
>x.a = "1" : "1"
>x.a : any (error)
>x : B
>a : any (error)
>"1" : "1"
    }
}

class ClassWithUnionProp { prop: A | B }
>ClassWithUnionProp : ClassWithUnionProp
>prop : A | B

function negativePropTest(x: ClassWithUnionProp) {
>negativePropTest : (x: ClassWithUnionProp) => void
>x : ClassWithUnionProp

    if ("a" in x.prop) {
>"a" in x.prop : boolean
>"a" : "a"
>x.prop : A | B
>x : ClassWithUnionProp
>prop : A | B

        let y: string = x.prop.b;
>y : string
>x.prop.b : any (error)
>x.prop : A
>x : ClassWithUnionProp
>prop : A
>b : any (error)

    } else {
        let z: string = x.prop.a;
>z : string
>x.prop.a : any (error)
>x.prop : B
>x : ClassWithUnionProp
>prop : B
>a : any (error)
    }
}

class NegativeClassTest {
>NegativeClassTest : NegativeClassTest

    protected prop: A | B;
>prop : A | B

    inThis() {
>inThis : () => void

        if ("a" in this.prop) {
>"a" in this.prop : boolean
>"a" : "a"
>this.prop : A | B
>this : this
>prop : A | B

            let z: number = this.prop.b;
>z : number
>this.prop.b : any (error)
>this.prop : A
>this : this
>prop : A
>b : any (error)

        } else {
            let y: string = this.prop.a;
>y : string
>this.prop.a : any (error)
>this.prop : B
>this : this
>prop : B
>a : any (error)
        }
    }
}

class UnreachableCodeDetection {
>UnreachableCodeDetection : UnreachableCodeDetection

    a: string;
>a : string

    inThis() {
>inThis : () => void

        if ("a" in this) {
>"a" in this : boolean
>"a" : "a"
>this : this

        } else {
            let y = this.a;
>y : any (error)
>this.a : any (error)
>this : never
>a : any (error)
        }
    }
}
