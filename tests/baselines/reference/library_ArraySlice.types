=== tests/cases/compiler/library_ArraySlice.ts ===
// Array.prototype.slice can have zero, one, or two arguments
Array.prototype.slice();
>Array.prototype.slice() : any[]
>Array.prototype.slice : { (): any[]; (start?: number, end?: number): any[]; }
>Array.prototype : any[]
>Array : ArrayConstructor
>prototype : any[]
>slice : { (): any[]; (start?: number, end?: number): any[]; }

Array.prototype.slice(0);
>Array.prototype.slice(0) : any[]
>Array.prototype.slice : { (): any[]; (start?: number, end?: number): any[]; }
>Array.prototype : any[]
>Array : ArrayConstructor
>prototype : any[]
>slice : { (): any[]; (start?: number, end?: number): any[]; }
>0 : number

Array.prototype.slice(0, 1);
>Array.prototype.slice(0, 1) : any[]
>Array.prototype.slice : { (): any[]; (start?: number, end?: number): any[]; }
>Array.prototype : any[]
>Array : ArrayConstructor
>prototype : any[]
>slice : { (): any[]; (start?: number, end?: number): any[]; }
>0 : number
>1 : number

// Array.prototype.slice returns this with zero arguments, allowing tuple slicing
let t1: [number, number] = [1, 2];
>t1 : [number, number]
>[1, 2] : [number, number]
>1 : number
>2 : number

let t2: [number, number] = t1.slice();
>t2 : [number, number]
>t1.slice() : [number, number]
>t1.slice : { (): [number, number]; (start?: number, end?: number): number[]; }
>t1 : [number, number]
>slice : { (): [number, number]; (start?: number, end?: number): number[]; }

