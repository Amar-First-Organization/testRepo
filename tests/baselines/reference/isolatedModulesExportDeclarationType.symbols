//// [tests/cases/compiler/isolatedModulesExportDeclarationType.ts] ////

=== /type.ts ===
export type T = number;
>T : Symbol(T, Decl(type.ts, 0, 0))

=== /test1.ts ===
import { T } from "./type";
>T : Symbol(T, Decl(test1.ts, 0, 8), Decl(test1.ts, 1, 5))

const T = 0;      // Error as of #56354
>T : Symbol(T, Decl(test1.ts, 0, 8), Decl(test1.ts, 1, 5))

export default T; // Ok
>T : Symbol(T, Decl(test1.ts, 0, 8), Decl(test1.ts, 1, 5))

=== /test2.ts ===
import { T } from "./type";
>T : Symbol(T, Decl(test2.ts, 0, 8), Decl(test2.ts, 0, 27))

type T = number;  // Merge error
>T : Symbol(T, Decl(test2.ts, 0, 8), Decl(test2.ts, 0, 27))

export default T; // Transpiler could assume the alias resolves to a value?
>T : Symbol(T, Decl(test2.ts, 0, 8), Decl(test2.ts, 0, 27))

=== /test3.ts ===
import { T } from "./type";
>T : Symbol(T, Decl(test3.ts, 0, 8))

export default T; // Error
>T : Symbol(T, Decl(test3.ts, 0, 8))

