=== tests/cases/conformance/types/structuralTags/structuralTagTypesUsingGlobalTagAlias.ts ===
export type Paired = {
>Paired : Paired

    x: number & Tag<"x">;
>x : any

    y: number & Tag<"y">;
>y : any

};


export function isPaired(x: {x: number, y: number}): x is Paired {
>isPaired : (x: { x: number; y: number; }) => x is Paired
>x : { x: number; y: number; }
>x : number
>y : number

    return true;
>true : true
}

export function makePair(x: number, y: number): Paired {
>makePair : (x: number, y: number) => Paired
>x : number
>y : number

    return {x, y} as Paired;
>{x, y} as Paired : Paired
>{x, y} : { x: number; y: number; }
>x : number
>y : number
}

const a = makePair(0, 0);
>a : Paired
>makePair(0, 0) : Paired
>makePair : (x: number, y: number) => Paired
>0 : 0
>0 : 0

const b = {x: 0, y: 0};
>b : { x: number; y: number; }
>{x: 0, y: 0} : { x: number; y: number; }
>x : number
>0 : 0
>y : number
>0 : 0

if (Math.random() > 0.3) {
>Math.random() > 0.3 : boolean
>Math.random() : number
>Math.random : () => number
>Math : Math
>random : () => number
>0.3 : 0.3

    b.x = a.x;
>b.x = a.x : any
>b.x : number
>b : { x: number; y: number; }
>x : number
>a.x : any
>a : Paired
>x : any

    b.y = a.y;
>b.y = a.y : any
>b.y : number
>b : { x: number; y: number; }
>y : number
>a.y : any
>a : Paired
>y : any
}

if (isPaired(b)) {
>isPaired(b) : boolean
>isPaired : (x: { x: number; y: number; }) => x is Paired
>b : { x: number; y: number; }

    b.x = a.x;
>b.x = a.x : any
>b.x : number
>b : { x: number; y: number; }
>x : number
>a.x : any
>a : Paired
>x : any

    b.y = a.y;
>b.y = a.y : any
>b.y : number
>b : { x: number; y: number; }
>y : number
>a.y : any
>a : Paired
>y : any

    a.x = b.x;
>a.x = b.x : number
>a.x : any
>a : Paired
>x : any
>b.x : number
>b : { x: number; y: number; }
>x : number

    a.y = b.y;
>a.y = b.y : number
>a.y : any
>a : Paired
>y : any
>b.y : number
>b : { x: number; y: number; }
>y : number
}


type NormalizedPath = string & Tag<"NormalizedPath">;
>NormalizedPath : any

type AbsolutePath = string & Tag<"AbsolutePath">;
>AbsolutePath : any

type NormalizedAbsolutePath = NormalizedPath & AbsolutePath;
>NormalizedAbsolutePath : any

declare function isNormalizedPath(x: string): x is NormalizedPath;
>isNormalizedPath : (x: string) => x is any
>x : string

declare function isAbsolutePath(x: string): x is AbsolutePath;
>isAbsolutePath : (x: string) => x is any
>x : string

declare function consumeNormalizedPath(x: NormalizedPath): void;
>consumeNormalizedPath : (x: any) => void
>x : any

declare function consumeAbsolutePath(x: AbsolutePath): void;
>consumeAbsolutePath : (x: any) => void
>x : any

declare function consumeNormalizedOrAbsolutePath(x: NormalizedPath | AbsolutePath): void;
>consumeNormalizedOrAbsolutePath : (x: any) => void
>x : any

declare function consumeNormalizedAbsolutePath(x: NormalizedAbsolutePath): void;
>consumeNormalizedAbsolutePath : (x: any) => void
>x : any

const p = "/a/b/c";
>p : "/a/b/c"
>"/a/b/c" : "/a/b/c"

if (isNormalizedPath(p)) {
>isNormalizedPath(p) : boolean
>isNormalizedPath : (x: string) => x is any
>p : "/a/b/c"

    if (isAbsolutePath(p)) {
>isAbsolutePath(p) : boolean
>isAbsolutePath : (x: string) => x is any
>p : "/a/b/c"

        consumeNormalizedPath(p);
>consumeNormalizedPath(p) : void
>consumeNormalizedPath : (x: any) => void
>p : "/a/b/c"

        consumeAbsolutePath(p);
>consumeAbsolutePath(p) : void
>consumeAbsolutePath : (x: any) => void
>p : "/a/b/c"

        consumeNormalizedOrAbsolutePath(p);
>consumeNormalizedOrAbsolutePath(p) : void
>consumeNormalizedOrAbsolutePath : (x: any) => void
>p : "/a/b/c"

        consumeNormalizedAbsolutePath(p);
>consumeNormalizedAbsolutePath(p) : void
>consumeNormalizedAbsolutePath : (x: any) => void
>p : "/a/b/c"
    }
    else {
        consumeNormalizedPath(p);
>consumeNormalizedPath(p) : void
>consumeNormalizedPath : (x: any) => void
>p : never

        consumeAbsolutePath(p); // err
>consumeAbsolutePath(p) : void
>consumeAbsolutePath : (x: any) => void
>p : never

        consumeNormalizedOrAbsolutePath(p);
>consumeNormalizedOrAbsolutePath(p) : void
>consumeNormalizedOrAbsolutePath : (x: any) => void
>p : never

        consumeNormalizedAbsolutePath(p); // err
>consumeNormalizedAbsolutePath(p) : void
>consumeNormalizedAbsolutePath : (x: any) => void
>p : never
    }
}
else {
    if (isAbsolutePath(p)) {
>isAbsolutePath(p) : boolean
>isAbsolutePath : (x: string) => x is any
>p : never

        consumeNormalizedPath(p); // err
>consumeNormalizedPath(p) : void
>consumeNormalizedPath : (x: any) => void
>p : never

        consumeAbsolutePath(p);
>consumeAbsolutePath(p) : void
>consumeAbsolutePath : (x: any) => void
>p : never

        consumeNormalizedOrAbsolutePath(p);
>consumeNormalizedOrAbsolutePath(p) : void
>consumeNormalizedOrAbsolutePath : (x: any) => void
>p : never

        consumeNormalizedAbsolutePath(p); // err
>consumeNormalizedAbsolutePath(p) : void
>consumeNormalizedAbsolutePath : (x: any) => void
>p : never
    }
    else {
        consumeNormalizedPath(p); // err
>consumeNormalizedPath(p) : void
>consumeNormalizedPath : (x: any) => void
>p : never

        consumeAbsolutePath(p); // err
>consumeAbsolutePath(p) : void
>consumeAbsolutePath : (x: any) => void
>p : never

        consumeNormalizedOrAbsolutePath(p); // err
>consumeNormalizedOrAbsolutePath(p) : void
>consumeNormalizedOrAbsolutePath : (x: any) => void
>p : never

        consumeNormalizedAbsolutePath(p); // err
>consumeNormalizedAbsolutePath(p) : void
>consumeNormalizedAbsolutePath : (x: any) => void
>p : never
    }
}

