=== tests/cases/compiler/reverseMappedTypeInferFromItsProperties.ts ===
// repro from #29479

type Selector<S, R> = (state: S) => R;
>Selector : Selector<S, R>
>state : S

declare function createStructuredSelector<S, T>(selectors: {
>createStructuredSelector : <S, T>(selectors: { [K in keyof T]: Selector<S, T[K]>; }) => Selector<S, T>
>selectors : { [K in keyof T]: Selector<S, T[K]>; }

  [K in keyof T]: Selector<S, T[K]>;
}): Selector<S, T>;

type State = { foo: number };
>State : { foo: number; }
>foo : number

declare const mySelector: Selector<State, boolean>;
>mySelector : Selector<State, boolean>

export const result = createStructuredSelector({ mySelector });
>result : Selector<State, { mySelector: boolean; }>
>createStructuredSelector({ mySelector }) : Selector<State, { mySelector: boolean; }>
>createStructuredSelector : <S, T>(selectors: { [K in keyof T]: Selector<S, T[K]>; }) => Selector<S, T>
>{ mySelector } : { mySelector: Selector<State, boolean>; }
>mySelector : Selector<State, boolean>

// 52737#discussion_r1127035242
declare const otherSelectors: { [x: string]: Selector<State, boolean> };
>otherSelectors : { [x: string]: Selector<State, boolean>; }
>x : string

export const otherResult = createStructuredSelector(otherSelectors);
>otherResult : Selector<State, { [x: string]: any; }>
>createStructuredSelector(otherSelectors) : Selector<State, { [x: string]: any; }>
>createStructuredSelector : <S, T>(selectors: { [K in keyof T]: Selector<S, T[K]>; }) => Selector<S, T>
>otherSelectors : { [x: string]: Selector<State, boolean>; }

declare function inferFromValue<T, S extends string>(obj: { [K in keyof T]: S }): [T, S];
>inferFromValue : <T, S extends string>(obj: { [K in keyof T]: S; }) => [T, S]
>obj : { [K in keyof T]: S; }

const fromValue1 = inferFromValue({ a: "foo", b: "bar" });
>fromValue1 : [{ a: unknown; b: unknown; }, "foo" | "bar"]
>inferFromValue({ a: "foo", b: "bar" }) : [{ a: unknown; b: unknown; }, "foo" | "bar"]
>inferFromValue : <T, S extends string>(obj: { [K in keyof T]: S; }) => [T, S]
>{ a: "foo", b: "bar" } : { a: "foo"; b: "bar"; }
>a : "foo"
>"foo" : "foo"
>b : "bar"
>"bar" : "bar"

// 52737#issuecomment-1457046429
interface Righto<RT extends any[], ET = any> extends CPSFunction<[], RT, ET> {
  (): Righto<RT, ET>;
  _trace(): void;
>_trace : () => void
}
type ErrBack<RT extends any[] = [], ET = any> = (
>ErrBack : ErrBack<RT, ET>

  err?: ET,
>err : ET | undefined

  ...results: { [P in keyof RT]?: RT[P] }
>results : { [P in keyof RT]?: RT[P] | undefined; }

) => void;
type CPSFunction<AT extends any[], RT extends any[], ET> = (
>CPSFunction : CPSFunction<AT, RT, ET>

  ...args: [...AT, ErrBack<RT, ET>]
>args : [...AT, ErrBack<RT, ET>]

) => void;
type Flexible<T, ET = any> =
>Flexible : Flexible<T, ET>

  | T
  | Promise<T>
  | Righto<[T | undefined, ...any[]], ET>;
type ArgsAsFlexible<AT extends any[], ET> = {
>ArgsAsFlexible : ArgsAsFlexible<AT, ET>

  [T in keyof AT]: Flexible<AT[T], ET>;
};
declare function divideNumbersCPS(
>divideNumbersCPS : (a: number, b: number, callback: ErrBack<[number], Error>) => void

  a: number,
>a : number

  b: number,
>b : number

  callback: ErrBack<[number], Error>
>callback : ErrBack<[number], Error>

): void;
declare function righto<AT extends any[], RT extends any[], ET = any>(
>righto : <AT extends any[], RT extends any[], ET = any>(fn: CPSFunction<AT, RT, ET>, ...args: ArgsAsFlexible<AT, ET>) => Righto<RT, ET>

  fn: CPSFunction<AT, RT, ET>,
>fn : CPSFunction<AT, RT, ET>

  ...args: ArgsAsFlexible<AT, ET>
>args : ArgsAsFlexible<AT, ET>

): Righto<RT, ET>;
const rightoRes1 = righto(divideNumbersCPS, 1, 1);
>rightoRes1 : Righto<[number], unknown>
>righto(divideNumbersCPS, 1, 1) : Righto<[number], unknown>
>righto : <AT extends any[], RT extends any[], ET = any>(fn: CPSFunction<AT, RT, ET>, ...args: ArgsAsFlexible<AT, ET>) => Righto<RT, ET>
>divideNumbersCPS : (a: number, b: number, callback: ErrBack<[number], Error>) => void
>1 : 1
>1 : 1

