//// [tests/cases/conformance/types/intersection/intersectionNarrowing.ts] ////

=== intersectionNarrowing.ts ===
// Repros from #43130

function f1<T>(x: T & string | T & undefined) {
>f1 : <T>(x: (T & string) | (T & undefined)) => void
>   : ^ ^^^^^^          ^   ^             ^^^^^^^^^^
>x : (string & T) | (undefined & T)
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    if (x) {
>x : (string & T) | (undefined & T)
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        x;  // Should narrow to T & string
>x : string & T
>  : ^^^^^^^^^^
    }
}

function f2<T>(x: T & string | T & undefined) {
>f2 : <T>(x: (T & string) | (T & undefined)) => void
>   : ^ ^^^^^^          ^   ^             ^^^^^^^^^^
>x : (string & T) | (undefined & T)
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    if (x !== undefined) {
>x !== undefined : boolean
>                : ^^^^^^^
>x : (string & T) | (undefined & T)
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>undefined : undefined
>          : ^^^^^^^^^

        x;  // Should narrow to T & string
>x : string & T
>  : ^^^^^^^^^^
    }
    else {
        x;  // Should narrow to T & undefined
>x : undefined & T
>  : ^^^^^^^^^^^^^
    }
}

function f3<T>(x: T & string | T & number) {
>f3 : <T>(x: (T & string) | (T & number)) => void
>   : ^ ^^^^^^          ^   ^          ^^^^^^^^^^
>x : (string & T) | (number & T)
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^

    if (typeof x === "string") {
>typeof x === "string" : boolean
>                      : ^^^^^^^
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>         : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>x : (string & T) | (number & T)
>  : ^^^^^^^^^^^^^^^^^^^^^^^^^^^
>"string" : "string"
>         : ^^^^^^^^

        x;  // Should narrow to T & string
>x : string & T
>  : ^^^^^^^^^^
    }
    else {
        x;  // Should narrow to T & number
>x : number & T
>  : ^^^^^^^^^^
    }
}

function f4<T>(x: T & 1 | T & 2) {
>f4 : <T>(x: (T & 1) | (T & 2)) => void
>   : ^ ^^^^^^     ^   ^     ^^^^^^^^^^
>x : (T & 1) | (T & 2)
>  : ^^^^^^^^^^^^^^^^^

    switch (x) {
>x : (T & 1) | (T & 2)
>  : ^^^^^^^^^^^^^^^^^

        case 1: x; break;  // T & 1
>1 : 1
>  : ^
>x : T & 1
>  : ^^^^^

        case 2: x; break;  // T & 2
>2 : 2
>  : ^
>x : T & 2
>  : ^^^^^

        default: x;  // Should narrow to never
>x : never
>  : ^^^^^
    }
}

function f5<T extends string | number>(x: T & number) {
>f5 : <T extends string | number>(x: T & number) => void
>   : ^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^          ^^^^^^^^^
>x : number & T
>  : ^^^^^^^^^^

    const t1 = x === "hello";  // Should be an error
>t1 : boolean
>   : ^^^^^^^
>x === "hello" : boolean
>              : ^^^^^^^
>x : number & T
>  : ^^^^^^^^^^
>"hello" : "hello"
>        : ^^^^^^^
}

