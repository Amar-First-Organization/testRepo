=== tests/cases/conformance/types/members/unionIndexerGenericAssignability.ts ===
interface Foo3<T extends string> {
   [x: `data-${T}`]: number;
>x : `data-${T}`

   a: string;
>a : string
}

function goo<U extends string>(obj1: Foo3<U | 'hello'>, obj2: Foo3<U>) {
>goo : <U extends string>(obj1: Foo3<U | 'hello'>, obj2: Foo3<U>) => void
>obj1 : Foo3<U | "hello">
>obj2 : Foo3<U>

   obj1 = obj2;  // Error expected
>obj1 = obj2 : Foo3<U>
>obj1 : Foo3<U | "hello">
>obj2 : Foo3<U>

   obj2 = obj1;
>obj2 = obj1 : Foo3<U | "hello">
>obj2 : Foo3<U>
>obj1 : Foo3<U | "hello">
}

type Foo4<T extends string> = {
>Foo4 : Foo4<T>

    [x: `data-${T}`]: number;
>x : `data-${T}`

    a: string;
>a : string
 }
 
 function loo<U extends string>(obj1: Foo4<U | 'hello'>, obj2: Foo4<U>) {
>loo : <U extends string>(obj1: Foo4<U | 'hello'>, obj2: Foo4<U>) => void
>obj1 : Foo4<"hello" | U>
>obj2 : Foo4<U>

    obj1 = obj2;  // Error expected, doesn't occur because object types have "inferrable indexes"
>obj1 = obj2 : Foo4<U>
>obj1 : Foo4<"hello" | U>
>obj2 : Foo4<U>

    obj2 = obj1;
>obj2 = obj1 : Foo4<"hello" | U>
>obj2 : Foo4<U>
>obj1 : Foo4<"hello" | U>
 }

interface I1<T extends string> {
    [x: `data-${T}`]: number;
>x : `data-${T}`
}

function f1<
>f1 : <T extends string, U extends T>(a: `data-${T}`, b: `data-${U}`, aObj: { [_ in `data-${T}`]: any; }, bObj: { [_ in `data-${U}`]: any; }, aObj2: { [_ in `data-${T}`]?: any; }, bObj2: { [_ in `data-${U}`]?: any; }, aObj3: { [x: `data-${T}`]: number; }, bObj3: { [x: `data-${U}`]: number; }, aObj4: I1<T>, bObj4: I1<U>) => void

    T extends string,
    U extends T
>(
    a: `data-${T}`,
>a : `data-${T}`

    b: `data-${U}`,
>b : `data-${U}`

    aObj: {[_ in `data-${T}`]: any},
>aObj : { [_ in `data-${T}`]: any; }

    bObj: {[_ in `data-${U}`]: any},
>bObj : { [_ in `data-${U}`]: any; }

    aObj2: {[_ in `data-${T}`]?: any},
>aObj2 : { [_ in `data-${T}`]?: any; }

    bObj2: {[_ in `data-${U}`]?: any},
>bObj2 : { [_ in `data-${U}`]?: any; }

    aObj3: {[x: `data-${T}`]: number}, // type literals can have a "inferrable index"
>aObj3 : { [x: `data-${T}`]: number; }
>x : `data-${T}`

    bObj3: {[x: `data-${U}`]: number}, // type literals can have a "inferrable index"
>bObj3 : { [x: `data-${U}`]: number; }
>x : `data-${U}`

    aObj4: I1<T>,
>aObj4 : I1<T>

    bObj4: I1<U>,
>bObj4 : I1<U>

) {
    a = b;
>a = b : `data-${U}`
>a : `data-${T}`
>b : `data-${U}`

    b = a;
>b = a : `data-${T}`
>b : `data-${U}`
>a : `data-${T}`

    aObj = bObj;
>aObj = bObj : { [_ in `data-${U}`]: any; }
>aObj : { [_ in `data-${T}`]: any; }
>bObj : { [_ in `data-${U}`]: any; }

    bObj = aObj;
>bObj = aObj : { [_ in `data-${T}`]: any; }
>bObj : { [_ in `data-${U}`]: any; }
>aObj : { [_ in `data-${T}`]: any; }

    aObj2 = bObj2;
>aObj2 = bObj2 : { [_ in `data-${U}`]?: any; }
>aObj2 : { [_ in `data-${T}`]?: any; }
>bObj2 : { [_ in `data-${U}`]?: any; }

    bObj2 = aObj2;
>bObj2 = aObj2 : { [_ in `data-${T}`]?: any; }
>bObj2 : { [_ in `data-${U}`]?: any; }
>aObj2 : { [_ in `data-${T}`]?: any; }

    aObj3 = bObj3; // not an error because the type-literaly-ness of the source is allowing us to pretend it's closed and simply providing no members of the target at present - an "inferred index"
>aObj3 = bObj3 : { [x: `data-${U}`]: number; }
>aObj3 : { [x: `data-${T}`]: number; }
>bObj3 : { [x: `data-${U}`]: number; }

    bObj3 = aObj3;
>bObj3 = aObj3 : { [x: `data-${T}`]: number; }
>bObj3 : { [x: `data-${U}`]: number; }
>aObj3 : { [x: `data-${T}`]: number; }

    aObj4 = bObj4;
>aObj4 = bObj4 : I1<U>
>aObj4 : I1<T>
>bObj4 : I1<U>

    bObj4 = aObj4;
>bObj4 = aObj4 : I1<T>
>bObj4 : I1<U>
>aObj4 : I1<T>
}
