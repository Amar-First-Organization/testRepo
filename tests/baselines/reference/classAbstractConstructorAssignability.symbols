//// [tests/cases/conformance/classes/classDeclarations/classAbstractKeyword/classAbstractConstructorAssignability.ts] ////

=== classAbstractConstructorAssignability.ts ===
class A {}
>A : Symbol(A, Decl(classAbstractConstructorAssignability.ts, 0, 0))

abstract class B extends A {}
>B : Symbol(B, Decl(classAbstractConstructorAssignability.ts, 0, 10))
>A : Symbol(A, Decl(classAbstractConstructorAssignability.ts, 0, 0))

class C extends B {}
>C : Symbol(C, Decl(classAbstractConstructorAssignability.ts, 2, 29))
>B : Symbol(B, Decl(classAbstractConstructorAssignability.ts, 0, 10))

var AA : typeof A = B;
>AA : Symbol(AA, Decl(classAbstractConstructorAssignability.ts, 6, 3))
>A : Symbol(A, Decl(classAbstractConstructorAssignability.ts, 0, 0))
>B : Symbol(B, Decl(classAbstractConstructorAssignability.ts, 0, 10))

var BB : typeof B = A;
>BB : Symbol(BB, Decl(classAbstractConstructorAssignability.ts, 7, 3))
>B : Symbol(B, Decl(classAbstractConstructorAssignability.ts, 0, 10))
>A : Symbol(A, Decl(classAbstractConstructorAssignability.ts, 0, 0))

var CC : typeof C = B;
>CC : Symbol(CC, Decl(classAbstractConstructorAssignability.ts, 8, 3))
>C : Symbol(C, Decl(classAbstractConstructorAssignability.ts, 2, 29))
>B : Symbol(B, Decl(classAbstractConstructorAssignability.ts, 0, 10))

new AA;
>AA : Symbol(AA, Decl(classAbstractConstructorAssignability.ts, 6, 3))

new BB;
>BB : Symbol(BB, Decl(classAbstractConstructorAssignability.ts, 7, 3))

new CC;
>CC : Symbol(CC, Decl(classAbstractConstructorAssignability.ts, 8, 3))

// https://github.com/microsoft/TypeScript/issues/57412

// private methods have parameters stripped away in the generated declaration files
abstract class GeneratedConstructable {
>GeneratedConstructable : Symbol(GeneratedConstructable, Decl(classAbstractConstructorAssignability.ts, 12, 7))

  private constructor() {}
}

class MyPrivateClass {
>MyPrivateClass : Symbol(MyPrivateClass, Decl(classAbstractConstructorAssignability.ts, 19, 1))

  private privateVal: boolean;
>privateVal : Symbol(MyPrivateClass.privateVal, Decl(classAbstractConstructorAssignability.ts, 21, 22))

  private constructor(
    public readonly foo: string,
>foo : Symbol(MyPrivateClass.foo, Decl(classAbstractConstructorAssignability.ts, 23, 22))

    public readonly bar: string,
>bar : Symbol(MyPrivateClass.bar, Decl(classAbstractConstructorAssignability.ts, 24, 32))

  ) {
    this.privateVal = true;
>this.privateVal : Symbol(MyPrivateClass.privateVal, Decl(classAbstractConstructorAssignability.ts, 21, 22))
>this : Symbol(MyPrivateClass, Decl(classAbstractConstructorAssignability.ts, 19, 1))
>privateVal : Symbol(MyPrivateClass.privateVal, Decl(classAbstractConstructorAssignability.ts, 21, 22))
  }
}

export const funcThatAcceptsAnyGeneratedClass = (
>funcThatAcceptsAnyGeneratedClass : Symbol(funcThatAcceptsAnyGeneratedClass, Decl(classAbstractConstructorAssignability.ts, 31, 12))

  clazz: typeof GeneratedConstructable,
>clazz : Symbol(clazz, Decl(classAbstractConstructorAssignability.ts, 31, 49))
>GeneratedConstructable : Symbol(GeneratedConstructable, Decl(classAbstractConstructorAssignability.ts, 12, 7))

) => {};

funcThatAcceptsAnyGeneratedClass(MyPrivateClass);
>funcThatAcceptsAnyGeneratedClass : Symbol(funcThatAcceptsAnyGeneratedClass, Decl(classAbstractConstructorAssignability.ts, 31, 12))
>MyPrivateClass : Symbol(MyPrivateClass, Decl(classAbstractConstructorAssignability.ts, 19, 1))

abstract class AbstractClass1 {
>AbstractClass1 : Symbol(AbstractClass1, Decl(classAbstractConstructorAssignability.ts, 35, 49))

  private constructor(arg: string) {}
>arg : Symbol(arg, Decl(classAbstractConstructorAssignability.ts, 38, 22))
}

class SomeClass1 {
>SomeClass1 : Symbol(SomeClass1, Decl(classAbstractConstructorAssignability.ts, 39, 1))

  private constructor(arg: number) {}
>arg : Symbol(arg, Decl(classAbstractConstructorAssignability.ts, 42, 22))
}

const test1: typeof AbstractClass1 = SomeClass1;
>test1 : Symbol(test1, Decl(classAbstractConstructorAssignability.ts, 45, 5))
>AbstractClass1 : Symbol(AbstractClass1, Decl(classAbstractConstructorAssignability.ts, 35, 49))
>SomeClass1 : Symbol(SomeClass1, Decl(classAbstractConstructorAssignability.ts, 39, 1))

abstract class AbstractClass2 {
>AbstractClass2 : Symbol(AbstractClass2, Decl(classAbstractConstructorAssignability.ts, 45, 48))

  private constructor() {}
  private test = 10;
>test : Symbol(AbstractClass2.test, Decl(classAbstractConstructorAssignability.ts, 48, 26))
}

class SomeClass2 {
>SomeClass2 : Symbol(SomeClass2, Decl(classAbstractConstructorAssignability.ts, 50, 1))

  constructor() {}
}

const test2: typeof AbstractClass2 = SomeClass2;
>test2 : Symbol(test2, Decl(classAbstractConstructorAssignability.ts, 56, 5))
>AbstractClass2 : Symbol(AbstractClass2, Decl(classAbstractConstructorAssignability.ts, 45, 48))
>SomeClass2 : Symbol(SomeClass2, Decl(classAbstractConstructorAssignability.ts, 50, 1))

