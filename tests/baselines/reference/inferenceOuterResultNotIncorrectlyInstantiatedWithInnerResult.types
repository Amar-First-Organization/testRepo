//// [tests/cases/compiler/inferenceOuterResultNotIncorrectlyInstantiatedWithInnerResult.ts] ////

=== inferenceOuterResultNotIncorrectlyInstantiatedWithInnerResult.ts ===
// simple example
export class Test<A, B> {
>Test : Test<A, B>
>     : ^^^^^^^^^^

    constructor(public a: A, public b: B) { }
>a : A
>  : ^
>b : B
>  : ^

    test<C>(c: C): Test<B, C> {
>test : <C>(c: C) => Test<B, C>
>     : ^ ^^ ^^ ^^^^^          
>c : C
>  : ^

        return new Test(this.b, c);
>new Test(this.b, c) : Test<B, C>
>                    : ^^^^^^^^^^
>Test : typeof Test
>     : ^^^^^^^^^^^
>this.b : B
>       : ^
>this : this
>     : ^^^^
>b : B
>  : ^
>c : C
>  : ^
    }
}

// complicated one
interface Supervisor<out T> {
    zip<A>(right: Supervisor<A>): Supervisor<[T, A]>;
>zip : <A>(right: Supervisor<A>) => Supervisor<[T, A]>
>    : ^ ^^     ^^             ^^^^^                  
>right : Supervisor<A>
>      : ^^^^^^^^^^^^^
}

export class Zip<out T0, out T1> implements Supervisor<readonly [T0, T1]> {
>Zip : Zip<T0, T1>
>    : ^^^^^^^^^^^

    constructor(
        readonly left: Supervisor<T0>,
>left : Supervisor<T0>
>     : ^^^^^^^^^^^^^^

        readonly right: Supervisor<T1>,
>right : Supervisor<T1>
>      : ^^^^^^^^^^^^^^

    ) { }

    zip<A>(right: Supervisor<A>): Supervisor<[[T0, T1], A]> {
>zip : <A>(right: Supervisor<A>) => Supervisor<[[T0, T1], A]>
>    : ^ ^^     ^^             ^^^^^                         
>right : Supervisor<A>
>      : ^^^^^^^^^^^^^

        return new Zip(this, right);
>new Zip(this, right) : Zip<[T0, T1], A>
>                     : ^^^^^^^^^^^^^^^^
>Zip : typeof Zip
>    : ^^^^^^^^^^
>this : this
>     : ^^^^
>right : Supervisor<A>
>      : ^^^^^^^^^^^^^
    }
}
