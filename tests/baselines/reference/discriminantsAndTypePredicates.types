=== tests/cases/compiler/discriminantsAndTypePredicates.ts ===
// Repro from #10145

interface A { type: 'A' }
>type : "A"

interface B { type: 'B' }
>type : "B"

function isA(x: A | B): x is A { return x.type === 'A'; }
>isA : (x: A | B) => x is A
>x : A | B
>x.type === 'A' : boolean
>x.type : "A" | "B"
>x : A | B
>type : "A" | "B"
>'A' : "A"

function isB(x: A | B): x is B { return x.type === 'B'; }
>isB : (x: A | B) => x is B
>x : A | B
>x.type === 'B' : boolean
>x.type : "A" | "B"
>x : A | B
>type : "A" | "B"
>'B' : "B"

function foo1(x: A | B): any {
>foo1 : (x: A | B) => any
>x : A | B

    x;  // A | B
>x : A | B

    if (isA(x)) {
>isA(x) : boolean
>isA : (x: A | B) => x is A
>x : A | B

        return x;  // A
>x : A
    }
    x;  // B
>x : B

    if (isB(x)) {
>isB(x) : boolean
>isB : (x: A | B) => x is B
>x : B

        return x;  // B
>x : B
    }
    x;  // never
>x : never
}

function foo2(x: A | B): any {
>foo2 : (x: A | B) => any
>x : A | B

    x;  // A | B
>x : A | B

    if (x.type === 'A') {
>x.type === 'A' : boolean
>x.type : "A" | "B"
>x : A | B
>type : "A" | "B"
>'A' : "A"

        return x;  // A
>x : A
    }
    x;  // B
>x : B

    if (x.type === 'B') {
>x.type === 'B' : boolean
>x.type : "B"
>x : B
>type : "B"
>'B' : "B"

        return x;  // B
>x : B
    }
    x;  // never
>x : never
}

// Repro from #30557

interface TypeA {
    Name: "TypeA";
>Name : "TypeA"

    Value1: "Cool stuff!";
>Value1 : "Cool stuff!"
}

interface TypeB {
    Name: "TypeB";
>Name : "TypeB"

    Value2: 0;
>Value2 : 0
}

type Type = TypeA | TypeB;
>Type : Type

declare function isType(x: unknown): x is Type;
>isType : (x: unknown) => x is Type
>x : unknown

function WorksProperly(data: Type) {
>WorksProperly : (data: Type) => void
>data : Type

    if (data.Name === "TypeA") {
>data.Name === "TypeA" : boolean
>data.Name : "TypeA" | "TypeB"
>data : Type
>Name : "TypeA" | "TypeB"
>"TypeA" : "TypeA"

        // TypeA
        const value1 = data.Value1;
>value1 : "Cool stuff!"
>data.Value1 : "Cool stuff!"
>data : TypeA
>Value1 : "Cool stuff!"
    }
}

function DoesNotWork(data: unknown) {
>DoesNotWork : (data: unknown) => void
>data : unknown

    if (isType(data)) {
>isType(data) : boolean
>isType : (x: unknown) => x is Type
>data : unknown

        if (data.Name === "TypeA") {
>data.Name === "TypeA" : boolean
>data.Name : "TypeA" | "TypeB"
>data : Type
>Name : "TypeA" | "TypeB"
>"TypeA" : "TypeA"

            // TypeA
            const value1 = data.Value1;
>value1 : "Cool stuff!"
>data.Value1 : "Cool stuff!"
>data : TypeA
>Value1 : "Cool stuff!"
        }
    }
}

function narrowToNever(data: Type): "Cool stuff!" | 0 {
>narrowToNever : (data: Type) => 0 | "Cool stuff!"
>data : Type

    if (data.Name === "TypeA") {
>data.Name === "TypeA" : boolean
>data.Name : "TypeA" | "TypeB"
>data : Type
>Name : "TypeA" | "TypeB"
>"TypeA" : "TypeA"

        return data.Value1;
>data.Value1 : "Cool stuff!"
>data : TypeA
>Value1 : "Cool stuff!"
    }
    if (data.Name === "TypeB") {
>data.Name === "TypeB" : boolean
>data.Name : "TypeB"
>data : TypeB
>Name : "TypeB"
>"TypeB" : "TypeB"

        return data.Value2;
>data.Value2 : 0
>data : TypeB
>Value2 : 0
    }
    return data;
>data : never
}

function narrowToNeverUnknown(data: unknown): "Cool stuff!" | 0 {
>narrowToNeverUnknown : (data: unknown) => 0 | "Cool stuff!"
>data : unknown

    if (isType(data)) {
>isType(data) : boolean
>isType : (x: unknown) => x is Type
>data : unknown

        if (data.Name === "TypeA") {
>data.Name === "TypeA" : boolean
>data.Name : "TypeA" | "TypeB"
>data : Type
>Name : "TypeA" | "TypeB"
>"TypeA" : "TypeA"

            return data.Value1;
>data.Value1 : "Cool stuff!"
>data : TypeA
>Value1 : "Cool stuff!"
        }
        if (data.Name === "TypeB") {
>data.Name === "TypeB" : boolean
>data.Name : "TypeB"
>data : TypeB
>Name : "TypeB"
>"TypeB" : "TypeB"

            return data.Value2;
>data.Value2 : 0
>data : TypeB
>Value2 : 0
        }
        return data;
>data : never
    }
    throw "error";
>"error" : "error"
}

type Foo = { kind: "a", a: number } | { kind: "b", b: number };
>Foo : Foo
>kind : "a"
>a : number
>kind : "b"
>b : number

type Bar = { kind: "c", c: number } | { kind: "d", d: number };
>Bar : Bar
>kind : "c"
>c : number
>kind : "d"
>d : number

declare function isFoo(x: unknown): x is Foo;
>isFoo : (x: unknown) => x is Foo
>x : unknown

declare function isBar(x: unknown): x is Bar;
>isBar : (x: unknown) => x is Bar
>x : unknown

function blah(x: unknown) {
>blah : (x: unknown) => void
>x : unknown

    if (isFoo(x)) {
>isFoo(x) : boolean
>isFoo : (x: unknown) => x is Foo
>x : unknown

        if (x.kind === "a") {
>x.kind === "a" : boolean
>x.kind : "a" | "b"
>x : Foo
>kind : "a" | "b"
>"a" : "a"

            let a = x.a;
>a : number
>x.a : number
>x : { kind: "a"; a: number; }
>a : number
        }
        else if (x.kind === "b") {
>x.kind === "b" : boolean
>x.kind : "b"
>x : { kind: "b"; b: number; }
>kind : "b"
>"b" : "b"

            let b = x.b;
>b : number
>x.b : number
>x : { kind: "b"; b: number; }
>b : number
        }
    }
    else if (isBar(x)) {
>isBar(x) : boolean
>isBar : (x: unknown) => x is Bar
>x : unknown

        if (x.kind === "c") {
>x.kind === "c" : boolean
>x.kind : "c" | "d"
>x : Bar
>kind : "c" | "d"
>"c" : "c"

            let c = x.c;
>c : number
>x.c : number
>x : { kind: "c"; c: number; }
>c : number
        }
        else if (x.kind === "d") {
>x.kind === "d" : boolean
>x.kind : "d"
>x : { kind: "d"; d: number; }
>kind : "d"
>"d" : "d"

            let d = x.d;
>d : number
>x.d : number
>x : { kind: "d"; d: number; }
>d : number
        }
    }
    x  // unknown
>x : unknown
}

type PrimitiveUnion = number | string
>PrimitiveUnion : PrimitiveUnion

type FooComplex = { kind: "a", a: number } | { kind: "b", b: number } | number;
>FooComplex : FooComplex
>kind : "a"
>a : number
>kind : "b"
>b : number

type BarComplex = { kind: "c", c: number } | { kind: "d", d: number } | string;
>BarComplex : BarComplex
>kind : "c"
>c : number
>kind : "d"
>d : number

declare function isPrimitiveUnion(x: unknown): x is PrimitiveUnion;
>isPrimitiveUnion : (x: unknown) => x is PrimitiveUnion
>x : unknown

declare function isFooComplex(x: unknown): x is FooComplex;
>isFooComplex : (x: unknown) => x is FooComplex
>x : unknown

declare function isBarComplex(x: unknown): x is BarComplex;
>isBarComplex : (x: unknown) => x is BarComplex
>x : unknown

declare function isZZYYComplex(x: unknown): x is { kind: "z"; zzz: string } | { kind: "y", yyy: number };
>isZZYYComplex : (x: unknown) => x is { kind: "z"; zzz: string; } | { kind: "y"; yyy: number; }
>x : unknown
>kind : "z"
>zzz : string
>kind : "y"
>yyy : number

function earlyExitsAndStuff(x: unknown) {
>earlyExitsAndStuff : (x: unknown) => PrimitiveUnion
>x : unknown

    if (!isFooComplex(x) && !isBarComplex(x)) {
>!isFooComplex(x) && !isBarComplex(x) : boolean
>!isFooComplex(x) : boolean
>isFooComplex(x) : boolean
>isFooComplex : (x: unknown) => x is FooComplex
>x : unknown
>!isBarComplex(x) : boolean
>isBarComplex(x) : boolean
>isBarComplex : (x: unknown) => x is BarComplex
>x : unknown

        if (isZZYYComplex(x)) {
>isZZYYComplex(x) : boolean
>isZZYYComplex : (x: unknown) => x is { kind: "z"; zzz: string; } | { kind: "y"; yyy: number; }
>x : unknown

            if (x.kind !== "z") {
>x.kind !== "z" : boolean
>x.kind : "z" | "y"
>x : { kind: "z"; zzz: string; } | { kind: "y"; yyy: number; }
>kind : "z" | "y"
>"z" : "z"

                return x.yyy;
>x.yyy : number
>x : { kind: "y"; yyy: number; }
>yyy : number
            }
            return x.zzz;
>x.zzz : string
>x : { kind: "z"; zzz: string; }
>zzz : string
        }
        return;
    }
    if (!!isPrimitiveUnion(x)) {
>!!isPrimitiveUnion(x) : boolean
>!isPrimitiveUnion(x) : boolean
>isPrimitiveUnion(x) : boolean
>isPrimitiveUnion : (x: unknown) => x is PrimitiveUnion
>x : string | number | { kind: "a"; a: number; } | { kind: "b"; b: number; } | { kind: "c"; c: number; } | { kind: "d"; d: number; }

        return x;
>x : PrimitiveUnion
    }
    if (!isZZYYComplex(x)) {
>!isZZYYComplex(x) : boolean
>isZZYYComplex(x) : boolean
>isZZYYComplex : (x: unknown) => x is { kind: "z"; zzz: string; } | { kind: "y"; yyy: number; }
>x : { kind: "a"; a: number; } | { kind: "b"; b: number; } | { kind: "c"; c: number; } | { kind: "d"; d: number; }

        if (x.kind === "a") {
>x.kind === "a" : boolean
>x.kind : "a" | "b" | "c" | "d"
>x : { kind: "a"; a: number; } | { kind: "b"; b: number; } | { kind: "c"; c: number; } | { kind: "d"; d: number; }
>kind : "a" | "b" | "c" | "d"
>"a" : "a"

            let a = x.a;
>a : number
>x.a : number
>x : { kind: "a"; a: number; }
>a : number
        }
        if (x.kind === "b") {
>x.kind === "b" : boolean
>x.kind : "a" | "b" | "c" | "d"
>x : { kind: "a"; a: number; } | { kind: "b"; b: number; } | { kind: "c"; c: number; } | { kind: "d"; d: number; }
>kind : "a" | "b" | "c" | "d"
>"b" : "b"

            let b = x.b;
>b : number
>x.b : number
>x : { kind: "b"; b: number; }
>b : number
        }
        if (x.kind === "c") {
>x.kind === "c" : boolean
>x.kind : "a" | "b" | "c" | "d"
>x : { kind: "a"; a: number; } | { kind: "b"; b: number; } | { kind: "c"; c: number; } | { kind: "d"; d: number; }
>kind : "a" | "b" | "c" | "d"
>"c" : "c"

            let c = x.c;
>c : number
>x.c : number
>x : { kind: "c"; c: number; }
>c : number
        }
        if (x.kind === "d") {
>x.kind === "d" : boolean
>x.kind : "a" | "b" | "c" | "d"
>x : { kind: "a"; a: number; } | { kind: "b"; b: number; } | { kind: "c"; c: number; } | { kind: "d"; d: number; }
>kind : "a" | "b" | "c" | "d"
>"d" : "d"

            let d = x.d;
>d : number
>x.d : number
>x : { kind: "d"; d: number; }
>d : number
        }
    }
}

function bluergh(x: unknown) {
>bluergh : (x: unknown) => void
>x : unknown

    if (isPrimitiveUnion(x)) {
>isPrimitiveUnion(x) : boolean
>isPrimitiveUnion : (x: unknown) => x is PrimitiveUnion
>x : unknown

        let a: number | string = x;
>a : PrimitiveUnion
>x : PrimitiveUnion

        return;
    }
    if (isFooComplex(x) && typeof x === "object") {
>isFooComplex(x) && typeof x === "object" : boolean
>isFooComplex(x) : boolean
>isFooComplex : (x: unknown) => x is FooComplex
>x : unknown
>typeof x === "object" : boolean
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>x : FooComplex
>"object" : "object"

        if (x.kind === "a") {
>x.kind === "a" : boolean
>x.kind : "a" | "b"
>x : { kind: "a"; a: number; } | { kind: "b"; b: number; }
>kind : "a" | "b"
>"a" : "a"

            let a = x.a;
>a : number
>x.a : number
>x : { kind: "a"; a: number; }
>a : number
        }
        else if (x.kind === "b") {
>x.kind === "b" : boolean
>x.kind : "b"
>x : { kind: "b"; b: number; }
>kind : "b"
>"b" : "b"

            let b = x.b;
>b : number
>x.b : number
>x : { kind: "b"; b: number; }
>b : number
        }
    }
    if (isPrimitiveUnion(x)) {
>isPrimitiveUnion(x) : boolean
>isPrimitiveUnion : (x: unknown) => x is PrimitiveUnion
>x : unknown

        let a: number | string = x;
>a : PrimitiveUnion
>x : PrimitiveUnion
    }
    if (isBarComplex(x) && typeof x === "object") {
>isBarComplex(x) && typeof x === "object" : boolean
>isBarComplex(x) : boolean
>isBarComplex : (x: unknown) => x is BarComplex
>x : unknown
>typeof x === "object" : boolean
>typeof x : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>x : BarComplex
>"object" : "object"

        if (x.kind === "c") {
>x.kind === "c" : boolean
>x.kind : "c" | "d"
>x : { kind: "c"; c: number; } | { kind: "d"; d: number; }
>kind : "c" | "d"
>"c" : "c"

            let c = x.c;
>c : number
>x.c : number
>x : { kind: "c"; c: number; }
>c : number
        }
        else if (x.kind === "d") {
>x.kind === "d" : boolean
>x.kind : "d"
>x : { kind: "d"; d: number; }
>kind : "d"
>"d" : "d"

            let d = x.d;
>d : number
>x.d : number
>x : { kind: "d"; d: number; }
>d : number
        }
    }
    if (isPrimitiveUnion(x)) {
>isPrimitiveUnion(x) : boolean
>isPrimitiveUnion : (x: unknown) => x is PrimitiveUnion
>x : unknown

        let a: number | string = x;
>a : PrimitiveUnion
>x : PrimitiveUnion
    }
    x  // unknown
>x : unknown
}

type A1 = { x: number };
>A1 : A1
>x : number

type B1 = A1 & { kind: "B"; y: number };
>B1 : B1
>kind : "B"
>y : number

type C1 = A1 & { kind: "C"; z: number };
>C1 : C1
>kind : "C"
>z : number

function isBorC(a: A1): a is B1 | C1 {
>isBorC : (a: A1) => a is B1 | C1
>a : A1

    return (a as any).kind === "B" || (a as any).kind === "C";
>(a as any).kind === "B" || (a as any).kind === "C" : boolean
>(a as any).kind === "B" : boolean
>(a as any).kind : any
>(a as any) : any
>a as any : any
>a : A1
>kind : any
>"B" : "B"
>(a as any).kind === "C" : boolean
>(a as any).kind : any
>(a as any) : any
>a as any : any
>a : A1
>kind : any
>"C" : "C"
}

function isB1(a: A1): a is B1 {
>isB1 : (a: A1) => a is B1
>a : A1

    return (a as any).kind === "B";
>(a as any).kind === "B" : boolean
>(a as any).kind : any
>(a as any) : any
>a as any : any
>a : A1
>kind : any
>"B" : "B"
}

function isC1(a: A1): a is C1 {
>isC1 : (a: A1) => a is C1
>a : A1

    return (a as any).kind === "C";
>(a as any).kind === "C" : boolean
>(a as any).kind : any
>(a as any) : any
>a as any : any
>a : A1
>kind : any
>"C" : "C"
}

function fn1(a: A1) {
>fn1 : (a: A1) => void
>a : A1

    if (isBorC(a)) {
>isBorC(a) : boolean
>isBorC : (a: A1) => a is B1 | C1
>a : A1

        if (a.kind === "B") {
>a.kind === "B" : boolean
>a.kind : "B" | "C"
>a : B1 | C1
>kind : "B" | "C"
>"B" : "B"

            a.y;
>a.y : number
>a : B1
>y : number
        }
    }
}

function fn2(a: A1) {
>fn2 : (a: A1) => void
>a : A1

    if (!isB1(a)) {
>!isB1(a) : boolean
>isB1(a) : boolean
>isB1 : (a: A1) => a is B1
>a : A1

        return;
    }
    if (!isC1(a)) {
>!isC1(a) : boolean
>isC1(a) : boolean
>isC1 : (a: A1) => a is C1
>a : B1

        if (a.kind === "B") {
>a.kind === "B" : boolean
>a.kind : "B"
>a : B1
>kind : "B"
>"B" : "B"

            a.y;
>a.y : number
>a : B1
>y : number
        }
        return;
    }
    if (a.kind === "B") {
>a.kind === "B" : boolean
>a.kind : never
>a : A1 & { kind: "B"; y: number; } & { kind: "C"; z: number; }
>kind : never
>"B" : "B"

        a.y;
>a.y : number
>a : A1 & { kind: "B"; y: number; } & { kind: "C"; z: number; }
>y : number
    }
}

declare function isTypeObj(x: unknown): x is { kind1: string, a?: number, b?: number };
>isTypeObj : (x: unknown) => x is { kind1: string; a?: number; b?: number; }
>x : unknown
>kind1 : string
>a : number
>b : number

declare function isTypeAB(x: unknown): x is { kind1: 'a', a: 1 } | { kind1: 'b', b: 2 };
>isTypeAB : (x: unknown) => x is { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>x : unknown
>kind1 : "a"
>a : 1
>kind1 : "b"
>b : 2

declare function isTypeCD(x: unknown): x is { kind2: 'c', c: 3 } | { kind2: 'd', d: 4 };
>isTypeCD : (x: unknown) => x is { kind2: "c"; c: 3; } | { kind2: "d"; d: 4; }
>x : unknown
>kind2 : "c"
>c : 3
>kind2 : "d"
>d : 4

function testComposition1(x: unknown) {
>testComposition1 : (x: unknown) => void
>x : unknown

    if (isTypeAB(x)) {
>isTypeAB(x) : boolean
>isTypeAB : (x: unknown) => x is { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>x : unknown

        if (isTypeCD(x)) {
>isTypeCD(x) : boolean
>isTypeCD : (x: unknown) => x is { kind2: "c"; c: 3; } | { kind2: "d"; d: 4; }
>x : { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }

            if (x.kind1 === 'a') {
>x.kind1 === 'a' : boolean
>x.kind1 : "a" | "b"
>x : ({ kind1: "a"; a: 1; } & { kind2: "c"; c: 3; }) | ({ kind1: "a"; a: 1; } & { kind2: "d"; d: 4; }) | ({ kind1: "b"; b: 2; } & { kind2: "c"; c: 3; }) | ({ kind1: "b"; b: 2; } & { kind2: "d"; d: 4; })
>kind1 : "a" | "b"
>'a' : "a"

                x.a;
>x.a : 1
>x : ({ kind1: "a"; a: 1; } & { kind2: "c"; c: 3; }) | ({ kind1: "a"; a: 1; } & { kind2: "d"; d: 4; })
>a : 1
            }
            if (x.kind2 === 'c') {
>x.kind2 === 'c' : boolean
>x.kind2 : "c" | "d"
>x : ({ kind1: "a"; a: 1; } & { kind2: "c"; c: 3; }) | ({ kind1: "a"; a: 1; } & { kind2: "d"; d: 4; }) | ({ kind1: "b"; b: 2; } & { kind2: "c"; c: 3; }) | ({ kind1: "b"; b: 2; } & { kind2: "d"; d: 4; })
>kind2 : "c" | "d"
>'c' : "c"

                x.c;
>x.c : 3
>x : ({ kind1: "a"; a: 1; } & { kind2: "c"; c: 3; }) | ({ kind1: "b"; b: 2; } & { kind2: "c"; c: 3; })
>c : 3
            }
        }
        if (x.kind1 === 'a') {
>x.kind1 === 'a' : boolean
>x.kind1 : "a" | "b"
>x : { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>kind1 : "a" | "b"
>'a' : "a"

            x.a;
>x.a : 1
>x : { kind1: "a"; a: 1; }
>a : 1
        }
        if (x.kind2 === 'c') {
>x.kind2 === 'c' : boolean
>x.kind2 : any
>x : { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>kind2 : any
>'c' : "c"

            x.c;
>x.c : any
>x : { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>c : any
        }
    }
}

function testComposition2(x: unknown) {
>testComposition2 : (x: unknown) => void
>x : unknown

    if (isTypeObj(x)) {
>isTypeObj(x) : boolean
>isTypeObj : (x: unknown) => x is { kind1: string; a?: number; b?: number; }
>x : unknown

        if (isTypeAB(x)) {
>isTypeAB(x) : boolean
>isTypeAB : (x: unknown) => x is { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>x : { kind1: string; a?: number; b?: number; }

            if (x.kind1 === "a") {
>x.kind1 === "a" : boolean
>x.kind1 : "a" | "b"
>x : { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>kind1 : "a" | "b"
>"a" : "a"

                x.a;
>x.a : 1
>x : { kind1: "a"; a: 1; }
>a : 1
            }
        }
        if (x.kind1 === "a") {
>x.kind1 === "a" : boolean
>x.kind1 : string
>x : { kind1: string; a?: number; b?: number; } | { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>kind1 : string
>"a" : "a"

            x.a; // Error
>x.a : any
>x : { kind1: string; a?: number; b?: number; } | { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>a : any
        }
    }
}

function testComposition3(x: unknown) {
>testComposition3 : (x: unknown) => void
>x : unknown

    if (isTypeAB(x)) {
>isTypeAB(x) : boolean
>isTypeAB : (x: unknown) => x is { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>x : unknown

        if (x.kind1 === 'a') {
>x.kind1 === 'a' : boolean
>x.kind1 : "a" | "b"
>x : { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>kind1 : "a" | "b"
>'a' : "a"

            x.a;
>x.a : 1
>x : { kind1: "a"; a: 1; }
>a : 1
        }
        return;
    }
    if (x.kind1 === 'a') {
>x.kind1 === 'a' : boolean
>x.kind1 : any
>x : unknown
>kind1 : any
>'a' : "a"

        x.a;  // Error
>x.a : any
>x : unknown
>a : any
    }
    if (isTypeCD(x)) {
>isTypeCD(x) : boolean
>isTypeCD : (x: unknown) => x is { kind2: "c"; c: 3; } | { kind2: "d"; d: 4; }
>x : unknown

        if (x.kind2 === 'c') {
>x.kind2 === 'c' : boolean
>x.kind2 : "c" | "d"
>x : { kind2: "c"; c: 3; } | { kind2: "d"; d: 4; }
>kind2 : "c" | "d"
>'c' : "c"

            x.c;
>x.c : 3
>x : { kind2: "c"; c: 3; }
>c : 3
        }
        return;
    }
    if (x.kind2 === 'c') {
>x.kind2 === 'c' : boolean
>x.kind2 : any
>x : unknown
>kind2 : any
>'c' : "c"

        x.c;  // Error
>x.c : any
>x : unknown
>c : any
    }
    if (isTypeAB(x)) {
>isTypeAB(x) : boolean
>isTypeAB : (x: unknown) => x is { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>x : unknown

        if (isTypeCD(x)) {
>isTypeCD(x) : boolean
>isTypeCD : (x: unknown) => x is { kind2: "c"; c: 3; } | { kind2: "d"; d: 4; }
>x : { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }

            if (x.kind1 === 'a') {
>x.kind1 === 'a' : boolean
>x.kind1 : "a" | "b"
>x : ({ kind1: "a"; a: 1; } & { kind2: "c"; c: 3; }) | ({ kind1: "a"; a: 1; } & { kind2: "d"; d: 4; }) | ({ kind1: "b"; b: 2; } & { kind2: "c"; c: 3; }) | ({ kind1: "b"; b: 2; } & { kind2: "d"; d: 4; })
>kind1 : "a" | "b"
>'a' : "a"

                x.a;
>x.a : 1
>x : ({ kind1: "a"; a: 1; } & { kind2: "c"; c: 3; }) | ({ kind1: "a"; a: 1; } & { kind2: "d"; d: 4; })
>a : 1
            }
            if (x.kind2 === 'c') {
>x.kind2 === 'c' : boolean
>x.kind2 : "c" | "d"
>x : ({ kind1: "a"; a: 1; } & { kind2: "c"; c: 3; }) | ({ kind1: "a"; a: 1; } & { kind2: "d"; d: 4; }) | ({ kind1: "b"; b: 2; } & { kind2: "c"; c: 3; }) | ({ kind1: "b"; b: 2; } & { kind2: "d"; d: 4; })
>kind2 : "c" | "d"
>'c' : "c"

                x.c;
>x.c : 3
>x : ({ kind1: "a"; a: 1; } & { kind2: "c"; c: 3; }) | ({ kind1: "b"; b: 2; } & { kind2: "c"; c: 3; })
>c : 3
            }
        }
    }
}

function looper(getter: () => unknown) {
>looper : (getter: () => unknown) => void
>getter : () => unknown

    let x = getter();
>x : unknown
>getter() : unknown
>getter : () => unknown

    while (isTypeAB(x)) {
>isTypeAB(x) : boolean
>isTypeAB : (x: unknown) => x is { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>x : unknown

        if (isTypeCD(x)) {
>isTypeCD(x) : boolean
>isTypeCD : (x: unknown) => x is { kind2: "c"; c: 3; } | { kind2: "d"; d: 4; }
>x : { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }

            if (x.kind1 === 'a') {
>x.kind1 === 'a' : boolean
>x.kind1 : "a" | "b"
>x : ({ kind1: "a"; a: 1; } & { kind2: "c"; c: 3; }) | ({ kind1: "a"; a: 1; } & { kind2: "d"; d: 4; }) | ({ kind1: "b"; b: 2; } & { kind2: "c"; c: 3; }) | ({ kind1: "b"; b: 2; } & { kind2: "d"; d: 4; })
>kind1 : "a" | "b"
>'a' : "a"

                x.a;
>x.a : 1
>x : ({ kind1: "a"; a: 1; } & { kind2: "c"; c: 3; }) | ({ kind1: "a"; a: 1; } & { kind2: "d"; d: 4; })
>a : 1
            }
            if (x.kind2 === 'c') {
>x.kind2 === 'c' : boolean
>x.kind2 : "c" | "d"
>x : ({ kind1: "a"; a: 1; } & { kind2: "c"; c: 3; }) | ({ kind1: "a"; a: 1; } & { kind2: "d"; d: 4; }) | ({ kind1: "b"; b: 2; } & { kind2: "c"; c: 3; }) | ({ kind1: "b"; b: 2; } & { kind2: "d"; d: 4; })
>kind2 : "c" | "d"
>'c' : "c"

                x.c;
>x.c : 3
>x : ({ kind1: "a"; a: 1; } & { kind2: "c"; c: 3; }) | ({ kind1: "b"; b: 2; } & { kind2: "c"; c: 3; })
>c : 3
            }
        }
        if (x.kind1 === 'a') {
>x.kind1 === 'a' : boolean
>x.kind1 : "a" | "b"
>x : { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>kind1 : "a" | "b"
>'a' : "a"

            x.a;
>x.a : 1
>x : { kind1: "a"; a: 1; }
>a : 1
        }
        if (x.kind2 === 'c') {
>x.kind2 === 'c' : boolean
>x.kind2 : any
>x : { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>kind2 : any
>'c' : "c"

            x.c; // Error
>x.c : any
>x : { kind1: "a"; a: 1; } | { kind1: "b"; b: 2; }
>c : any
        }
    }
    if (x.kind1 === 'a') {
>x.kind1 === 'a' : boolean
>x.kind1 : any
>x : unknown
>kind1 : any
>'a' : "a"

        x.a;  // error
>x.a : any
>x : unknown
>a : any
    }
}

