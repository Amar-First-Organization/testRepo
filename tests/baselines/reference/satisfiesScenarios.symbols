=== tests/cases/compiler/satisfiesScenarios.ts ===
const x = [1, 2] satisfies [number, number];
>x : Symbol(x, Decl(satisfiesScenarios.ts, 0, 5))

interface A {
>A : Symbol(A, Decl(satisfiesScenarios.ts, 0, 44))

    a: string
>a : Symbol(A.a, Decl(satisfiesScenarios.ts, 2, 13))
}
let d = { a: 'test' } satisfies A;
>d : Symbol(d, Decl(satisfiesScenarios.ts, 5, 3))
>a : Symbol(a, Decl(satisfiesScenarios.ts, 5, 9))
>A : Symbol(A, Decl(satisfiesScenarios.ts, 0, 44))

let e = { a: 'test', b: 'test' } satisfies A;
>e : Symbol(e, Decl(satisfiesScenarios.ts, 6, 3))
>a : Symbol(a, Decl(satisfiesScenarios.ts, 6, 9))
>b : Symbol(b, Decl(satisfiesScenarios.ts, 6, 20))
>A : Symbol(A, Decl(satisfiesScenarios.ts, 0, 44))

// Most examples from #47920
namespace PropNameConstraining {
>PropNameConstraining : Symbol(PropNameConstraining, Decl(satisfiesScenarios.ts, 6, 45))

    type Keys = 'a' | 'b' | 'c' | 'd';
>Keys : Symbol(Keys, Decl(satisfiesScenarios.ts, 9, 32))

    const p = {
>p : Symbol(p, Decl(satisfiesScenarios.ts, 12, 9))

        a: 0,
>a : Symbol(a, Decl(satisfiesScenarios.ts, 12, 15))

        b: "hello",
>b : Symbol(b, Decl(satisfiesScenarios.ts, 13, 13))

        x: 8 // Should error, 'x' isn't in 'Keys'
>x : Symbol(x, Decl(satisfiesScenarios.ts, 14, 19))

    } satisfies Partial<Record<Keys, unknown>>;
>Partial : Symbol(Partial, Decl(lib.es5.d.ts, --, --))
>Record : Symbol(Record, Decl(lib.es5.d.ts, --, --))
>Keys : Symbol(Keys, Decl(satisfiesScenarios.ts, 9, 32))

    // Should be OK -- retain info that a is number and b is string
    let a = p.a.toFixed();
>a : Symbol(a, Decl(satisfiesScenarios.ts, 19, 7))
>p.a.toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))
>p.a : Symbol(a, Decl(satisfiesScenarios.ts, 12, 15))
>p : Symbol(p, Decl(satisfiesScenarios.ts, 12, 9))
>a : Symbol(a, Decl(satisfiesScenarios.ts, 12, 15))
>toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))

    let b = p.b.substring(1);
>b : Symbol(b, Decl(satisfiesScenarios.ts, 20, 7))
>p.b.substring : Symbol(String.substring, Decl(lib.es5.d.ts, --, --))
>p.b : Symbol(b, Decl(satisfiesScenarios.ts, 13, 13))
>p : Symbol(p, Decl(satisfiesScenarios.ts, 12, 9))
>b : Symbol(b, Decl(satisfiesScenarios.ts, 13, 13))
>substring : Symbol(String.substring, Decl(lib.es5.d.ts, --, --))

    // Should error even though 'd' is in 'Keys'
    let d = p.d;
>d : Symbol(d, Decl(satisfiesScenarios.ts, 22, 7))
>p : Symbol(p, Decl(satisfiesScenarios.ts, 12, 9))
}

namespace PropertyNameFulfillment {
>PropertyNameFulfillment : Symbol(PropertyNameFulfillment, Decl(satisfiesScenarios.ts, 23, 1))

    type Keys = 'a' | 'b' | 'c' | 'd';
>Keys : Symbol(Keys, Decl(satisfiesScenarios.ts, 25, 35))

    const p = {
>p : Symbol(p, Decl(satisfiesScenarios.ts, 28, 9))

        a: 0,
>a : Symbol(a, Decl(satisfiesScenarios.ts, 28, 15))

        b: "hello",
>b : Symbol(b, Decl(satisfiesScenarios.ts, 29, 13))

        x: 8 // Should error, 'x' isn't in 'Keys'
>x : Symbol(x, Decl(satisfiesScenarios.ts, 30, 19))

    } satisfies Record<Keys, unknown>;
>Record : Symbol(Record, Decl(lib.es5.d.ts, --, --))
>Keys : Symbol(Keys, Decl(satisfiesScenarios.ts, 25, 35))

    // Should be OK -- retain info that a is number and b is string
    let a = p.a.toFixed();
>a : Symbol(a, Decl(satisfiesScenarios.ts, 35, 7))
>p.a.toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))
>p.a : Symbol(a, Decl(satisfiesScenarios.ts, 28, 15))
>p : Symbol(p, Decl(satisfiesScenarios.ts, 28, 9))
>a : Symbol(a, Decl(satisfiesScenarios.ts, 28, 15))
>toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))

    let b = p.b.substr(1);
>b : Symbol(b, Decl(satisfiesScenarios.ts, 36, 7))
>p.b.substr : Symbol(String.substr, Decl(lib.es5.d.ts, --, --))
>p.b : Symbol(b, Decl(satisfiesScenarios.ts, 29, 13))
>p : Symbol(p, Decl(satisfiesScenarios.ts, 28, 9))
>b : Symbol(b, Decl(satisfiesScenarios.ts, 29, 13))
>substr : Symbol(String.substr, Decl(lib.es5.d.ts, --, --))

    // Should error even though 'd' is in 'Keys'
    let d = p.d;
>d : Symbol(d, Decl(satisfiesScenarios.ts, 38, 7))
>p : Symbol(p, Decl(satisfiesScenarios.ts, 28, 9))
}

namespace PropertyValueConformance {
>PropertyValueConformance : Symbol(PropertyValueConformance, Decl(satisfiesScenarios.ts, 39, 1))

    type Facts = { [key: string]: boolean };
>Facts : Symbol(Facts, Decl(satisfiesScenarios.ts, 41, 36))
>key : Symbol(key, Decl(satisfiesScenarios.ts, 42, 20))

    declare function checkTruths(x: Facts): void;
>checkTruths : Symbol(checkTruths, Decl(satisfiesScenarios.ts, 42, 44))
>x : Symbol(x, Decl(satisfiesScenarios.ts, 43, 33))
>Facts : Symbol(Facts, Decl(satisfiesScenarios.ts, 41, 36))

    declare function checkM(x: { m: boolean }): void;
>checkM : Symbol(checkM, Decl(satisfiesScenarios.ts, 43, 49))
>x : Symbol(x, Decl(satisfiesScenarios.ts, 44, 28))
>m : Symbol(m, Decl(satisfiesScenarios.ts, 44, 32))

    const x = {
>x : Symbol(x, Decl(satisfiesScenarios.ts, 45, 9))

        m: true
>m : Symbol(m, Decl(satisfiesScenarios.ts, 45, 15))

    };

    // Should be OK
    checkTruths(x);
>checkTruths : Symbol(checkTruths, Decl(satisfiesScenarios.ts, 42, 44))
>x : Symbol(x, Decl(satisfiesScenarios.ts, 45, 9))

    // Should be OK
    checkM(x);
>checkM : Symbol(checkM, Decl(satisfiesScenarios.ts, 43, 49))
>x : Symbol(x, Decl(satisfiesScenarios.ts, 45, 9))

    // Should fail under --noIndexSignaturePropertyAccess
    console.log(x.z);
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>x : Symbol(x, Decl(satisfiesScenarios.ts, 45, 9))

    // Should be OK under --noUncheckedIndexedAccess
    const m: boolean = x.m;
>m : Symbol(m, Decl(satisfiesScenarios.ts, 56, 9))
>x.m : Symbol(m, Decl(satisfiesScenarios.ts, 45, 15))
>x : Symbol(x, Decl(satisfiesScenarios.ts, 45, 9))
>m : Symbol(m, Decl(satisfiesScenarios.ts, 45, 15))

    // Should be 'm'
    type M = keyof typeof x;
>M : Symbol(M, Decl(satisfiesScenarios.ts, 56, 27))
>x : Symbol(x, Decl(satisfiesScenarios.ts, 45, 9))

    // Should be able to detect a failure here
    const x2 = {
>x2 : Symbol(x2, Decl(satisfiesScenarios.ts, 62, 9))

        m: true,
>m : Symbol(m, Decl(satisfiesScenarios.ts, 62, 16))

        s: "false"
>s : Symbol(s, Decl(satisfiesScenarios.ts, 63, 16))

    } satisfies Facts;
>Facts : Symbol(Facts, Decl(satisfiesScenarios.ts, 41, 36))
}

namespace PropertyValueConformance2 {
>PropertyValueConformance2 : Symbol(PropertyValueConformance2, Decl(satisfiesScenarios.ts, 66, 1))

    export type Color = { r: number, g: number, b: number };
>Color : Symbol(Color, Decl(satisfiesScenarios.ts, 68, 37))
>r : Symbol(r, Decl(satisfiesScenarios.ts, 69, 25))
>g : Symbol(g, Decl(satisfiesScenarios.ts, 69, 36))
>b : Symbol(b, Decl(satisfiesScenarios.ts, 69, 47))

    // All of these should be Colors, but I only use some of them here.
    export const Palette = {
>Palette : Symbol(Palette, Decl(satisfiesScenarios.ts, 72, 16))

        white: { r: 255, g: 255, b: 255 },
>white : Symbol(white, Decl(satisfiesScenarios.ts, 72, 28))
>r : Symbol(r, Decl(satisfiesScenarios.ts, 73, 16))
>g : Symbol(g, Decl(satisfiesScenarios.ts, 73, 24))
>b : Symbol(b, Decl(satisfiesScenarios.ts, 73, 32))

        black: { r: 0, g: 0, d: 0 }, // <- oops! 'd' in place of 'b'
>black : Symbol(black, Decl(satisfiesScenarios.ts, 73, 42))
>r : Symbol(r, Decl(satisfiesScenarios.ts, 74, 16))
>g : Symbol(g, Decl(satisfiesScenarios.ts, 74, 22))
>d : Symbol(d, Decl(satisfiesScenarios.ts, 74, 28))

        blue: { r: 0, g: 0, b: 255 },
>blue : Symbol(blue, Decl(satisfiesScenarios.ts, 74, 36))
>r : Symbol(r, Decl(satisfiesScenarios.ts, 75, 15))
>g : Symbol(g, Decl(satisfiesScenarios.ts, 75, 21))
>b : Symbol(b, Decl(satisfiesScenarios.ts, 75, 27))

    } satisfies Record<string, Color>;
>Record : Symbol(Record, Decl(lib.es5.d.ts, --, --))
>Color : Symbol(Color, Decl(satisfiesScenarios.ts, 68, 37))
}

namespace EnsureInterfaceImpl {
>EnsureInterfaceImpl : Symbol(EnsureInterfaceImpl, Decl(satisfiesScenarios.ts, 77, 1))

    type Movable = {
>Movable : Symbol(Movable, Decl(satisfiesScenarios.ts, 79, 31))

        move(distance: number): void;
>move : Symbol(move, Decl(satisfiesScenarios.ts, 80, 20))
>distance : Symbol(distance, Decl(satisfiesScenarios.ts, 81, 13))

    };

    const car = {
>car : Symbol(car, Decl(satisfiesScenarios.ts, 84, 9))

        start() { },
>start : Symbol(start, Decl(satisfiesScenarios.ts, 84, 17))

        move(d) {
>move : Symbol(move, Decl(satisfiesScenarios.ts, 85, 20))
>d : Symbol(d, Decl(satisfiesScenarios.ts, 86, 13))

            // d should be number
        },
        stop() { }
>stop : Symbol(stop, Decl(satisfiesScenarios.ts, 88, 10))

    } satisfies Movable & Record<string, unknown>;
>Movable : Symbol(Movable, Decl(satisfiesScenarios.ts, 79, 31))
>Record : Symbol(Record, Decl(lib.es5.d.ts, --, --))
}

namespace OptionalMemberConformance {
>OptionalMemberConformance : Symbol(OptionalMemberConformance, Decl(satisfiesScenarios.ts, 91, 1))

    type Point2d = { x: number, y: number };
>Point2d : Symbol(Point2d, Decl(satisfiesScenarios.ts, 93, 37))
>x : Symbol(x, Decl(satisfiesScenarios.ts, 94, 20))
>y : Symbol(y, Decl(satisfiesScenarios.ts, 94, 31))

    // Undesirable behavior today with type annotation
    const a = { x: 10 } satisfies Partial<Point2d>;
>a : Symbol(a, Decl(satisfiesScenarios.ts, 96, 9))
>x : Symbol(x, Decl(satisfiesScenarios.ts, 96, 15))
>Partial : Symbol(Partial, Decl(lib.es5.d.ts, --, --))
>Point2d : Symbol(Point2d, Decl(satisfiesScenarios.ts, 93, 37))

    // Should OK
    console.log(a.x.toFixed());
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>a.x.toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))
>a.x : Symbol(x, Decl(satisfiesScenarios.ts, 96, 15))
>a : Symbol(a, Decl(satisfiesScenarios.ts, 96, 9))
>x : Symbol(x, Decl(satisfiesScenarios.ts, 96, 15))
>toFixed : Symbol(Number.toFixed, Decl(lib.es5.d.ts, --, --))

    // Should error
    let p = a.y;    
>p : Symbol(p, Decl(satisfiesScenarios.ts, 100, 7))
>a : Symbol(a, Decl(satisfiesScenarios.ts, 96, 9))
}

namespace ContextualTyping {
>ContextualTyping : Symbol(ContextualTyping, Decl(satisfiesScenarios.ts, 101, 1))

    type Predicates = { [s: string]: (n: number) => boolean };
>Predicates : Symbol(Predicates, Decl(satisfiesScenarios.ts, 103, 28))
>s : Symbol(s, Decl(satisfiesScenarios.ts, 104, 25))
>n : Symbol(n, Decl(satisfiesScenarios.ts, 104, 38))

    const p: Predicates = {
>p : Symbol(p, Decl(satisfiesScenarios.ts, 106, 9))
>Predicates : Symbol(Predicates, Decl(satisfiesScenarios.ts, 103, 28))

        isEven: n => n % 2 === 0,
>isEven : Symbol(isEven, Decl(satisfiesScenarios.ts, 106, 27))
>n : Symbol(n, Decl(satisfiesScenarios.ts, 107, 15))
>n : Symbol(n, Decl(satisfiesScenarios.ts, 107, 15))

        isOdd: n => n % 2 === 1
>isOdd : Symbol(isOdd, Decl(satisfiesScenarios.ts, 107, 33))
>n : Symbol(n, Decl(satisfiesScenarios.ts, 108, 14))
>n : Symbol(n, Decl(satisfiesScenarios.ts, 108, 14))

    };
}
