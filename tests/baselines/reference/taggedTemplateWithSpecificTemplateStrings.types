//// [tests/cases/conformance/es6/templates/taggedTemplateWithSpecificTemplateStrings.ts] ////

=== taggedTemplateWithSpecificTemplateStrings.ts ===
// overload resolution
declare function f1(array: TemplateStringsArrayOf<readonly ["a", ...string[]]>, ...args: any): "A";
>f1 : { (array: TemplateStringsArrayOf<readonly ["a", ...string[]]>, ...args: any): "A"; (array: TemplateStringsArrayOf<readonly ["b", ...string[]], readonly ["b", ...string[]]>, ...args: any): "B"; (array: TemplateStringsArray, ...args: any): "C"; }
>array : TemplateStringsArrayOf<readonly ["a", ...string[]], readonly ["a", ...string[]]>
>args : any

declare function f1(array: TemplateStringsArrayOf<readonly ["b", ...string[]]>, ...args: any): "B";
>f1 : { (array: TemplateStringsArrayOf<readonly ["a", ...string[]], readonly ["a", ...string[]]>, ...args: any): "A"; (array: TemplateStringsArrayOf<readonly ["b", ...string[]]>, ...args: any): "B"; (array: TemplateStringsArray, ...args: any): "C"; }
>array : TemplateStringsArrayOf<readonly ["b", ...string[]], readonly ["b", ...string[]]>
>args : any

declare function f1(array: TemplateStringsArray, ...args: any): "C";
>f1 : { (array: TemplateStringsArrayOf<readonly ["a", ...string[]], readonly ["a", ...string[]]>, ...args: any): "A"; (array: TemplateStringsArrayOf<readonly ["b", ...string[]], readonly ["b", ...string[]]>, ...args: any): "B"; (array: TemplateStringsArray, ...args: any): "C"; }
>array : TemplateStringsArray
>args : any

const f1_r0 = f1`a`;        // "A"
>f1_r0 : "A"
>f1`a` : "A"
>f1 : { (array: TemplateStringsArrayOf<readonly ["a", ...string[]], readonly ["a", ...string[]]>, ...args: any): "A"; (array: TemplateStringsArrayOf<readonly ["b", ...string[]], readonly ["b", ...string[]]>, ...args: any): "B"; (array: TemplateStringsArray, ...args: any): "C"; }
>`a` : "a"

const f1_r1 = f1`a${"b"}`;  // "A"
>f1_r1 : "A"
>f1`a${"b"}` : "A"
>f1 : { (array: TemplateStringsArrayOf<readonly ["a", ...string[]], readonly ["a", ...string[]]>, ...args: any): "A"; (array: TemplateStringsArrayOf<readonly ["b", ...string[]], readonly ["b", ...string[]]>, ...args: any): "B"; (array: TemplateStringsArray, ...args: any): "C"; }
>`a${"b"}` : string
>"b" : "b"

const f1_r2 = f1`b`;        // "B"
>f1_r2 : "B"
>f1`b` : "B"
>f1 : { (array: TemplateStringsArrayOf<readonly ["a", ...string[]], readonly ["a", ...string[]]>, ...args: any): "A"; (array: TemplateStringsArrayOf<readonly ["b", ...string[]], readonly ["b", ...string[]]>, ...args: any): "B"; (array: TemplateStringsArray, ...args: any): "C"; }
>`b` : "b"

const f1_r3 = f1`b${"b"}`;  // "B"
>f1_r3 : "B"
>f1`b${"b"}` : "B"
>f1 : { (array: TemplateStringsArrayOf<readonly ["a", ...string[]], readonly ["a", ...string[]]>, ...args: any): "A"; (array: TemplateStringsArrayOf<readonly ["b", ...string[]], readonly ["b", ...string[]]>, ...args: any): "B"; (array: TemplateStringsArray, ...args: any): "C"; }
>`b${"b"}` : string
>"b" : "b"

const f1_r4 = f1`c`;        // "C"
>f1_r4 : "C"
>f1`c` : "C"
>f1 : { (array: TemplateStringsArrayOf<readonly ["a", ...string[]], readonly ["a", ...string[]]>, ...args: any): "A"; (array: TemplateStringsArrayOf<readonly ["b", ...string[]], readonly ["b", ...string[]]>, ...args: any): "B"; (array: TemplateStringsArray, ...args: any): "C"; }
>`c` : "c"

const f1_r5 = f1`c${"b"}`;  // "C"
>f1_r5 : "C"
>f1`c${"b"}` : "C"
>f1 : { (array: TemplateStringsArrayOf<readonly ["a", ...string[]], readonly ["a", ...string[]]>, ...args: any): "A"; (array: TemplateStringsArrayOf<readonly ["b", ...string[]], readonly ["b", ...string[]]>, ...args: any): "B"; (array: TemplateStringsArray, ...args: any): "C"; }
>`c${"b"}` : string
>"b" : "b"

// constrained type parameter
declare function f0<T extends TemplateStringsArray, A extends string[]>(array: T, ...args: A): [T, A];
>f0 : <T extends TemplateStringsArray, A extends string[]>(array: T, ...args: A) => [T, A]
>array : T
>args : A

const f0_r0 = f0`a${"b"}c`; // [TemplateStringsArrayOf<readonly ["a", "c"], readonly ["a", "c"]>, ["b"]]
>f0_r0 : [TemplateStringsArrayOf<readonly ["a", "c"], readonly ["a", "c"]>, ["b"]]
>f0`a${"b"}c` : [TemplateStringsArrayOf<readonly ["a", "c"], readonly ["a", "c"]>, ["b"]]
>f0 : <T extends TemplateStringsArray, A extends string[]>(array: T, ...args: A) => [T, A]
>`a${"b"}c` : string
>"b" : "b"

// interpolation example
type TemplatePrimitive = string | number | bigint | boolean | null | undefined;
>TemplatePrimitive : string | number | bigint | boolean | null | undefined

type Interpolate<T extends readonly string[], A extends any[], R extends string = ''> =
>Interpolate : Interpolate<T, A, R>

    T extends readonly [infer TH extends string, ...infer TT extends readonly string[]] ?
        A extends [infer AH extends TemplatePrimitive, ...infer AT extends TemplatePrimitive[]] ?
            Interpolate<TT, AT, `${R}${TH}${AH}`> :
            Interpolate<TT, [], `${R}${TH}`> :
        R;

// string interpolation
declare function interp<T extends TemplateStringsArray, A extends TemplatePrimitive[]>(array: T, ...args: A): Interpolate<T, A>;
>interp : <T extends TemplateStringsArray, A extends TemplatePrimitive[]>(array: T, ...args: A) => Interpolate<T, A>
>array : T
>args : A

const interp_r0 = interp`a${"b"}c`;    // "abc"
>interp_r0 : "abc"
>interp`a${"b"}c` : "abc"
>interp : <T extends TemplateStringsArray, A extends TemplatePrimitive[]>(array: T, ...args: A) => Interpolate<T, A, "">
>`a${"b"}c` : string
>"b" : "b"

const interp_r1 = interp`a${1}c`;      // "a1c"
>interp_r1 : "a1c"
>interp`a${1}c` : "a1c"
>interp : <T extends TemplateStringsArray, A extends TemplatePrimitive[]>(array: T, ...args: A) => Interpolate<T, A, "">
>`a${1}c` : string
>1 : 1

// "a\nb\nc"
const interp_r2 = interp`a\n${"b"}
>interp_r2 : "a\nb\nc"
>interp`a\n${"b"}c` : "a\nb\nc"
>interp : <T extends TemplateStringsArray, A extends TemplatePrimitive[]>(array: T, ...args: A) => Interpolate<T, A, "">
>`a\n${"b"}c` : string
>"b" : "b"

c`; 

// raw string interpolation (i.e., 'String.raw')
declare function raw<T extends TemplateStringsArray, A extends TemplatePrimitive[]>(array: T, ...args: A): Interpolate<T["raw"], A>;
>raw : <T extends TemplateStringsArray, A extends TemplatePrimitive[]>(array: T, ...args: A) => Interpolate<T["raw"], A>
>array : T
>args : A

const raw_r0 = raw`a${"b"}c`;          // "abc"
>raw_r0 : "abc"
>raw`a${"b"}c` : "abc"
>raw : <T extends TemplateStringsArray, A extends TemplatePrimitive[]>(array: T, ...args: A) => Interpolate<T["raw"], A, "">
>`a${"b"}c` : string
>"b" : "b"

const raw_r1 = raw`a${1}c`;            // "a1c"
>raw_r1 : "a1c"
>raw`a${1}c` : "a1c"
>raw : <T extends TemplateStringsArray, A extends TemplatePrimitive[]>(array: T, ...args: A) => Interpolate<T["raw"], A, "">
>`a${1}c` : string
>1 : 1

// "a\\nb\nc"
const raw_r2 = raw`a\n${"b"}
>raw_r2 : "a\\nb\nc"
>raw`a\n${"b"}c` : "a\\nb\nc"
>raw : <T extends TemplateStringsArray, A extends TemplatePrimitive[]>(array: T, ...args: A) => Interpolate<T["raw"], A, "">
>`a\n${"b"}c` : string
>"b" : "b"

c`;

// Jest's `it.each`:
type Whitespace = " " | "\t" | "\v"
>Whitespace : " " | "\t" | "\v"

type Trim<S extends string, Chars extends string = Whitespace | "\n"> =
>Trim : Trim<S, Chars>

    S extends `${Chars}${infer R}` ? Trim<R, Chars> :
    S extends `${infer R}${Chars}` ? Trim<R, Chars> :
    S;

type Split<S extends string, D extends string> =
>Split : Split<S, D>

    S extends D ? [] :
    S extends `${infer H}${D}${infer T}` ? [H, ...Split<T, D>] :
    [S];

type ParseRows<A extends any[], S extends readonly string[], Row extends any[] = [], Rows extends any[][] = []> =
>ParseRows : ParseRows<A, S, Row, Rows>

    [A, S] extends [[infer AH, ...infer AT], readonly [infer TH extends string, ...infer TT extends string[]]] ?
        Trim<TH, Whitespace> extends "|" ? ParseRows<AT, TT, [...Row, AH], Rows> :
        Trim<TH, Whitespace> extends "\n" | "" ? ParseRows<AT, TT, [], [...Rows, [...Row, AH]]> :
        never :
    [A, S] extends [[], readonly []] ? Rows :
    never;

type JestEachArgument<Headers extends string[], Rows extends any[][]> = {
>JestEachArgument : JestEachArgument<Headers, Rows>

    [P1 in keyof Rows]: {
        [P2 in keyof Headers as P2 extends `${number}` ? Trim<Headers[P2]> : never]:
            P2 extends keyof Rows[P1] ? Rows[P1][P2] : undefined;
    };
}[number];

type JestEachFunction<Arg> = (name: string, cb: (arg: Arg) => void, timeout?: number) => void;
>JestEachFunction : JestEachFunction<Arg>
>name : string
>cb : (arg: Arg) => void
>arg : Arg
>timeout : number | undefined

type JestEach<T extends readonly string[], A extends any[]> =
>JestEach : JestEach<T, A>

    T extends readonly [infer TH extends string, ...infer TT extends readonly string[]] ?
        JestEachFunction<JestEachArgument<Split<Trim<TH>, "|">, ParseRows<A, TT>>> :
        null;

declare function each<T extends readonly string[], A extends unknown[]>(strs: T, ...args: A): JestEach<T, A>;
>each : <T extends readonly string[], A extends unknown[]>(strs: T, ...args: A) => JestEach<T, A>
>strs : T
>args : A

each`
>each`    foo    | bar    ${"a"} | ${1}    ${"c"} | ${undefined}`("test", ({ foo, bar }) => {    foo;    bar;}) : void
>each`    foo    | bar    ${"a"} | ${1}    ${"c"} | ${undefined}` : JestEachFunction<{ foo: string; bar: number; } | { foo: string; bar: undefined; }>
>each : <T extends readonly string[], A extends unknown[]>(strs: T, ...args: A) => JestEach<T, A>
>`    foo    | bar    ${"a"} | ${1}    ${"c"} | ${undefined}` : string

    foo    | bar
    ${"a"} | ${1}
>"a" : "a"
>1 : 1

    ${"c"} | ${undefined}
>"c" : "c"
>undefined : undefined

`("test", ({ foo, bar }) => {
>"test" : "test"
>({ foo, bar }) => {    foo;    bar;} : ({ foo, bar }: { foo: string; bar: number; } | { foo: string; bar: undefined; }) => void
>foo : string
>bar : number | undefined

    foo;
>foo : string

    bar;
>bar : number | undefined

});

