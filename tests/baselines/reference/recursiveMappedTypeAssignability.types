=== tests/cases/compiler/recursiveMappedTypeAssignability.ts ===
type D<U> = { [P in keyof U]: D<U[P]> };
>D : D<U>
>U : U
>P : P
>U : U
>D : D<U>
>U : U
>P : P

<T>(t: T, dt: D<T>) => { dt = t };
><T>(t: T, dt: D<T>) => { dt = t } : <T>(t: T, dt: D<T>) => void
>T : T
>t : T
>T : T
>dt : D<T>
>D : D<U>
>T : T
>dt = t : T
>dt : D<T>
>t : T

type DR<U> = { readonly [P in keyof U]: DR<U[P]> };
>DR : DR<U>
>U : U
>P : P
>U : U
>DR : DR<U>
>U : U
>P : P

<T>(t: T, dt: DR<T>) => { dt = t };
><T>(t: T, dt: DR<T>) => { dt = t } : <T>(t: T, dt: DR<T>) => void
>T : T
>t : T
>T : T
>dt : DR<T>
>DR : DR<U>
>T : T
>dt = t : T
>dt : DR<T>
>t : T

type DP<U> = { [P in keyof U]?: DP<U[P]> };
>DP : DP<U>
>U : U
>P : P
>U : U
>DP : DP<U>
>U : U
>P : P

<T>(t: T, dt: DP<T>) => { dt = t };
><T>(t: T, dt: DP<T>) => { dt = t } : <T>(t: T, dt: DP<T>) => void
>T : T
>t : T
>T : T
>dt : DP<T>
>DP : DP<U>
>T : T
>dt = t : T
>dt : DP<T>
>t : T

type DAP<U> = { [P in keyof U]?: DAP<U[P]> & U[P] };
>DAP : DAP<U>
>U : U
>P : P
>U : U
>DAP : DAP<U>
>U : U
>P : P
>U : U
>P : P

<T>(t: T, dt: DAP<T>) => { dt = t };
><T>(t: T, dt: DAP<T>) => { dt = t } : <T>(t: T, dt: DAP<T>) => void
>T : T
>t : T
>T : T
>dt : DAP<T>
>DAP : DAP<U>
>T : T
>dt = t : T
>dt : DAP<T>
>t : T

// #21592
// doesn't work because aliasSymbol isn't set on the literal type
// since it's not top-level -- the union is.
type SafeAny<T> = {
>SafeAny : SafeAny<T>
>T : T

    [K in keyof T]?: SafeAny<T[K]>
>K : K
>T : T
>SafeAny : SafeAny<T>
>T : T
>K : K

} | boolean | number | string | symbol | null | undefined
>null : null

type DataValidator<T> = {
>DataValidator : DataValidator<T>
>T : T

    [K in keyof T]?: (v: SafeAny<T[K]>) => v is T[K]
>K : K
>T : T
>v : SafeAny<T[K]>
>SafeAny : SafeAny<T>
>T : T
>K : K
>v : any
>T : T
>K : K
}

// modified repro with top-level mapped type, which works
// because the literal type has aliasSymbol set
type SafeAnyMap<T> = {
>SafeAnyMap : SafeAnyMap<T>
>T : T

    [K in keyof T]?: SafeAny2<T[K]>
>K : K
>T : T
>SafeAny2 : SafeAny2<T>
>T : T
>K : K
}
type SafeAny2<T> = SafeAnyMap<T> | boolean | number | string | symbol | null | undefined
>SafeAny2 : SafeAny2<T>
>T : T
>SafeAnyMap : SafeAnyMap<T>
>T : T
>null : null

<T>(t: T, sat: SafeAny2<T>) => { sat = t }
><T>(t: T, sat: SafeAny2<T>) => { sat = t } : <T>(t: T, sat: SafeAny2<T>) => void
>T : T
>t : T
>T : T
>sat : SafeAny2<T>
>SafeAny2 : SafeAny2<T>
>T : T
>sat = t : T
>sat : SafeAny2<T>
>t : T


const fn = <T>(arg: T) => {
>fn : <T>(arg: T) => void
><T>(arg: T) => {    ((arg2: RecursivePartial<T>) => {        // ...    })(arg);} : <T>(arg: T) => void
>T : T
>arg : T
>T : T

    ((arg2: RecursivePartial<T>) => {
>((arg2: RecursivePartial<T>) => {        // ...    })(arg) : void
>((arg2: RecursivePartial<T>) => {        // ...    }) : (arg2: RecursivePartial<T>) => void
>(arg2: RecursivePartial<T>) => {        // ...    } : (arg2: RecursivePartial<T>) => void
>arg2 : RecursivePartial<T>
>RecursivePartial : RecursivePartial<T>
>T : T

        // ...
    })(arg);
>arg : T

};

type RecursivePartial<T> = {
>RecursivePartial : RecursivePartial<T>
>T : T

    [P in keyof T]?: RecursivePartial<T[P]>;
>P : P
>T : T
>RecursivePartial : RecursivePartial<T>
>T : T
>P : P

};

