=== tests/cases/conformance/types/difference/objectRest.ts ===

let o = { a: 1, b: 'no' }
>o : { a: number; b: string; }
>{ a: 1, b: 'no' } : { a: number; b: string; }
>a : number
>1 : 1
>b : string
>'no' : "no"

var { ...clone } = o;
>clone : { a: number; b: string; }
>o : { a: number; b: string; }

var { a, ...justB } = o;
>a : number
>justB : { b: string; }
>o : { a: number; b: string; }

var { a, b: renamed, ...empty } = o;
>a : number
>b : any
>renamed : string
>empty : {}
>o : { a: number; b: string; }

var { ['b']: renamed, ...justA } = o;
>'b' : "b"
>renamed : string
>justA : { a: number; }
>o : { a: number; b: string; }

var { 'b': renamed, ...justA } = o;
>renamed : string
>justA : { a: number; }
>o : { a: number; b: string; }

var { b: { '0': n, '1': oooo }, ...justA } = o;
>b : any
>n : string
>oooo : string
>justA : { a: number; }
>o : { a: number; b: string; }

let o2 = { c: 'terrible idea?', d: 'yes' };
>o2 : { c: string; d: string; }
>{ c: 'terrible idea?', d: 'yes' } : { c: string; d: string; }
>c : string
>'terrible idea?' : "terrible idea?"
>d : string
>'yes' : "yes"

var { d: renamed, ...d } = o2;
>d : any
>renamed : string
>d : { c: string; }
>o2 : { c: string; d: string; }

function cloneAgain({ a, ...clone }: { a: number, b: string }): void {
>cloneAgain : ({a, ...clone}: { a: number; b: string; }) => void
>a : number
>clone : { b: string; }
>a : number
>b : string
}
let array: { x: number, y: string }[];
>array : { x: number; y: string; }[]
>x : number
>y : string

for (let { x, ...restOf } of array) {
>x : number
>restOf : { y: string; }
>array : { x: number; y: string; }[]

    [x, restOf];
>[x, restOf] : (number | { y: string; })[]
>x : number
>restOf : { y: string; }
}
let xx: number;
>xx : number

let rrestOff: { y: string };
>rrestOff : { y: string; }
>y : string

for ({ x: xx, ...rrestOff } of array ) {
>{ x: xx, ...rrestOff } : { y: string; x: number; }
>x : { x: number; y: string; }
>xx : number
>rrestOff : any
>array : { x: number; y: string; }[]

    [xx, rrestOff];
>[xx, rrestOff] : (number | { y: string; })[]
>xx : number
>rrestOff : { y: string; }
}
for (const norest of array.map(a => ({ ...a }))) {
>norest : { x: number; y: string; }
>array.map(a => ({ ...a })) : { x: number; y: string; }[]
>array.map : { <U>(this: [{ x: number; y: string; }, { x: number; y: string; }, { x: number; y: string; }, { x: number; y: string; }, { x: number; y: string; }], callbackfn: (value: { x: number; y: string; }, index: number, array: { x: number; y: string; }[]) => U, thisArg?: any): [U, U, U, U, U]; <U>(this: [{ x: number; y: string; }, { x: number; y: string; }, { x: number; y: string; }, { x: number; y: string; }], callbackfn: (value: { x: number; y: string; }, index: number, array: { x: number; y: string; }[]) => U, thisArg?: any): [U, U, U, U]; <U>(this: [{ x: number; y: string; }, { x: number; y: string; }, { x: number; y: string; }], callbackfn: (value: { x: number; y: string; }, index: number, array: { x: number; y: string; }[]) => U, thisArg?: any): [U, U, U]; <U>(this: [{ x: number; y: string; }, { x: number; y: string; }], callbackfn: (value: { x: number; y: string; }, index: number, array: { x: number; y: string; }[]) => U, thisArg?: any): [U, U]; <U>(callbackfn: (value: { x: number; y: string; }, index: number, array: { x: number; y: string; }[]) => U, thisArg?: any): U[]; }
>array : { x: number; y: string; }[]
>map : { <U>(this: [{ x: number; y: string; }, { x: number; y: string; }, { x: number; y: string; }, { x: number; y: string; }, { x: number; y: string; }], callbackfn: (value: { x: number; y: string; }, index: number, array: { x: number; y: string; }[]) => U, thisArg?: any): [U, U, U, U, U]; <U>(this: [{ x: number; y: string; }, { x: number; y: string; }, { x: number; y: string; }, { x: number; y: string; }], callbackfn: (value: { x: number; y: string; }, index: number, array: { x: number; y: string; }[]) => U, thisArg?: any): [U, U, U, U]; <U>(this: [{ x: number; y: string; }, { x: number; y: string; }, { x: number; y: string; }], callbackfn: (value: { x: number; y: string; }, index: number, array: { x: number; y: string; }[]) => U, thisArg?: any): [U, U, U]; <U>(this: [{ x: number; y: string; }, { x: number; y: string; }], callbackfn: (value: { x: number; y: string; }, index: number, array: { x: number; y: string; }[]) => U, thisArg?: any): [U, U]; <U>(callbackfn: (value: { x: number; y: string; }, index: number, array: { x: number; y: string; }[]) => U, thisArg?: any): U[]; }
>a => ({ ...a }) : (a: { x: number; y: string; }) => { x: number; y: string; }
>a : { x: number; y: string; }
>({ ...a }) : { x: number; y: string; }
>{ ...a } : { x: number; y: string; }
>a : any

    [norest.x, norest.y];
>[norest.x, norest.y] : (string | number)[]
>norest.x : number
>norest : { x: number; y: string; }
>x : number
>norest.y : string
>norest : { x: number; y: string; }
>y : string

    // x is now a string. who knows why.
}

