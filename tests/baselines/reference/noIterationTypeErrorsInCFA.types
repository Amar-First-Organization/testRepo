=== tests/cases/compiler/noIterationTypeErrorsInCFA.ts ===
interface F {
    d(): void
>d : () => void
}
export function doRemove(dds: F | F[]) {
>doRemove : (dds: F | F[]) => F[]
>dds : F | F[]

    if (!Array.isArray(dds)) {
>!Array.isArray(dds) : boolean
>Array.isArray(dds) : boolean
>Array.isArray : { <T>(arg: T): arg is T extends any ? (true extends false & T ? Extract<any[], T> : T extends string | readonly any[] ? never : T extends ArrayLike<infer U> ? Extract<U[], T> : never) | (true extends false & T ? never : {} extends Required<T> ? T & any[] : Extract<T, readonly any[]>) : never; <T>(arg: T): arg is T extends any ? (true extends false & T ? Extract<any[], T> : T extends string | readonly any[] ? never : T extends ArrayLike<infer U> | Iterable<infer U> ? Extract<U[], T> : never) | (true extends false & T ? never : {} extends Required<T> ? T & any[] : Extract<T, readonly any[]>) : never; }
>Array : ArrayConstructor
>isArray : { <T>(arg: T): arg is T extends any ? (true extends false & T ? Extract<any[], T> : T extends string | readonly any[] ? never : T extends ArrayLike<infer U> ? Extract<U[], T> : never) | (true extends false & T ? never : {} extends Required<T> ? T & any[] : Extract<T, readonly any[]>) : never; <T>(arg: T): arg is T extends any ? (true extends false & T ? Extract<any[], T> : T extends string | readonly any[] ? never : T extends ArrayLike<infer U> | Iterable<infer U> ? Extract<U[], T> : never) | (true extends false & T ? never : {} extends Required<T> ? T & any[] : Extract<T, readonly any[]>) : never; }
>dds : F | F[]

        dds = [dds]
>dds = [dds] : F[]
>dds : F | F[]
>[dds] : F[]
>dds : F
    }
    for (let n of dds) {
>n : F
>dds : F[]

        n.d()
>n.d() : void
>n.d : () => void
>n : F
>d : () => void
    }
    return dds
>dds : F[]
}

