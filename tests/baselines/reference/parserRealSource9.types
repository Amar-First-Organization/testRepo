=== tests/cases/conformance/parser/ecmascript5/parserRealSource9.ts ===
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='typescript.ts' />

module TypeScript {
>TypeScript : typeof TypeScript

    export class Binder {
>Binder : Binder

        constructor (public checker: TypeChecker) { }
>checker : any (error)

        public resolveBaseTypeLinks(typeLinks: TypeLink[], scope: SymbolScope) {
>resolveBaseTypeLinks : (typeLinks: any (error)[], scope: any (error)) => any (error)[]
>typeLinks : any (error)[]
>scope : any (error)

            var extendsList: Type[] = null;
>extendsList : any (error)[]
>null : null

            if (typeLinks) {
>typeLinks : any (error)[]

                extendsList = new Type[];
>extendsList = new Type[] : any (error)
>extendsList : any (error)[]
>new Type[] : any (error)
>Type[] : any (error)
>Type : any (error)
> : any (error)

                for (var i = 0, len = typeLinks.length; i < len; i++) {
>i : number
>0 : 0
>len : number
>typeLinks.length : number
>typeLinks : any (error)[]
>length : number
>i < len : boolean
>i : number
>len : number
>i++ : number
>i : number

                    var typeLink = typeLinks[i];
>typeLink : any (error)
>typeLinks[i] : any (error)
>typeLinks : any (error)[]
>i : number

                    this.checker.resolvingBases = true;
>this.checker.resolvingBases = true : true
>this.checker.resolvingBases : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>resolvingBases : any (error)
>true : true

                    this.checker.resolveTypeLink(scope, typeLink, true);
>this.checker.resolveTypeLink(scope, typeLink, true) : any (error)
>this.checker.resolveTypeLink : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>resolveTypeLink : any (error)
>scope : any (error)
>typeLink : any (error)
>true : true

                    this.checker.resolvingBases = false;
>this.checker.resolvingBases = false : false
>this.checker.resolvingBases : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>resolvingBases : any (error)
>false : false

                    if (typeLink.type.isClass()) {
>typeLink.type.isClass() : any (error)
>typeLink.type.isClass : any (error)
>typeLink.type : any (error)
>typeLink : any (error)
>type : any (error)
>isClass : any (error)

                        extendsList[i] = typeLink.type.instanceType;
>extendsList[i] = typeLink.type.instanceType : any (error)
>extendsList[i] : any (error)
>extendsList : any (error)[]
>i : number
>typeLink.type.instanceType : any (error)
>typeLink.type : any (error)
>typeLink : any (error)
>type : any (error)
>instanceType : any (error)
                    }
                    else {
                        extendsList[i] = typeLink.type;
>extendsList[i] = typeLink.type : any (error)
>extendsList[i] : any (error)
>extendsList : any (error)[]
>i : number
>typeLink.type : any (error)
>typeLink : any (error)
>type : any (error)
                    }
                }
            }
            return extendsList;
>extendsList : any (error)[]
        }

        public resolveBases(scope: SymbolScope, type: Type) {
>resolveBases : (scope: any (error), type: any (error)) => void
>scope : any (error)
>type : any (error)

            type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope);
>type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope) : any (error)[]
>type.extendsList : any (error)
>type : any (error)
>extendsList : any (error)
>this.resolveBaseTypeLinks(type.extendsTypeLinks, scope) : any (error)[]
>this.resolveBaseTypeLinks : (typeLinks: any (error)[], scope: any (error)) => any (error)[]
>this : this
>resolveBaseTypeLinks : (typeLinks: any (error)[], scope: any (error)) => any (error)[]
>type.extendsTypeLinks : any (error)
>type : any (error)
>extendsTypeLinks : any (error)
>scope : any (error)

            var i = 0, len = type.extendsList.length;
>i : number
>0 : 0
>len : any (error)
>type.extendsList.length : any (error)
>type.extendsList : any (error)
>type : any (error)
>extendsList : any (error)
>length : any (error)

            var derivedIsClass = type.isClassInstance();
>derivedIsClass : any (error)
>type.isClassInstance() : any (error)
>type.isClassInstance : any (error)
>type : any (error)
>isClassInstance : any (error)

            for (; i < len; i++) {
>i < len : boolean
>i : number
>len : any (error)
>i++ : number
>i : number

                var baseIsClass = type.extendsList[i].isClassInstance();
>baseIsClass : any (error)
>type.extendsList[i].isClassInstance() : any (error)
>type.extendsList[i].isClassInstance : any (error)
>type.extendsList[i] : any (error)
>type.extendsList : any (error)
>type : any (error)
>extendsList : any (error)
>i : number
>isClassInstance : any (error)

                if (type.extendsList[i] != this.checker.anyType) {
>type.extendsList[i] != this.checker.anyType : boolean
>type.extendsList[i] : any (error)
>type.extendsList : any (error)
>type : any (error)
>extendsList : any (error)
>i : number
>this.checker.anyType : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>anyType : any (error)

                    if (derivedIsClass) {
>derivedIsClass : any (error)

                        if (!baseIsClass) {
>!baseIsClass : boolean
>baseIsClass : any (error)

                            this.checker.errorReporter.simpleErrorFromSym(type.symbol,
>this.checker.errorReporter.simpleErrorFromSym(type.symbol,                                                                     "A export class may only extend other classes, " + type.extendsList[i].symbol.fullName() + " is an interface.") : any (error)
>this.checker.errorReporter.simpleErrorFromSym : any (error)
>this.checker.errorReporter : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>errorReporter : any (error)
>simpleErrorFromSym : any (error)
>type.symbol : any (error)
>type : any (error)
>symbol : any (error)

                                                                     "A export class may only extend other classes, " + type.extendsList[i].symbol.fullName() + " is an interface.");
>"A export class may only extend other classes, " + type.extendsList[i].symbol.fullName() + " is an interface." : string
>"A export class may only extend other classes, " + type.extendsList[i].symbol.fullName() : string
>"A export class may only extend other classes, " : "A export class may only extend other classes, "
>type.extendsList[i].symbol.fullName() : any (error)
>type.extendsList[i].symbol.fullName : any (error)
>type.extendsList[i].symbol : any (error)
>type.extendsList[i] : any (error)
>type.extendsList : any (error)
>type : any (error)
>extendsList : any (error)
>i : number
>symbol : any (error)
>fullName : any (error)
>" is an interface." : " is an interface."
                        }
                    }
                    else {
                        if (baseIsClass) {
>baseIsClass : any (error)

                            this.checker.errorReporter.simpleErrorFromSym(type.symbol,
>this.checker.errorReporter.simpleErrorFromSym(type.symbol,                                                                     "An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName() + " is a class.") : any (error)
>this.checker.errorReporter.simpleErrorFromSym : any (error)
>this.checker.errorReporter : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>errorReporter : any (error)
>simpleErrorFromSym : any (error)
>type.symbol : any (error)
>type : any (error)
>symbol : any (error)

                                                                     "An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName() + " is a class.");
>"An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName() + " is a class." : string
>"An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName() : string
>"An interface may only extend other interfaces, " : "An interface may only extend other interfaces, "
>type.extendsList[i].symbol.fullName() : any (error)
>type.extendsList[i].symbol.fullName : any (error)
>type.extendsList[i].symbol : any (error)
>type.extendsList[i] : any (error)
>type.extendsList : any (error)
>type : any (error)
>extendsList : any (error)
>i : number
>symbol : any (error)
>fullName : any (error)
>" is a class." : " is a class."
                        }
                    }
                }
            }

            type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope);
>type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope) : any (error)[]
>type.implementsList : any (error)
>type : any (error)
>implementsList : any (error)
>this.resolveBaseTypeLinks(type.implementsTypeLinks, scope) : any (error)[]
>this.resolveBaseTypeLinks : (typeLinks: any (error)[], scope: any (error)) => any (error)[]
>this : this
>resolveBaseTypeLinks : (typeLinks: any (error)[], scope: any (error)) => any (error)[]
>type.implementsTypeLinks : any (error)
>type : any (error)
>implementsTypeLinks : any (error)
>scope : any (error)

            if (type.implementsList) {
>type.implementsList : any (error)
>type : any (error)
>implementsList : any (error)

                for (i = 0, len = type.implementsList.length; i < len; i++) {
>i = 0, len = type.implementsList.length : any (error)
>i = 0 : 0
>i : number
>0 : 0
>len = type.implementsList.length : any (error)
>len : any (error)
>type.implementsList.length : any (error)
>type.implementsList : any (error)
>type : any (error)
>implementsList : any (error)
>length : any (error)
>i < len : boolean
>i : number
>len : any (error)
>i++ : number
>i : number

                    var iface = type.implementsList[i];
>iface : any (error)
>type.implementsList[i] : any (error)
>type.implementsList : any (error)
>type : any (error)
>implementsList : any (error)
>i : number

                    if (iface.isClassInstance()) {
>iface.isClassInstance() : any (error)
>iface.isClassInstance : any (error)
>iface : any (error)
>isClassInstance : any (error)

                        if (derivedIsClass) {
>derivedIsClass : any (error)

                            this.checker.errorReporter.simpleErrorFromSym(type.symbol,
>this.checker.errorReporter.simpleErrorFromSym(type.symbol,                                                                     "A class may only implement an interface; " + iface.symbol.fullName() + " is a class.") : any (error)
>this.checker.errorReporter.simpleErrorFromSym : any (error)
>this.checker.errorReporter : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>errorReporter : any (error)
>simpleErrorFromSym : any (error)
>type.symbol : any (error)
>type : any (error)
>symbol : any (error)

                                                                     "A class may only implement an interface; " + iface.symbol.fullName() + " is a class.");
>"A class may only implement an interface; " + iface.symbol.fullName() + " is a class." : string
>"A class may only implement an interface; " + iface.symbol.fullName() : string
>"A class may only implement an interface; " : "A class may only implement an interface; "
>iface.symbol.fullName() : any (error)
>iface.symbol.fullName : any (error)
>iface.symbol : any (error)
>iface : any (error)
>symbol : any (error)
>fullName : any (error)
>" is a class." : " is a class."
                        }
                    }
                }
            }
        }

        public resolveSignatureGroup(signatureGroup: SignatureGroup, scope: SymbolScope, instanceType: Type) {
>resolveSignatureGroup : (signatureGroup: any (error), scope: any (error), instanceType: any (error)) => void
>signatureGroup : any (error)
>scope : any (error)
>instanceType : any (error)

            var supplyVar = !(signatureGroup.hasImplementation);
>supplyVar : boolean
>!(signatureGroup.hasImplementation) : boolean
>(signatureGroup.hasImplementation) : any (error)
>signatureGroup.hasImplementation : any (error)
>signatureGroup : any (error)
>hasImplementation : any (error)

            for (var i = 0, len = signatureGroup.signatures.length; i < len; i++) {
>i : number
>0 : 0
>len : any (error)
>signatureGroup.signatures.length : any (error)
>signatureGroup.signatures : any (error)
>signatureGroup : any (error)
>signatures : any (error)
>length : any (error)
>i < len : boolean
>i : number
>len : any (error)
>i++ : number
>i : number

                var signature = signatureGroup.signatures[i];
>signature : any (error)
>signatureGroup.signatures[i] : any (error)
>signatureGroup.signatures : any (error)
>signatureGroup : any (error)
>signatures : any (error)
>i : number

                if (instanceType) {
>instanceType : any (error)

                    signature.returnType.type = instanceType;
>signature.returnType.type = instanceType : any (error)
>signature.returnType.type : any (error)
>signature.returnType : any (error)
>signature : any (error)
>returnType : any (error)
>type : any (error)
>instanceType : any (error)
                }
                else {
                    this.checker.resolveTypeLink(scope, signature.returnType, supplyVar);
>this.checker.resolveTypeLink(scope, signature.returnType, supplyVar) : any (error)
>this.checker.resolveTypeLink : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>resolveTypeLink : any (error)
>scope : any (error)
>signature.returnType : any (error)
>signature : any (error)
>returnType : any (error)
>supplyVar : boolean
                }
                var paramLen = signature.parameters.length;
>paramLen : any (error)
>signature.parameters.length : any (error)
>signature.parameters : any (error)
>signature : any (error)
>parameters : any (error)
>length : any (error)

                for (var j = 0; j < paramLen; j++) {
>j : number
>0 : 0
>j < paramLen : boolean
>j : number
>paramLen : any (error)
>j++ : number
>j : number

                    this.bindSymbol(scope, signature.parameters[j]);
>this.bindSymbol(scope, signature.parameters[j]) : void
>this.bindSymbol : (scope: any (error), symbol: Symbol) => void
>this : this
>bindSymbol : (scope: any (error), symbol: Symbol) => void
>scope : any (error)
>signature.parameters[j] : any (error)
>signature.parameters : any (error)
>signature : any (error)
>parameters : any (error)
>j : number
                }
                if (signature.hasVariableArgList) {
>signature.hasVariableArgList : any (error)
>signature : any (error)
>hasVariableArgList : any (error)

                    // check that last parameter has an array type
                    var lastParam = <ParameterSymbol>signature.parameters[paramLen - 1];
>lastParam : any (error)
><ParameterSymbol>signature.parameters[paramLen - 1] : any (error)
>signature.parameters[paramLen - 1] : any (error)
>signature.parameters : any (error)
>signature : any (error)
>parameters : any (error)
>paramLen - 1 : number
>paramLen : any (error)
>1 : 1

                    lastParam.argsOffset = paramLen - 1;
>lastParam.argsOffset = paramLen - 1 : number
>lastParam.argsOffset : any (error)
>lastParam : any (error)
>argsOffset : any (error)
>paramLen - 1 : number
>paramLen : any (error)
>1 : 1

                    if (!lastParam.getType().isArray()) {
>!lastParam.getType().isArray() : boolean
>lastParam.getType().isArray() : any (error)
>lastParam.getType().isArray : any (error)
>lastParam.getType() : any (error)
>lastParam.getType : any (error)
>lastParam : any (error)
>getType : any (error)
>isArray : any (error)

                        this.checker.errorReporter.simpleErrorFromSym(lastParam,
>this.checker.errorReporter.simpleErrorFromSym(lastParam,                                                                 "... parameter must have array type") : any (error)
>this.checker.errorReporter.simpleErrorFromSym : any (error)
>this.checker.errorReporter : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>errorReporter : any (error)
>simpleErrorFromSym : any (error)
>lastParam : any (error)

                                                                 "... parameter must have array type");
>"... parameter must have array type" : "... parameter must have array type"

                        lastParam.parameter.typeLink.type = this.checker.makeArrayType(lastParam.parameter.typeLink.type);
>lastParam.parameter.typeLink.type = this.checker.makeArrayType(lastParam.parameter.typeLink.type) : any (error)
>lastParam.parameter.typeLink.type : any (error)
>lastParam.parameter.typeLink : any (error)
>lastParam.parameter : any (error)
>lastParam : any (error)
>parameter : any (error)
>typeLink : any (error)
>type : any (error)
>this.checker.makeArrayType(lastParam.parameter.typeLink.type) : any (error)
>this.checker.makeArrayType : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>makeArrayType : any (error)
>lastParam.parameter.typeLink.type : any (error)
>lastParam.parameter.typeLink : any (error)
>lastParam.parameter : any (error)
>lastParam : any (error)
>parameter : any (error)
>typeLink : any (error)
>type : any (error)
                    }
                }
            }
        }

        public bindType(scope: SymbolScope, type: Type, instanceType: Type): void {
>bindType : (scope: any (error), type: any (error), instanceType: any (error)) => void
>scope : any (error)
>type : any (error)
>instanceType : any (error)

            if (instanceType) {
>instanceType : any (error)

                this.bindType(scope, instanceType, null);
>this.bindType(scope, instanceType, null) : void
>this.bindType : (scope: any (error), type: any (error), instanceType: any (error)) => void
>this : this
>bindType : (scope: any (error), type: any (error), instanceType: any (error)) => void
>scope : any (error)
>instanceType : any (error)
>null : null
            }
            if (type.hasMembers()) {
>type.hasMembers() : any (error)
>type.hasMembers : any (error)
>type : any (error)
>hasMembers : any (error)

                var members = type.members;
>members : any (error)
>type.members : any (error)
>type : any (error)
>members : any (error)

                var ambientMembers = type.ambientMembers;
>ambientMembers : any (error)
>type.ambientMembers : any (error)
>type : any (error)
>ambientMembers : any (error)

                var typeMembers = type.getAllEnclosedTypes(); // REVIEW: Should only be getting exported types?
>typeMembers : any (error)
>type.getAllEnclosedTypes() : any (error)
>type.getAllEnclosedTypes : any (error)
>type : any (error)
>getAllEnclosedTypes : any (error)

                var ambientTypeMembers = type.getAllAmbientEnclosedTypes(); // REVIEW: Should only be getting exported types?
>ambientTypeMembers : any (error)
>type.getAllAmbientEnclosedTypes() : any (error)
>type.getAllAmbientEnclosedTypes : any (error)
>type : any (error)
>getAllAmbientEnclosedTypes : any (error)

                var memberScope = new SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol);
>memberScope : any (error)
>new SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol) : any (error)
>SymbolTableScope : any (error)
>members : any (error)
>ambientMembers : any (error)
>typeMembers : any (error)
>ambientTypeMembers : any (error)
>type.symbol : any (error)
>type : any (error)
>symbol : any (error)

                var agg = new SymbolAggregateScope(type.symbol);
>agg : any (error)
>new SymbolAggregateScope(type.symbol) : any (error)
>SymbolAggregateScope : any (error)
>type.symbol : any (error)
>type : any (error)
>symbol : any (error)

                var prevCurrentModDecl = this.checker.currentModDecl;
>prevCurrentModDecl : any (error)
>this.checker.currentModDecl : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>currentModDecl : any (error)

                var prevBindStatus = this.checker.inBind;
>prevBindStatus : any (error)
>this.checker.inBind : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>inBind : any (error)

                agg.addParentScope(memberScope);
>agg.addParentScope(memberScope) : any (error)
>agg.addParentScope : any (error)
>agg : any (error)
>addParentScope : any (error)
>memberScope : any (error)

                agg.addParentScope(scope);
>agg.addParentScope(scope) : any (error)
>agg.addParentScope : any (error)
>agg : any (error)
>addParentScope : any (error)
>scope : any (error)

                if (type.isModuleType()) {
>type.isModuleType() : any (error)
>type.isModuleType : any (error)
>type : any (error)
>isModuleType : any (error)

                    this.checker.currentModDecl = <ModuleDeclaration>type.symbol.declAST;
>this.checker.currentModDecl = <ModuleDeclaration>type.symbol.declAST : any (error)
>this.checker.currentModDecl : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>currentModDecl : any (error)
><ModuleDeclaration>type.symbol.declAST : any (error)
>type.symbol.declAST : any (error)
>type.symbol : any (error)
>type : any (error)
>symbol : any (error)
>declAST : any (error)

                    this.checker.inBind = true;
>this.checker.inBind = true : true
>this.checker.inBind : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>inBind : any (error)
>true : true
                }
                if (members) {
>members : any (error)

                    this.bind(agg, type.members.allMembers); // REVIEW: Should only be getting exported types?
>this.bind(agg, type.members.allMembers) : void
>this.bind : (scope: any (error), table: any (error)) => void
>this : this
>bind : (scope: any (error), table: any (error)) => void
>agg : any (error)
>type.members.allMembers : any (error)
>type.members : any (error)
>type : any (error)
>members : any (error)
>allMembers : any (error)
                }
                if (typeMembers) {
>typeMembers : any (error)

                    this.bind(agg, typeMembers.allMembers);
>this.bind(agg, typeMembers.allMembers) : void
>this.bind : (scope: any (error), table: any (error)) => void
>this : this
>bind : (scope: any (error), table: any (error)) => void
>agg : any (error)
>typeMembers.allMembers : any (error)
>typeMembers : any (error)
>allMembers : any (error)
                }
                if (ambientMembers) {
>ambientMembers : any (error)

                    this.bind(agg, ambientMembers.allMembers);
>this.bind(agg, ambientMembers.allMembers) : void
>this.bind : (scope: any (error), table: any (error)) => void
>this : this
>bind : (scope: any (error), table: any (error)) => void
>agg : any (error)
>ambientMembers.allMembers : any (error)
>ambientMembers : any (error)
>allMembers : any (error)
                }
                if (ambientTypeMembers) {
>ambientTypeMembers : any (error)

                    this.bind(agg, ambientTypeMembers.allMembers);
>this.bind(agg, ambientTypeMembers.allMembers) : void
>this.bind : (scope: any (error), table: any (error)) => void
>this : this
>bind : (scope: any (error), table: any (error)) => void
>agg : any (error)
>ambientTypeMembers.allMembers : any (error)
>ambientTypeMembers : any (error)
>allMembers : any (error)
                }
                this.checker.currentModDecl = prevCurrentModDecl;
>this.checker.currentModDecl = prevCurrentModDecl : any (error)
>this.checker.currentModDecl : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>currentModDecl : any (error)
>prevCurrentModDecl : any (error)

                this.checker.inBind = prevBindStatus;
>this.checker.inBind = prevBindStatus : any (error)
>this.checker.inBind : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>inBind : any (error)
>prevBindStatus : any (error)
            }
            if (type.extendsTypeLinks) {
>type.extendsTypeLinks : any (error)
>type : any (error)
>extendsTypeLinks : any (error)

                this.resolveBases(scope, type);
>this.resolveBases(scope, type) : void
>this.resolveBases : (scope: any (error), type: any (error)) => void
>this : this
>resolveBases : (scope: any (error), type: any (error)) => void
>scope : any (error)
>type : any (error)
            }
            if (type.construct) {
>type.construct : any (error)
>type : any (error)
>construct : any (error)

                this.resolveSignatureGroup(type.construct, scope, instanceType);
>this.resolveSignatureGroup(type.construct, scope, instanceType) : void
>this.resolveSignatureGroup : (signatureGroup: any (error), scope: any (error), instanceType: any (error)) => void
>this : this
>resolveSignatureGroup : (signatureGroup: any (error), scope: any (error), instanceType: any (error)) => void
>type.construct : any (error)
>type : any (error)
>construct : any (error)
>scope : any (error)
>instanceType : any (error)
            }
            if (type.call) {
>type.call : any (error)
>type : any (error)
>call : any (error)

                this.resolveSignatureGroup(type.call, scope, null);
>this.resolveSignatureGroup(type.call, scope, null) : void
>this.resolveSignatureGroup : (signatureGroup: any (error), scope: any (error), instanceType: any (error)) => void
>this : this
>resolveSignatureGroup : (signatureGroup: any (error), scope: any (error), instanceType: any (error)) => void
>type.call : any (error)
>type : any (error)
>call : any (error)
>scope : any (error)
>null : null
            }
            if (type.index) {
>type.index : any (error)
>type : any (error)
>index : any (error)

                this.resolveSignatureGroup(type.index, scope, null);
>this.resolveSignatureGroup(type.index, scope, null) : void
>this.resolveSignatureGroup : (signatureGroup: any (error), scope: any (error), instanceType: any (error)) => void
>this : this
>resolveSignatureGroup : (signatureGroup: any (error), scope: any (error), instanceType: any (error)) => void
>type.index : any (error)
>type : any (error)
>index : any (error)
>scope : any (error)
>null : null
            }
            if (type.elementType) {
>type.elementType : any (error)
>type : any (error)
>elementType : any (error)

                this.bindType(scope, type.elementType, null);
>this.bindType(scope, type.elementType, null) : void
>this.bindType : (scope: any (error), type: any (error), instanceType: any (error)) => void
>this : this
>bindType : (scope: any (error), type: any (error), instanceType: any (error)) => void
>scope : any (error)
>type.elementType : any (error)
>type : any (error)
>elementType : any (error)
>null : null
            }
        }

        public bindSymbol(scope: SymbolScope, symbol: Symbol) {
>bindSymbol : (scope: any (error), symbol: Symbol) => void
>scope : any (error)
>symbol : Symbol

            if (!symbol.bound) {
>!symbol.bound : boolean
>symbol.bound : any (error)
>symbol : Symbol
>bound : any (error)

                var prevLocationInfo = this.checker.locationInfo;
>prevLocationInfo : any (error)
>this.checker.locationInfo : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>locationInfo : any (error)

                if ((this.checker.units) && (symbol.unitIndex >= 0) && (symbol.unitIndex < this.checker.units.length)) {
>(this.checker.units) && (symbol.unitIndex >= 0) && (symbol.unitIndex < this.checker.units.length) : boolean
>(this.checker.units) && (symbol.unitIndex >= 0) : boolean
>(this.checker.units) : any (error)
>this.checker.units : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>units : any (error)
>(symbol.unitIndex >= 0) : boolean
>symbol.unitIndex >= 0 : boolean
>symbol.unitIndex : any (error)
>symbol : Symbol
>unitIndex : any (error)
>0 : 0
>(symbol.unitIndex < this.checker.units.length) : boolean
>symbol.unitIndex < this.checker.units.length : boolean
>symbol.unitIndex : any (error)
>symbol : Symbol
>unitIndex : any (error)
>this.checker.units.length : any (error)
>this.checker.units : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>units : any (error)
>length : any (error)

                    this.checker.locationInfo = this.checker.units[symbol.unitIndex];
>this.checker.locationInfo = this.checker.units[symbol.unitIndex] : any (error)
>this.checker.locationInfo : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>locationInfo : any (error)
>this.checker.units[symbol.unitIndex] : any (error)
>this.checker.units : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>units : any (error)
>symbol.unitIndex : any (error)
>symbol : Symbol
>unitIndex : any (error)
                }
                switch (symbol.kind()) {
>symbol.kind() : any (error)
>symbol.kind : any (error)
>symbol : Symbol
>kind : any (error)

                    case SymbolKind.Type:
>SymbolKind.Type : any (error)
>SymbolKind : any (error)
>Type : any (error)

                        if (symbol.flags & SymbolFlags.Bound) {
>symbol.flags & SymbolFlags.Bound : number
>symbol.flags : any (error)
>symbol : Symbol
>flags : any (error)
>SymbolFlags.Bound : any (error)
>SymbolFlags : any (error)
>Bound : any (error)

                            break;
                        }

                        var typeSymbol = <TypeSymbol>symbol;
>typeSymbol : any (error)
><TypeSymbol>symbol : any (error)
>symbol : Symbol

                        typeSymbol.flags |= SymbolFlags.Bound;
>typeSymbol.flags |= SymbolFlags.Bound : number
>typeSymbol.flags : any (error)
>typeSymbol : any (error)
>flags : any (error)
>SymbolFlags.Bound : any (error)
>SymbolFlags : any (error)
>Bound : any (error)

                        // Since type collection happens out of order, a dynamic module referenced by an import statement
                        // may not yet be in scope when the import symbol is created.  In that case, we need to search
                        // out the module symbol now
                        // Note that we'll also want to do this in resolveTypeMembers, in case the symbol is set outside the
                        // context of a given module  (E.g., an outer import statement)
                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name) {
>typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name : boolean
>typeSymbol.aliasLink && !typeSymbol.type : boolean
>typeSymbol.aliasLink : any (error)
>typeSymbol : any (error)
>aliasLink : any (error)
>!typeSymbol.type : boolean
>typeSymbol.type : any (error)
>typeSymbol : any (error)
>type : any (error)
>typeSymbol.aliasLink.alias.nodeType == NodeType.Name : boolean
>typeSymbol.aliasLink.alias.nodeType : any (error)
>typeSymbol.aliasLink.alias : any (error)
>typeSymbol.aliasLink : any (error)
>typeSymbol : any (error)
>aliasLink : any (error)
>alias : any (error)
>nodeType : any (error)
>NodeType.Name : any (error)
>NodeType : any (error)
>Name : any (error)

                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;
>modPath : any (error)
>(<Identifier>typeSymbol.aliasLink.alias).text : any (error)
>(<Identifier>typeSymbol.aliasLink.alias) : any (error)
><Identifier>typeSymbol.aliasLink.alias : any (error)
>typeSymbol.aliasLink.alias : any (error)
>typeSymbol.aliasLink : any (error)
>typeSymbol : any (error)
>aliasLink : any (error)
>alias : any (error)
>text : any (error)

                            var modSym = this.checker.findSymbolForDynamicModule(modPath, this.checker.locationInfo.filename, (id) => scope.find(id, false, true));
>modSym : any (error)
>this.checker.findSymbolForDynamicModule(modPath, this.checker.locationInfo.filename, (id) => scope.find(id, false, true)) : any (error)
>this.checker.findSymbolForDynamicModule : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>findSymbolForDynamicModule : any (error)
>modPath : any (error)
>this.checker.locationInfo.filename : any (error)
>this.checker.locationInfo : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>locationInfo : any (error)
>filename : any (error)
>(id) => scope.find(id, false, true) : (id: any) => any (error)
>id : any
>scope.find(id, false, true) : any (error)
>scope.find : any (error)
>scope : any (error)
>find : any (error)
>id : any
>false : false
>true : true

                            if (modSym) {
>modSym : any (error)

                                typeSymbol.type = modSym.getType();
>typeSymbol.type = modSym.getType() : any (error)
>typeSymbol.type : any (error)
>typeSymbol : any (error)
>type : any (error)
>modSym.getType() : any (error)
>modSym.getType : any (error)
>modSym : any (error)
>getType : any (error)
                            }
                        }

                        if (typeSymbol.type && typeSymbol.type != this.checker.gloModType) {
>typeSymbol.type && typeSymbol.type != this.checker.gloModType : boolean
>typeSymbol.type : any (error)
>typeSymbol : any (error)
>type : any (error)
>typeSymbol.type != this.checker.gloModType : boolean
>typeSymbol.type : any (error)
>typeSymbol : any (error)
>type : any (error)
>this.checker.gloModType : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>gloModType : any (error)

                            this.bindType(scope, typeSymbol.type, typeSymbol.instanceType);
>this.bindType(scope, typeSymbol.type, typeSymbol.instanceType) : void
>this.bindType : (scope: any (error), type: any (error), instanceType: any (error)) => void
>this : this
>bindType : (scope: any (error), type: any (error), instanceType: any (error)) => void
>scope : any (error)
>typeSymbol.type : any (error)
>typeSymbol : any (error)
>type : any (error)
>typeSymbol.instanceType : any (error)
>typeSymbol : any (error)
>instanceType : any (error)

                            // bind expansions on the parent type symbol
                            if (typeSymbol.type.isModuleType()) {
>typeSymbol.type.isModuleType() : any (error)
>typeSymbol.type.isModuleType : any (error)
>typeSymbol.type : any (error)
>typeSymbol : any (error)
>type : any (error)
>isModuleType : any (error)

                                for (var i = 0; i < typeSymbol.expansions.length; i++) {
>i : number
>0 : 0
>i < typeSymbol.expansions.length : boolean
>i : number
>typeSymbol.expansions.length : any (error)
>typeSymbol.expansions : any (error)
>typeSymbol : any (error)
>expansions : any (error)
>length : any (error)
>i++ : number
>i : number

                                    this.bindType(scope, typeSymbol.expansions[i], typeSymbol.instanceType);
>this.bindType(scope, typeSymbol.expansions[i], typeSymbol.instanceType) : void
>this.bindType : (scope: any (error), type: any (error), instanceType: any (error)) => void
>this : this
>bindType : (scope: any (error), type: any (error), instanceType: any (error)) => void
>scope : any (error)
>typeSymbol.expansions[i] : any (error)
>typeSymbol.expansions : any (error)
>typeSymbol : any (error)
>expansions : any (error)
>i : number
>typeSymbol.instanceType : any (error)
>typeSymbol : any (error)
>instanceType : any (error)
                                }
                            }
                        }
                        break;
                    case SymbolKind.Field:
>SymbolKind.Field : any (error)
>SymbolKind : any (error)
>Field : any (error)

                        this.checker.resolveTypeLink(scope, (<FieldSymbol>symbol).field.typeLink,
>this.checker.resolveTypeLink(scope, (<FieldSymbol>symbol).field.typeLink,                                                false) : any (error)
>this.checker.resolveTypeLink : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>resolveTypeLink : any (error)
>scope : any (error)
>(<FieldSymbol>symbol).field.typeLink : any (error)
>(<FieldSymbol>symbol).field : any (error)
>(<FieldSymbol>symbol) : any (error)
><FieldSymbol>symbol : any (error)
>symbol : Symbol
>field : any (error)
>typeLink : any (error)

                                                false);
>false : false

                        break;
                    case SymbolKind.Parameter:
>SymbolKind.Parameter : any (error)
>SymbolKind : any (error)
>Parameter : any (error)

                        this.checker.resolveTypeLink(scope,
>this.checker.resolveTypeLink(scope,                                                (<ParameterSymbol>symbol).parameter.typeLink,                                                true) : any (error)
>this.checker.resolveTypeLink : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>resolveTypeLink : any (error)
>scope : any (error)

                                                (<ParameterSymbol>symbol).parameter.typeLink,
>(<ParameterSymbol>symbol).parameter.typeLink : any (error)
>(<ParameterSymbol>symbol).parameter : any (error)
>(<ParameterSymbol>symbol) : any (error)
><ParameterSymbol>symbol : any (error)
>symbol : Symbol
>parameter : any (error)
>typeLink : any (error)

                                                true);
>true : true

                        break;
                }
                this.checker.locationInfo = prevLocationInfo;
>this.checker.locationInfo = prevLocationInfo : any (error)
>this.checker.locationInfo : any (error)
>this.checker : any (error)
>this : this
>checker : any (error)
>locationInfo : any (error)
>prevLocationInfo : any (error)
            }
            symbol.bound = true;
>symbol.bound = true : true
>symbol.bound : any (error)
>symbol : Symbol
>bound : any (error)
>true : true
        }

        public bind(scope: SymbolScope, table: IHashTable) {
>bind : (scope: any (error), table: any (error)) => void
>scope : any (error)
>table : any (error)

            table.map(
>table.map(                (key, sym, binder) => {                    binder.bindSymbol(scope, sym);                },                this) : any (error)
>table.map : any (error)
>table : any (error)
>map : any (error)

                (key, sym, binder) => {
>(key, sym, binder) => {                    binder.bindSymbol(scope, sym);                } : (key: any, sym: any, binder: any) => void
>key : any
>sym : any
>binder : any

                    binder.bindSymbol(scope, sym);
>binder.bindSymbol(scope, sym) : any
>binder.bindSymbol : any
>binder : any
>bindSymbol : any
>scope : any (error)
>sym : any

                },
                this);
>this : this
        }
    }

}
