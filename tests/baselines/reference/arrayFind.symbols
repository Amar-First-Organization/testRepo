=== tests/cases/compiler/arrayFind.ts ===
// test fix for #18112, type guard predicates should narrow returned element
function isNumber(x: any): x is number {
>isNumber : Symbol(isNumber, Decl(arrayFind.ts, 0, 0))
>x : Symbol(x, Decl(arrayFind.ts, 1, 18))
>x : Symbol(x, Decl(arrayFind.ts, 1, 18))

  return typeof x === "number";
>x : Symbol(x, Decl(arrayFind.ts, 1, 18))
}

const arrayOfStringsNumbersAndBooleans = ["string", false, 0, "strung", 1, true];
>arrayOfStringsNumbersAndBooleans : Symbol(arrayOfStringsNumbersAndBooleans, Decl(arrayFind.ts, 5, 5))

const foundNumber: number | undefined = arrayOfStringsNumbersAndBooleans.find(isNumber);
>foundNumber : Symbol(foundNumber, Decl(arrayFind.ts, 6, 5))
>arrayOfStringsNumbersAndBooleans.find : Symbol(Array.find, Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --))
>arrayOfStringsNumbersAndBooleans : Symbol(arrayOfStringsNumbersAndBooleans, Decl(arrayFind.ts, 5, 5))
>find : Symbol(Array.find, Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --))
>isNumber : Symbol(isNumber, Decl(arrayFind.ts, 0, 0))

const readonlyArrayOfStringsNumbersAndBooleans = arrayOfStringsNumbersAndBooleans as ReadonlyArray<string | number | boolean>;
>readonlyArrayOfStringsNumbersAndBooleans : Symbol(readonlyArrayOfStringsNumbersAndBooleans, Decl(arrayFind.ts, 8, 5))
>arrayOfStringsNumbersAndBooleans : Symbol(arrayOfStringsNumbersAndBooleans, Decl(arrayFind.ts, 5, 5))
>ReadonlyArray : Symbol(ReadonlyArray, Decl(lib.es5.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.iterable.d.ts, --, --))

const readonlyFoundNumber: number | undefined = readonlyArrayOfStringsNumbersAndBooleans.find(isNumber);
>readonlyFoundNumber : Symbol(readonlyFoundNumber, Decl(arrayFind.ts, 9, 5))
>readonlyArrayOfStringsNumbersAndBooleans.find : Symbol(ReadonlyArray.find, Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --))
>readonlyArrayOfStringsNumbersAndBooleans : Symbol(readonlyArrayOfStringsNumbersAndBooleans, Decl(arrayFind.ts, 8, 5))
>find : Symbol(ReadonlyArray.find, Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --))
>isNumber : Symbol(isNumber, Decl(arrayFind.ts, 0, 0))

// test for #38959
interface Foo { kind: "foo"; foo: string; }
>Foo : Symbol(Foo, Decl(arrayFind.ts, 9, 104))
>kind : Symbol(Foo.kind, Decl(arrayFind.ts, 12, 15))
>foo : Symbol(Foo.foo, Decl(arrayFind.ts, 12, 28))

interface Bar { kind: "bar"; bar: string; }
>Bar : Symbol(Bar, Decl(arrayFind.ts, 12, 43))
>kind : Symbol(Bar.kind, Decl(arrayFind.ts, 13, 15))
>bar : Symbol(Bar.bar, Decl(arrayFind.ts, 13, 28))

type FooBar = Foo | Bar;
>FooBar : Symbol(FooBar, Decl(arrayFind.ts, 13, 43))
>Foo : Symbol(Foo, Decl(arrayFind.ts, 9, 104))
>Bar : Symbol(Bar, Decl(arrayFind.ts, 12, 43))

const fooBar: FooBar[] = [];
>fooBar : Symbol(fooBar, Decl(arrayFind.ts, 15, 5))
>FooBar : Symbol(FooBar, Decl(arrayFind.ts, 13, 43))

const foundBar: Bar | undefined = fooBar.find<Bar>((t) => t.kind === "bar" && t.bar === "value");
>foundBar : Symbol(foundBar, Decl(arrayFind.ts, 16, 5))
>Bar : Symbol(Bar, Decl(arrayFind.ts, 12, 43))
>fooBar.find : Symbol(Array.find, Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --))
>fooBar : Symbol(fooBar, Decl(arrayFind.ts, 15, 5))
>find : Symbol(Array.find, Decl(lib.es2015.core.d.ts, --, --), Decl(lib.es2015.core.d.ts, --, --))
>Bar : Symbol(Bar, Decl(arrayFind.ts, 12, 43))
>t : Symbol(t, Decl(arrayFind.ts, 16, 52))
>t.kind : Symbol(kind, Decl(arrayFind.ts, 12, 15), Decl(arrayFind.ts, 13, 15))
>t : Symbol(t, Decl(arrayFind.ts, 16, 52))
>kind : Symbol(kind, Decl(arrayFind.ts, 12, 15), Decl(arrayFind.ts, 13, 15))
>t.bar : Symbol(Bar.bar, Decl(arrayFind.ts, 13, 28))
>t : Symbol(t, Decl(arrayFind.ts, 16, 52))
>bar : Symbol(Bar.bar, Decl(arrayFind.ts, 13, 28))

