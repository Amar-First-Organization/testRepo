//// [tests/cases/compiler/declarationEmitUsingAlternativeContainingModules2.ts] ////

//// [useQuery-CPqkvEsh.d.ts]
type QueryKey = ReadonlyArray<unknown>;

interface Register {}

type DefaultError = Register extends {
  defaultError: infer TError;
}
  ? TError
  : Error;

type ShouldRetryFunction<TError = DefaultError> = (
  failureCount: number,
  error: TError,
) => boolean;
type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>;

type QueryFunctionContext<
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = never,
> = [TPageParam] extends [never]
  ? {
      queryKey: TQueryKey;
    }
  : {
      queryKey: TQueryKey;
      pageParam: TPageParam;
    };

type QueryFunction<
  T = unknown,
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = never,
> = (context: QueryFunctionContext<TQueryKey, TPageParam>) => T | Promise<T>;

interface QueryOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = never,
> {
  retry?: RetryValue<TError>;
  queryFn?: QueryFunction<TQueryFnData, TQueryKey, TPageParam>;
  queryKey?: TQueryKey;
  initialData?: TData;
  initialDataUpdatedAt?: number | (() => number | undefined);
}

interface QueryObserverOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = never,
> extends QueryOptions<
    TQueryFnData,
    TError,
    TQueryData,
    TQueryKey,
    TPageParam
  > {
  enabled?: boolean;
  refetchInterval?: number;
  select?: (data: TQueryData) => TData;
}

type UseQueryOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
> = {
  [Property in keyof QueryObserverOptions<
    TQueryFnData,
    TError,
    TData,
    TQueryData,
    TQueryKey
  >]: QueryObserverOptions<
    TQueryFnData,
    TError,
    TData,
    TQueryData,
    TQueryKey
  >[Property];
};

type UndefinedInitialQueryOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
> = UseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey> & {
  initialData?: undefined;
};

interface QueryObserverBaseResult<TData = unknown, TError = DefaultError> {
  data: TData | undefined;
  dataUpdatedAt: number;
  error: TError | null;
  errorUpdatedAt: number;
  failureCount: number;
  failureReason: TError | null;
  errorUpdateCount: number;
  isError: boolean;
  isFetched: boolean;
  isFetchedAfterMount: boolean;
  isFetching: boolean;
  isLoading: boolean;
  isPending: boolean;
  isLoadingError: boolean;
  isInitialLoading: boolean;
  isPaused: boolean;
  isPlaceholderData: boolean;
  isRefetchError: boolean;
  isRefetching: boolean;
  isStale: boolean;
  isSuccess: boolean;
}

interface QueryObserverSuccessResult<TData = unknown, TError = DefaultError>
  extends QueryObserverBaseResult<TData, TError> {
  data: TData;
  error: null;
  isError: false;
  isPending: false;
  isLoadingError: false;
  isRefetchError: false;
  isSuccess: true;
  status: "success";
}

type DefinedQueryObserverResult<
  TData = unknown,
  TError = DefaultError,
> = QueryObserverSuccessResult<TData, TError>;
type QueryObserverResult<
  TData = unknown,
  TError = DefaultError,
> = DefinedQueryObserverResult<TData, TError>;

type ToRef<T> = {
  value: T;
};

type UseBaseQueryReturnType<
  TData,
  TError,
  Result = QueryObserverResult<TData, TError>,
> = {
  [K in keyof Result]: K extends
    | "fetchNextPage"
    | "fetchPreviousPage"
    | "refetch"
    ? Result[K]
    : ToRef<Readonly<Result>[K]>;
} & {
  suspense: () => Promise<Result>;
};

type UseQueryReturnType<TData, TError> = UseBaseQueryReturnType<TData, TError>;

declare function useQuery<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
>(
  options: UndefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey>,
): UseQueryReturnType<TData, TError>;

export { type UseQueryReturnType as b, useQuery as u };

//// [index.d.ts]
export { b as UseQueryReturnType, u as useQuery } from './useQuery-CPqkvEsh.js';

//// [package.json]
{
  "name": "@tanstack/vue-query",
  "type": "module",
  "exports": {
    ".": {
      "import": {
        "types": "./build/modern/index.d.ts",
        "default": "./build/modern/index.js"
      },
      "require": {
        "types": "./build/modern/index.d.cts",
        "default": "./build/modern/index.cjs"
      }
    }
  }
}

//// [index.mts]
import { useQuery } from '@tanstack/vue-query'

const baseUrl = 'https://api.publicapis.org/'

interface IEntry {
  API: string
  Description: string
  Auth: string
  HTTPS: boolean
  Cors: string
  Link: string
  Category: string
}

const testApi = {
  getEntries: (): Promise<IEntry[]> => {
    return fetch(baseUrl + 'entries')
      .then((res) => res.json())
      .then((data) => data.entries)
      .catch((err) => console.log(err))
  }
}

const entryKeys = {
  all: ['entries'] as const,
  list: () => [...entryKeys.all, 'list'] as const
}

export const useEntries = (): b<IEntry[], Error> => {
  return useQuery({
    queryKey: entryKeys.list(),
    queryFn: testApi.getEntries,
    select: (data) => data.slice(0, 10)
  })
}


/// [Declarations] ////



//// [src/index.d.mts]
interface IEntry {
    API: string;
    Description: string;
    Auth: string;
    HTTPS: boolean;
    Cors: string;
    Link: string;
    Category: string;
}
export declare const useEntries: () => b<IEntry[], Error>;
export {};
//# sourceMappingURL=index.d.mts.map

/// [Declarations Maps] ////


//// [src/index.d.mts.map]
{"version":3,"file":"index.d.mts","sourceRoot":"","sources":["index.mts"],"names":[],"mappings":"AAIA,UAAU,MAAM;IACd,GAAG,EAAE,MAAM,CAAA;IACX,WAAW,EAAE,MAAM,CAAA;IACnB,IAAI,EAAE,MAAM,CAAA;IACZ,KAAK,EAAE,OAAO,CAAA;IACd,IAAI,EAAE,MAAM,CAAA;IACZ,IAAI,EAAE,MAAM,CAAA;IACZ,QAAQ,EAAE,MAAM,CAAA;CACjB;AAgBD,eAAO,MAAM,UAAU,0BAMtB,CAAA"}

//// https://sokra.github.io/source-map-visualization#base64,aW50ZXJmYWNlIElFbnRyeSB7DQogICAgQVBJOiBzdHJpbmc7DQogICAgRGVzY3JpcHRpb246IHN0cmluZzsNCiAgICBBdXRoOiBzdHJpbmc7DQogICAgSFRUUFM6IGJvb2xlYW47DQogICAgQ29yczogc3RyaW5nOw0KICAgIExpbms6IHN0cmluZzsNCiAgICBDYXRlZ29yeTogc3RyaW5nOw0KfQ0KZXhwb3J0IGRlY2xhcmUgY29uc3QgdXNlRW50cmllczogKCkgPT4gYjxJRW50cnlbXSwgRXJyb3I+Ow0KZXhwb3J0IHt9Ow0KLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZC5tdHMubWFw,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZC5tdHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC5tdHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBSUEsVUFBVSxNQUFNO0lBQ2QsR0FBRyxFQUFFLE1BQU0sQ0FBQTtJQUNYLFdBQVcsRUFBRSxNQUFNLENBQUE7SUFDbkIsSUFBSSxFQUFFLE1BQU0sQ0FBQTtJQUNaLEtBQUssRUFBRSxPQUFPLENBQUE7SUFDZCxJQUFJLEVBQUUsTUFBTSxDQUFBO0lBQ1osSUFBSSxFQUFFLE1BQU0sQ0FBQTtJQUNaLFFBQVEsRUFBRSxNQUFNLENBQUE7Q0FDakI7QUFnQkQsZUFBTyxNQUFNLFVBQVUsMEJBTXRCLENBQUEifQ==,aW1wb3J0IHsgdXNlUXVlcnkgfSBmcm9tICdAdGFuc3RhY2svdnVlLXF1ZXJ5JwoKY29uc3QgYmFzZVVybCA9ICdodHRwczovL2FwaS5wdWJsaWNhcGlzLm9yZy8nCgppbnRlcmZhY2UgSUVudHJ5IHsKICBBUEk6IHN0cmluZwogIERlc2NyaXB0aW9uOiBzdHJpbmcKICBBdXRoOiBzdHJpbmcKICBIVFRQUzogYm9vbGVhbgogIENvcnM6IHN0cmluZwogIExpbms6IHN0cmluZwogIENhdGVnb3J5OiBzdHJpbmcKfQoKY29uc3QgdGVzdEFwaSA9IHsKICBnZXRFbnRyaWVzOiAoKTogUHJvbWlzZTxJRW50cnlbXT4gPT4gewogICAgcmV0dXJuIGZldGNoKGJhc2VVcmwgKyAnZW50cmllcycpCiAgICAgIC50aGVuKChyZXMpID0+IHJlcy5qc29uKCkpCiAgICAgIC50aGVuKChkYXRhKSA9PiBkYXRhLmVudHJpZXMpCiAgICAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmxvZyhlcnIpKQogIH0KfQoKY29uc3QgZW50cnlLZXlzID0gewogIGFsbDogWydlbnRyaWVzJ10gYXMgY29uc3QsCiAgbGlzdDogKCkgPT4gWy4uLmVudHJ5S2V5cy5hbGwsICdsaXN0J10gYXMgY29uc3QKfQoKZXhwb3J0IGNvbnN0IHVzZUVudHJpZXMgPSAoKTogYjxJRW50cnlbXSwgRXJyb3I+ID0+IHsKICByZXR1cm4gdXNlUXVlcnkoewogICAgcXVlcnlLZXk6IGVudHJ5S2V5cy5saXN0KCksCiAgICBxdWVyeUZuOiB0ZXN0QXBpLmdldEVudHJpZXMsCiAgICBzZWxlY3Q6IChkYXRhKSA9PiBkYXRhLnNsaWNlKDAsIDEwKQogIH0pCn0K

