//// [tests/cases/compiler/reverseMappedDefaultInferenceToConstraint.ts] ////

=== reverseMappedDefaultInferenceToConstraint.ts ===
// https://github.com/microsoft/TypeScript/issues/56241

interface ParameterizedObject {
  type: string;
>type : string

  params?: Record<string, unknown>;
>params : Record<string, unknown> | undefined
}

declare function setup<
>setup : <TContext, TGuards extends Record<string, Record<string, unknown> | undefined>>(_: { types: {    context: TContext;}; guards: { [K in keyof TGuards]: (context: TContext, params: TGuards[K]) => void; }; }) => TGuards

  TContext,
  TGuards extends Record<string, ParameterizedObject["params"] | undefined>,
>(_: {
>_ : { types: {    context: TContext;}; guards: { [K in keyof TGuards]: (context: TContext, params: TGuards[K]) => void; }; }

  types: {
>types : { context: TContext; }

    context: TContext;
>context : TContext

  };
  guards: {
>guards : { [K in keyof TGuards]: (context: TContext, params: TGuards[K]) => void; }

    [K in keyof TGuards]: (context: TContext, params: TGuards[K]) => void;
>context : TContext
>params : TGuards[K]

  };
}): TGuards;

const result = setup({
>result : { checkFoo: { foo: string; }; alwaysTrue: Record<string, unknown> | undefined; }
>setup({  types: {    context: {      count: 100,    },  },  guards: {    checkFoo: (_, { foo }: { foo: string }) => foo === "foo",    alwaysTrue: (_) => true,  },}) : { checkFoo: { foo: string; }; alwaysTrue: Record<string, unknown> | undefined; }
>setup : <TContext, TGuards extends Record<string, Record<string, unknown> | undefined>>(_: { types: { context: TContext; }; guards: { [K in keyof TGuards]: (context: TContext, params: TGuards[K]) => void; }; }) => TGuards
>{  types: {    context: {      count: 100,    },  },  guards: {    checkFoo: (_, { foo }: { foo: string }) => foo === "foo",    alwaysTrue: (_) => true,  },} : { types: { context: { count: number; }; }; guards: { checkFoo: (_: { count: number; }, { foo }: { foo: string; }) => boolean; alwaysTrue: (_: { count: number; }) => boolean; }; }

  types: {
>types : { context: { count: number; }; }
>{    context: {      count: 100,    },  } : { context: { count: number; }; }

    context: {
>context : { count: number; }
>{      count: 100,    } : { count: number; }

      count: 100,
>count : number
>100 : 100

    },
  },
  guards: {
>guards : { checkFoo: (_: { count: number; }, { foo }: { foo: string; }) => boolean; alwaysTrue: (_: { count: number; }) => boolean; }
>{    checkFoo: (_, { foo }: { foo: string }) => foo === "foo",    alwaysTrue: (_) => true,  } : { checkFoo: (_: { count: number; }, { foo }: { foo: string; }) => boolean; alwaysTrue: (_: { count: number; }) => boolean; }

    checkFoo: (_, { foo }: { foo: string }) => foo === "foo",
>checkFoo : (_: { count: number; }, { foo }: { foo: string; }) => boolean
>(_, { foo }: { foo: string }) => foo === "foo" : (_: { count: number; }, { foo }: { foo: string; }) => boolean
>_ : { count: number; }
>foo : string
>foo : string
>foo === "foo" : boolean
>foo : string
>"foo" : "foo"

    alwaysTrue: (_) => true,
>alwaysTrue : (_: { count: number; }) => boolean
>(_) => true : (_: { count: number; }) => boolean
>_ : { count: number; }
>true : true

  },
});

declare function foo<
>foo : <T extends Record<PropertyKey, U>, U extends number | boolean>(a: { [K in keyof T]: (arg: T[K]) => void; }, b: U) => T

  T extends Record<PropertyKey, U>,
  U extends number | boolean,
>(
  a: {
>a : { [K in keyof T]: (arg: T[K]) => void; }

    [K in keyof T]: (arg: T[K]) => void;
>arg : T[K]

  },
  b: U,
>b : U

): T;

declare const num: number;
>num : number

const result1 = foo(
>result1 : { a: number; b: number; }
>foo(  {    a: (arg) => {},    b: () => {},  },  num,) : { a: number; b: number; }
>foo : <T extends Record<PropertyKey, U>, U extends number | boolean>(a: { [K in keyof T]: (arg: T[K]) => void; }, b: U) => T
  {
>{    a: (arg) => {},    b: () => {},  } : { a: (arg: number) => void; b: () => void; }

    a: (arg) => {},
>a : (arg: number) => void
>(arg) => {} : (arg: number) => void
>arg : number

    b: () => {},
>b : () => void
>() => {} : () => void

  },
  num,
>num : number

);

const result2 = foo(
>result2 : { a: 100; b: number; }
>foo(  {    a: (arg: 100) => {},    b: () => {},  },  num,) : { a: 100; b: number; }
>foo : <T extends Record<PropertyKey, U>, U extends number | boolean>(a: { [K in keyof T]: (arg: T[K]) => void; }, b: U) => T
  {
>{    a: (arg: 100) => {},    b: () => {},  } : { a: (arg: 100) => void; b: () => void; }

    a: (arg: 100) => {},
>a : (arg: 100) => void
>(arg: 100) => {} : (arg: 100) => void
>arg : 100

    b: () => {},
>b : () => void
>() => {} : () => void

  },
  num,
>num : number

);

