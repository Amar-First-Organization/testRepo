=== tests/cases/compiler/a.js ===
//
// Variables
//

/**
 * @type {string}
 */
var var1;
>var1 : string

/** @type {Window} */
var var2;
>var2 : any

/** @type {PromiseLike<string>} */
var var3;
>var3 : PromiseLike<string>

/**
 * The type specifier can specify a union type - e.g. a string or a boolean
 * @type {(string | boolean)}
 */
var var4;
>var4 : string | boolean

/**
 * Note that parens are options for union types
 * @type {string | boolean}
 */
var var5;
>var5 : string | boolean


// You can specify an array type (e.g. an array of numbers)
/** @type {number[]} */
var var6;
>var6 : number[]

// An array of numbers (alternate syntax)
/** @type {Array.<number>} */
var var7;
>var7 : number[]

/** @type {Array<number>} */
var var8;
>var8 : number[]


// An object specification may also be used within the braces
// For example, an object used as a boolean map
/** @type {{[a: string]: boolean}} */
var var9;
>var9 : { [a: string]: boolean; }

//
// Typedefs
//

// "@typedef" maybe used to define complex types
/**
 * @typedef {Object} SpecialType - creates a new type named 'SpecialType'
 * @property {string} prop1 - a string property of SpecialType
 * @property {number} prop2 - a number property of SpecialType
 * @property {number=} prop3 - an optional number property of SpecialType
 * @prop {number} [prop4] - an optional number property of SpecialType
 * @prop {number} [prop5=42] - an optional number property of SpecialType with default value
 */
/** @type {SpecialType} */
var specialTypeObject;
>specialTypeObject : { prop1: string; prop2: number; prop3?: number; prop4?: number; prop5?: number; }

// You can use both 'object' and 'Object'
/**
 * @typedef {object} SpecialType1 - creates a new type named 'SpecialType'
 * @property {string} prop1 - a string property of SpecialType
 * @property {number} prop2 - a number property of SpecialType
 * @property {number=} prop3 - an optional number property of SpecialType
 */
/** @type {SpecialType1} */
var specialTypeObject1;
>specialTypeObject1 : { prop1: string; prop2: number; prop3?: number; }


//
// Functions
//

// Likewise, for the return type of a function
/**
 * @return {PromiseLike<string>}
 */
function fn1() { }
>fn1 : () => PromiseLike<string>

/**
 * @returns {{a: string, b: number}} - May use '@returns' as well as '@return'
 */
function fn2() { }
>fn2 : () => { a: string; b: number; }


// Parameters may be declared in a variety of syntactic forms
/**
 * @param p0 {string} - A string param declared using TS-style
 * @param {string}  p1 - A string param.
 * @param {string=} p2 - An optional param
 * @param {string} [p3] - Another optional param.
 * @param {string} [p4="test"] - An optional param with a default value
 * @return {string} This is the result
 */
function fn3(p0, p1, p2, p3, p4) {
>fn3 : (p0: string, p1: string, p2?: string, p3?: string, p4?: string) => string
>p0 : string
>p1 : string
>p2 : string
>p3 : string
>p4 : string

  // TODO
}


// Generic types may also be used
/**
 * @template T
 * @param {T} p1 - A generic parameter that flows through to the return type
 * @return {T}
 */
function fn4(p1) { }
>fn4 : <T>(p1: T) => T
>p1 : T

// Define function type
/** @type {function(string, boolean): number} */
var fn5;
>fn5 : (arg0: string, arg1: boolean) => number

// Both "fn6" and "fn7" have same type of Function type.
/** @type {function} */
var fn6;
>fn6 : Function

/** @type {Function} */
var fn7;
>fn7 : Function

/**
 * @param {*} p1 - Param can be 'any' type
 * @param {?} p2 - Param is of unknown type (same as 'any')
 */
function fn8(p1, p2) { }
>fn8 : (p1: any, p2: any) => void
>p1 : any
>p2 : any

var someObj = {
>someObj : { [x: string]: any; x: (param1: string) => void; }
>{  /**   * @param {string} param1 - Docs on property assignments work   */  x: function (param1) { }} : { [x: string]: any; x: (param1: string) => void; }

  /**
   * @param {string} param1 - Docs on property assignments work
   */
  x: function (param1) { }
>x : (param1: string) => void
>function (param1) { } : (param1: string) => void
>param1 : string

};

/**
 * As do docs on variable assignments
 * @return {Window}
 */
let someFunc = function () { };
>someFunc : () => any
>function () { } : () => any

var Foo = function() {}
>Foo : () => void
>function() {} : () => void

/**
 * And class methods
 * @param {string} greeting The greeting to use
 */
Foo.prototype.sayHi = (greeting) => console.log("Hi!");
>Foo.prototype.sayHi = (greeting) => console.log("Hi!") : (greeting: string) => any
>Foo.prototype.sayHi : any
>Foo.prototype : any
>Foo : () => void
>prototype : any
>sayHi : any
>(greeting) => console.log("Hi!") : (greeting: string) => any
>greeting : string
>console.log("Hi!") : any
>console.log : any
>console : any
>log : any
>"Hi!" : "Hi!"

/**
 * And arrow functions expressions
 * @param {number} x - A multiplier
 */
let myArrow = x => x * x;
>myArrow : (x: number) => number
>x => x * x : (x: number) => number
>x : number
>x * x : number
>x : number
>x : number


/**
 * A parameter can be a class constructor.
 *
 * @param {{new(...args: any[]): object}} C - The class to register
 */
function registerClass(C) { }
>registerClass : (C: new (...args: any[]) => any) => void
>C : new (...args: any[]) => any

/**
 * ES6 Classes
 */
class IconComponent {
>IconComponent : IconComponent

  /** @readonly */
  static observedAttributes() {
>observedAttributes : () => string[]

    return ['icon']
>['icon'] : string[]
>'icon' : "icon"
  }

  constructor() {}

  /**
   * @param name {string}
   * @param oldValue {null | string}
   * @param newValue {null | string}
   */
  attributeChangedCallback(name, oldValue, newValue) {}
>attributeChangedCallback : (name: string, oldValue: string, newValue: string) => void
>name : string
>oldValue : string
>newValue : string

  /** @private */
  _render() {}
>_render : () => void
}

