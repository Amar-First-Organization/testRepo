=== tests/cases/compiler/newOperator.ts ===
interface ifc { }
// Attempting to 'new' an interface yields poor error
var i = new ifc();
>i : any (error)
>new ifc() : any (error)
>ifc : any (error)

// Parens are optional
var x = new Date;
>x : Date
>new Date : Date
>Date : DateConstructor

var y = new Date();
>y : Date
>new Date() : Date
>Date : DateConstructor

// Target is not a class or var, good error
var t1 = new 53();
>t1 : any (error)
>new 53() : any (error)
>53 : 53

var t2 = new ''();
>t2 : any (error)
>new ''() : any (error)
>'' : ""

new string;
>new string : any (error)
>string : any (error)

// Use in LHS of expression?
(new Date()).toString();
>(new Date()).toString() : string
>(new Date()).toString : () => string
>(new Date()) : Date
>new Date() : Date
>Date : DateConstructor
>toString : () => string

// Various spacing
var t3 = new string[]( );
>t3 : any (error)
>new string[]( ) : any (error)
>string[] : any (error)
>string : any (error)
> : any (error)

var t4 =
>t4 : any (error)

new
>newstring[    ]    (        ) : any (error)

string
>string[    ] : any (error)
>string : any (error)

[
    ]
> : any (error)

    (
        );

// Unresolved symbol
var f = new q();
>f : any (error)
>new q() : any (error)
>q : any (error)

// not legal
var t5 = new new Date;
>t5 : any (error)
>new new Date : any (error)
>new Date : Date
>Date : DateConstructor

// Can be an expression
new String;
>new String : String
>String : StringConstructor


module M {
>M : typeof M

    export class T {
>T : T

        x: number;
>x : number
    }
}

class S {
>S : S

    public get xs(): M.T[] {
>xs : M.T[]
>M : any (error)

        return new M.T[];
>new M.T[] : any
>M.T[] : any
>M.T : typeof M.T
>M : typeof M
>T : typeof M.T
> : any (error)
    }
}

