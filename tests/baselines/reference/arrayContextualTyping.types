=== tests/cases/compiler/arrayContextualTyping.ts ===
// Setup
declare class MyCustomArray extends Array<number> {
>MyCustomArray : MyCustomArray
>Array : number[]

    isCustom: true;
>isCustom : true
>true : true
}

// MVP: An empty array contextually typed by an array type gets that array's type
const m1 = [] satisfies number[];
>m1 : number[]
>[] satisfies number[] : number[]
>[] : number[]

m1.push(0); // Should be OK
>m1.push(0) : number
>m1.push : (...items: number[]) => number
>m1 : number[]
>push : (...items: number[]) => number
>0 : 0

m1.push(""); // Should error
>m1.push("") : number
>m1.push : (...items: number[]) => number
>m1 : number[]
>push : (...items: number[]) => number
>"" : ""

// Works in object fields?
const m2 = { a: [] satisfies string[] };
>m2 : { a: string[]; }
>{ a: [] satisfies string[] } : { a: string[]; }
>a : string[]
>[] satisfies string[] : string[]
>[] : string[]

m2.a.push(""); // Should be OK
>m2.a.push("") : number
>m2.a.push : (...items: string[]) => number
>m2.a : string[]
>m2 : { a: string[]; }
>a : string[]
>push : (...items: string[]) => number
>"" : ""

m2.a.push(0); // Should error
>m2.a.push(0) : number
>m2.a.push : (...items: string[]) => number
>m2.a : string[]
>m2 : { a: string[]; }
>a : string[]
>push : (...items: string[]) => number
>0 : 0

// If the contextual type is a union, keep the array-supertyping parts of the union
const m3 = [] satisfies number[] | ArrayLike<string>;
>m3 : number[]
>[] satisfies number[] | ArrayLike<string> : number[]
>[] : number[]

const m3t: number[] | string[] = m3;
>m3t : number[] | string[]
>m3 : number[]

// Keep only the array parts
const m4 = [] satisfies MyCustomArray | string[];
>m4 : never[]
>[] satisfies MyCustomArray | string[] : never[]
>[] : never[]

const m4t: string[] = m4;
>m4t : string[]
>m4 : never[]

// Should OK
const m5: string[] | number[] = [] satisfies string[] | number[];
>m5 : number[] | string[]
>[] satisfies string[] | number[] : never[]
>[] : never[]

// Should OK
type Obj = { a: string[] } | { a: number[] };
>Obj : { a: string[]; } | { a: number[]; }
>a : string[]
>a : number[]

const m6: Obj = { a: [] } satisfies Obj;
>m6 : Obj
>{ a: [] } satisfies Obj : { a: never[]; }
>{ a: [] } : { a: never[]; }
>a : never[]
>[] : never[]

// Should all OK
type DiscrObj = { a: string[], kind: "strings" } | { a: number[], kind: "numbers" };
>DiscrObj : { a: string[]; kind: "strings"; } | { a: number[]; kind: "numbers"; }
>a : string[]
>kind : "strings"
>a : number[]
>kind : "numbers"

const m7: DiscrObj = { a: [], kind: "numbers"};
>m7 : DiscrObj
>{ a: [], kind: "numbers"} : { a: number[]; kind: "numbers"; }
>a : number[]
>[] : number[]
>kind : "numbers"
>"numbers" : "numbers"

const m8: DiscrObj = { a: [], kind: "numbers"} satisfies DiscrObj;
>m8 : DiscrObj
>{ a: [], kind: "numbers"} satisfies DiscrObj : { a: number[]; kind: "numbers"; }
>{ a: [], kind: "numbers"} : { a: number[]; kind: "numbers"; }
>a : number[]
>[] : number[]
>kind : "numbers"
>"numbers" : "numbers"

const m9: DiscrObj = { a: [], kind: "strings"} satisfies DiscrObj;
>m9 : DiscrObj
>{ a: [], kind: "strings"} satisfies DiscrObj : { a: string[]; kind: "strings"; }
>{ a: [], kind: "strings"} : { a: string[]; kind: "strings"; }
>a : string[]
>[] : string[]
>kind : "strings"
>"strings" : "strings"

