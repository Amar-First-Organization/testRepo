tests/cases/compiler/noImplicitOverride.ts(5,7): error TS2300: Duplicate identifier 'RejectWhenOverrideAbsentOnInheritedMethod'.
tests/cases/compiler/noImplicitOverride.ts(6,5): error TS2570: Class member 'toString' must be marked 'override' when noImplicitOverride is enabled (inherited from Object)
tests/cases/compiler/noImplicitOverride.ts(8,7): error TS2300: Duplicate identifier 'AcceptWhenOverridePresentOnInheritedMethod'.
tests/cases/compiler/noImplicitOverride.ts(14,5): error TS2570: Class member 'toString' must be marked 'override' when noImplicitOverride is enabled (inherited from Object)
tests/cases/compiler/noImplicitOverride.ts(23,5): error TS2322: Type '() => number' is not assignable to type '() => string'.
  Class member 'toString' must be marked 'override' when noImplicitOverride is enabled (inherited from Object)
tests/cases/compiler/noImplicitOverride.ts(45,12): error TS2570: Class member 'userId' must be marked 'override' when noImplicitOverride is enabled (inherited from Base)
tests/cases/compiler/noImplicitOverride.ts(52,9): error TS2570: Class member 'name' must be marked 'override' when noImplicitOverride is enabled (inherited from Base)
tests/cases/compiler/noImplicitOverride.ts(58,7): error TS2300: Duplicate identifier 'RejectWhenOverrideAbsentOnInheritedMethod'.
tests/cases/compiler/noImplicitOverride.ts(59,5): error TS2570: Class member 'getMeaningOfLife' must be marked 'override' when noImplicitOverride is enabled (inherited from Base)
tests/cases/compiler/noImplicitOverride.ts(61,7): error TS2300: Duplicate identifier 'AcceptWhenOverridePresentOnInheritedMethod'.
tests/cases/compiler/noImplicitOverride.ts(65,7): error TS2415: Class 'RejectWhenOverridePresentWithPrivateModifier' incorrectly extends base class 'Base'.
  Types have separate declarations of a private property 'processInternal'.
tests/cases/compiler/noImplicitOverride.ts(66,13): error TS1243: 'private' modifier cannot be used with 'override' modifier.
tests/cases/compiler/noImplicitOverride.ts(79,5): error TS1070: 'override' modifier cannot appear on a type member.
tests/cases/compiler/noImplicitOverride.ts(102,14): error TS1243: 'abstract' modifier cannot be used with 'override' modifier.
tests/cases/compiler/noImplicitOverride.ts(122,5): error TS2570: Class member 'normal' must be marked 'override' when noImplicitOverride is enabled (inherited from <typeof A>.(Anonymous class) & A)
tests/cases/compiler/noImplicitOverride.ts(123,5): error TS2570: Class member 'mixedIn' must be marked 'override' when noImplicitOverride is enabled (inherited from <typeof A>.(Anonymous class) & A)


==== tests/cases/compiler/noImplicitOverride.ts (16 errors) ====
    // ******************************************************
    // First set of cases deal with inheritance from Object. 
    // ******************************************************
    
    class RejectWhenOverrideAbsentOnInheritedMethod extends Object {
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2300: Duplicate identifier 'RejectWhenOverrideAbsentOnInheritedMethod'.
        toString(): string { return 'foo'; };
        ~~~~~~~~
!!! error TS2570: Class member 'toString' must be marked 'override' when noImplicitOverride is enabled (inherited from Object)
    }
    class AcceptWhenOverridePresentOnInheritedMethod extends Object {
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2300: Duplicate identifier 'AcceptWhenOverridePresentOnInheritedMethod'.
        override toString(): string { return 'foo'; };
    }
    
    // Similar to previous cases where augmentation from Object is implicit
    class RejectWhenOverrideAbsentOnAugmentedProperty {
        toString(): string { return 'foo'; };
        ~~~~~~~~
!!! error TS2570: Class member 'toString' must be marked 'override' when noImplicitOverride is enabled (inherited from Object)
    }
    class AcceptWhenOverridePresentOnAugumentedProperty extends Object {
        override toString(): string { return 'foo'; };
    }
    
    // This should fail via type mismatch of the return value.
    // (test is not specific to the override checking code)
    class RejectWhenOverrideTypeMismatchOnMethodThatMasksObjectTypeMember {
        toString(): number {
        ~~~~~~~~
!!! error TS2322: Type '() => number' is not assignable to type '() => string'.
!!! error TS2322:   Class member 'toString' must be marked 'override' when noImplicitOverride is enabled (inherited from Object)
            return -1;
        }
    }
    
    // ******************************************************
    // Next set of cases deal with inheritance derived from 
    // an explicitly defined class. 
    // ******************************************************
    
    class Base {
        // Public property
        public userId: number = 1;
        // Accessor
        get name(): string { return 'Base'; }
        // Typical public method
        getMeaningOfLife(): number { return 42; }
        // Private method
        private processInternal(): void { }
    }
    
    class RejectWhenOverrideAbsentOnInheritedProperty extends Base {
        public userId = 2;
               ~~~~~~
!!! error TS2570: Class member 'userId' must be marked 'override' when noImplicitOverride is enabled (inherited from Base)
    }
    class AcceptWhenOverridePresentOnInheritedProperty extends Base {
        public override userId = 2;
    }
    
    class RejectWhenOverrideAbsentOnInheritedAccessor extends Base {
        get name(): string { return 'foo'; };
            ~~~~
!!! error TS2570: Class member 'name' must be marked 'override' when noImplicitOverride is enabled (inherited from Base)
    }
    class AcceptWhenOverridePresentOnInheritedAccessor extends Base {
        override get name(): string { return 'foo'; };
    }
    
    class RejectWhenOverrideAbsentOnInheritedMethod extends Base {
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2300: Duplicate identifier 'RejectWhenOverrideAbsentOnInheritedMethod'.
        getMeaningOfLife(): number { return 24; };
        ~~~~~~~~~~~~~~~~
!!! error TS2570: Class member 'getMeaningOfLife' must be marked 'override' when noImplicitOverride is enabled (inherited from Base)
    }
    class AcceptWhenOverridePresentOnInheritedMethod extends Base {
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2300: Duplicate identifier 'AcceptWhenOverridePresentOnInheritedMethod'.
        override getMeaningOfLife(): number { return 24; };
    }
    
    class RejectWhenOverridePresentWithPrivateModifier extends Base {
          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2415: Class 'RejectWhenOverridePresentWithPrivateModifier' incorrectly extends base class 'Base'.
!!! error TS2415:   Types have separate declarations of a private property 'processInternal'.
        private override processInternal() { }
                ~~~~~~~~
!!! error TS1243: 'private' modifier cannot be used with 'override' modifier.
    }
    
    // ******************************************************
    // Next set of cases deal with override within interfaces
    // and abstract classes (where is should not be present). 
    // ******************************************************
    
    interface Shape {
        getWidth(): number;
    }
    
    interface RejectWhenOverridePresentOnInterfaceDeclaration extends Shape {
        override getWidth(): number;
        ~~~~~~~~
!!! error TS1070: 'override' modifier cannot appear on a type member.
    }
    
    interface AcceptWhenOverrideAbsentOnInterfaceDeclaration extends Shape {
        getWidth(): number;
    }
    
    // ******************************************************
    // Next set of cases deal with override with abstract 
    // classes. 
    // ******************************************************
    
    abstract class Animal {
        protected readonly name: string
    
        constructor(name: string) {
            this.name = name;
        }
    
        abstract speak(): string;
    }
    
    abstract class RejectWhenOverridePresentWithAbstractModifier extends Animal {
        abstract override speak(): string;
                 ~~~~~~~~
!!! error TS1243: 'abstract' modifier cannot be used with 'override' modifier.
    }
    
    abstract class AcceptWhenOverridePresentOnConcreteDeclaration extends Animal {
        override speak(): string { return "Woof!"; }
    }
    
    // ******************************************************
    // Next set of cases deal with override with mixins 
    // ******************************************************
    
    const mixin = <BC extends new (...args: any[]) => {}>(Base: BC) => class extends Base {
        mixedIn() {}
    };
    
    class A {
        normal() {}
    }
    
    class RejectWhenOverrideAbsentOnInheritedMethodMixin extends mixin(A) {
        normal() {} 
        ~~~~~~
!!! error TS2570: Class member 'normal' must be marked 'override' when noImplicitOverride is enabled (inherited from <typeof A>.(Anonymous class) & A)
        mixedIn() {} 
        ~~~~~~~
!!! error TS2570: Class member 'mixedIn' must be marked 'override' when noImplicitOverride is enabled (inherited from <typeof A>.(Anonymous class) & A)
    }
    
    class AcceptWhenOverridePresentOnInheritedMethodMixin extends mixin(A) {
        override normal() {} 
        override mixedIn() {} 
    }
    
    // ********************************************************
    // Next set of cases deal with override specified via JsDoc
    // ********************************************************
    
    //class AcceptWhenOverrideSpecifiedByJSDocAnnotation extends Animal {
    //    /** @override */ public speak(): string { return "Woof!" }
    //}
    